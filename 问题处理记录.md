# 代码中常见问题处理



## SpringBoot 2.0中JPA的findOne()方法异常解决方法



### springboot java.util.NoSuchElementException: No value present 异常处理

使用jpa查询的时候，如果查询不到数据，就会返回这个错误，下面是处理方法。

```java
    @Override
    public User findByEmail(String email) {
        User user = new User();
        user.setEmail(email);
        Example<User> example = Example.of(user);
        Optional<User> optional = userDao.findOne(example);

        return optional.isPresent() ? optional.get(): null;
    }
```



### SpringBoot 2.0中JPA的findOne()方法异常解决方法

在用SpringBoot 2的时候，发现使用Spring Data JPA 的自带findOne()方法时，不像以前那样可以通过直接使用：

```
xxxRepository.findOne(id)
1
```

传入id来获取一个对象。查看源码发现findOne方法变成了如下所示：

```
<S extends T> Optional<S> findOne(Example<S> var1);
1
```

原来是自从spring boot 2.0以后，由于用上了Java 8 的Optional，废除了原来的findOne(Id)。

> Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。

findById()方法也使用了Optional，废除了原来的方法：

```
Optional<T> findById(ID var1);
1
```

**解决方法**：调用findById方法返回Optional对象，再调用Optional的get()方法返回该对象，即用`xxxRepository.findById(id).get()`代替原来的findOne(id）方法。



### 在撸SpringBoot2.0+的时候，JpaRepository中的findOne()传id报错

```java
Inferred type 'S' for type parameter 'S' is not within its bound; 
```

SpringBoot 1.+的版本JpaRepository为

```java
@NoRepositoryBean
public interface CrudRepository<T, ID extends Serializable> extends Repository<T, ID> {
    <S extends T> S save(S var1);
    <S extends T> Iterable<S> save(Iterable<S> var1);
    T findOne(ID var1);
    boolean exists(ID var1);
    Iterable<T> findAll();
    Iterable<T> findAll(Iterable<ID> var1);
    long count();
    void delete(ID var1);
    void delete(T var1);
    void delete(Iterable<? extends T> var1);
    void deleteAll();
}
```

SpringBoot2+版本的JpaRepository为

```dart
@NoRepositoryBean
public interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T> {
    List<T> findAll();
    List<T> findAll(Sort var1);
    List<T> findAllById(Iterable<ID> var1);
    <S extends T> List<S> saveAll(Iterable<S> var1);
    void flush();
    <S extends T> S saveAndFlush(S var1);
    void deleteInBatch(Iterable<T> var1);
    void deleteAllInBatch();
    T getOne(ID var1);
    <S extends T> List<S> findAll(Example<S> var1);
    <S extends T> List<S> findAll(Example<S> var1, Sort var2);
}
```

新版本获取findOne()方法可用类似方法解决

```csharp
  @Test
   public void findOneTest(){
        Product product = new Product();
        product.setCategoryId(1);
        Example<Product> example = Example.of(product);
        Optional<Product> productOptional = respository.findOne(example);

        if (productOptional.isPresent()) {
            Product productResult =   productOptional.get();
            System.out.println(productResult.toString());
        } else {
            // handle not found, return null or throw
            System.out.println("no exit!");
        }

    }
```

