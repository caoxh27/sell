# **JavaEasyCoding**



## 第1章 计算机基础

大道至简，盘古生其中。计算机的基础世界一切都是由0 与1 组成的。



**追根究底**是深度分析和解决问题、提升程序员素质的关键所在，有助于编写高质
量的代码。基础知识的深度认知决定着知识上层建筑的延展性。试问， 对于如下的基
础知识，你的认知是否足够清晰呢？
· 位移运算可以快速地实现乘除运算， 那位移时要注意什么？
· 浮点数的存储与计算为什么总会产生微小的误差？
· 乱码产生的根源是什么？
· 代码执行时， CPU 是如何与内存配合完成程序使命的？
·网络连接资源耗尽的问题本质是什么？
· 黑客攻击的通常套路是什么？如何有效地防止？
本章从编程的角度深度探讨计算机组成原理、计算机网络、信息安全等相关内容，
与具体编程语言无关。本章将不会讨论内部硬件的工作原理、网络世界的协议和底层
传输方式、安全领域的攻防类型等内容。
1.1 走进O 与1 的世界
简单地说， 计算机就是晶体管、电路板组装起来的电子设备， 无论是图形图像的
渲染、网络远程共享， 还是大数据计算， 归根结底都是O 与l 的信号处理。信息存储
和逻辑计算的元数据， 只能是0 与l ， 但是它们在不同介质里的物理表现方式却是不
一样的， 如三极管的断电与通电、CPU 的低电平与高电平、碰盘的电荷左右方向。
明确了O 与l 的物理表现方式后’设定基数为2 ， 进位规则是“ 逢二进
则是H 借一当二”， 所以称为二进制。那么如何表示曰常生活中的十进制数值昵？二
进制数位从右往左’ 每一位都是乘以2 ， 如下示例为二进制数与十进制数的对应关系，
阴影部分的数字为二进制数
1=1 ' 10=2 ' 100=4 ' 1000=8 ' 11000=24 ，即2°= 1 ; i =2; i2=4; 23=8; 24+ 23=24
设想有8 条电路， 每条电路有低电平和高电平两种状态。根据数学排列组合， 有
8 个2 相乘， 即28 ’ 能够表示256 种不同的信号。假设表示区间为0 ～ 255 ， 最大数
即为28 -1 ， 那么32 条电路能够表示的最大数为（ 232一1 ) =4,294 ,967,295 。平时所说
的32 位机器， 就能够同时处理字长为32 位的电路信号。
如何表示负数呢？上面的8 条电路， 最左侧的条表示正负， 0 表示正数， l 表
示负数，不参与数值表示。8 条电路的最大值为0111111 l 即127 ， 表示范围因有正负
12
第1 童计算机基础
之分而改变为－ 128 ～ 127 ，二进制整数最终都是以补码形式出现的。正数的补码与
原码、反码是样的， 而负数的补码是反码加l 的结果。这样使减法运算可以使用加
法器实现， 符号位也参与运算。比如35 + (-35 ） 如图1-1 ( a ） 所示， 35 - 37 如图1 - 1 ( b )
所示。
00100011 35

+ 11011 101 -35
rD 句t
qJηJ
ll
-
l1
-
<Unu
-
nuv
‘l
-
nu
--
-
··
A
A
HV
-
nu
--
-
nu
--
-
＋ 一
00000000 l l lll l 10
1101 1101 -35
+ 10000000 - 128
101011 101
负主~： Mir. IN：友示负，｛j 7 f但他取反＋ l
- (0000001 +1) = - 2
(a) ( b )
图1-1 负数运算
( c)
加；咸法是高频运算3 使用同一个运算器， 可以减少中间变量存储的开销， 这样也
降低了CPU 内部的设计复杂度， 使内部结构更加精筒， 计算更加高效， 无论对于指令、
寄存器， 还是运算器都会减轻很大的负担。
如图1- 1 ( c ） 所示3 计算结果需要9 条电路来表示， 用8 条电路来表达这个计算
结果即溢出， 即在数值运算过程中， 超出规定的表示范围。旦溢出， 计算结果就是
错误的。在各种编程语言中， 均规定了不同数字类型的表示范围， 有相应的最大值和
最小值。
以上示例中的一条电路线在计算机中被称为l 位， 即l 个bit ， 简写为b。8 个
bi t 组成一个单位，称为一个字节， 即l 个Byte ， 简写为B 。1024 个Byte ， 简写为
阻， 1024 个阻， 简写为MB ; 1 024 个MB ， 简写为GB ， 这些都是计算机中常用的
存储计量单位。
除二进制的加减法外， 还有一种大家既陌生又熟悉的操作． 位移运算。陌生是指
不易理解且不常用， 熟悉是指“ 别人家的开发工程师” 在代码中经常使用这种方式进
行高低位的截取、晗希计算，甚至运用在乘除法运算中。向右移动l 位近似表示除以
2 （ 如表1-1 所示）， 十进制的奇数转化为二进制数后，在向右移时， 最右边的1 将
被直接抹去， 说明向右移对于奇数并非完全相当于除以2。在左移＜＜与右移＞＞两种
运算中， 符号位均参与移动， 除负数往右移动， 高位补l 之外，其他情况均在空位处
3
码出高效· Java 开发手册
补0 ， 红色是原有数据的符号位， 绿色仅是标记， 便于识别移动方向。
表1 - 1 带符号位移运算
正数／负数向左移《1 位向右移》1 位
正数（ 35 的补码。0 1 00011 ) 0100011 0 = 26+22+21 = 70 000 1000 I = 24+2°= ! 7 （ 近似除2 )
负数（ -35 的补码l 10 11101 ) 101 1 I 0 I 0 = l (I 000I0I+1) = 70 1 1 101 门。＝ 1(0010001 + 1) ＝ 一1 8
正数（ 99 的补码。l 100011 ) 1100011 0= - 58 00 门α〕O I =49
负数（－99 的补码1 00 1 1 1 0 1 ) 00 11101 0 = 58 1100 I I I 0 = 50
左移运算由于符号位参与向左移动， 在移动后的结果中， 最左位可能是1 或者0,
即正数向左移动的结果可能是正， 也可能是负，负数向左移动的结果同样可能是正，
也可能是负。
对于三个大于号的＞＞〉无符号向右移动（ 注意不存在＜＜＜无符号向左移动的运
算方式） ， 当向右移动时， 正负数高位均补0 ，正数不断向右移动的最小值是0 ， 而
负数不断向右移动的最小值是l 。无符号意即藐视符号位，符号位失去特权， 必须像
其他平常的数字位一起向右移动， 高位直接补0 ， 根本不关心是正数还是负数。此运
算常用在高位转低位的场景中， 如表1 -2 所示分别表示向右移动l ～ 3 位的结果， 左
侧空位均补0 。
表1-2 无符号位移运算
正数／负数向右移》＞ 1 位向右移》＞2 位向右移》＞3 位
正数（ 35 的补码00 1 00011 ) 000 10001 =17 00001000 = 8 00000100 = 4
负数（ -35 的补码l 10 11101 ) 0!!01 110 =110 00110 ! I l = 55 000 1101 1 = 27
为何负数不断地无符号向右移动的最小值是l 呢？在实际编程中， 位移运算仅作
用于整型（ 32 位）和长整型（ 64 位）数上， 假如在整型数上移动的位数是32 位， 无
论是否带符号位以及移动方向， 均为本身。因为移动的位数是个mod 32 的结果，
即35 >> 1 与3 5»33 是一样的结果。如果是长整型， mod 64 ， 即35 << 1 与35 <<65 的
结果是一样的。负数在无符号往右移动63 位时，除最右边为l 外， 左边均为0 ， 达
到最小值l ， 如果＞＞＞64 ， 贝lj 为其原数值本身。
位运算的其他操作比较好理解， 包括按位取反（ 符号为～）、按位与（符号为＆） 、
14
仅供•I ＇附业月1途或交流学习使用
第才章计算机基础
接位或（符号为｜）、接位异或（符号为什等运算。其中， 按位与（ ＆）运算典型的
场景是获取网段值， IP 地址与掩码255.255.255.0 进行按位与运算得到高24 位， 即为
当前IP 的网段。按位运算的左右两边都是整型数， true&false 这样的方式也是合法的，
因为boolean 底层表示也是0 与l 。
接位与和逻辑与（符号为＆＆）运算都可以作用于条件表达式，但是后者有短路
功能，表达如下所示
boolean a = true ;
bo。lean b = true ;
boolean c= (a=( l==2 )) && (b = ( l==2 ));
因为＆＆前边的条件表达式， 即如上的红色代码部分的结果为false ，触发短路，
直接退出， 最后a 的值为false, b 的值为true 。假如把＆＆ 修改为按位与＆，贝lj 执行
的结果为a 与b 都是false 。
同样的逻辑，按位或对应的逻辑或运算（符号为｜｜）也具有短路功能， 当逻辑或
｜｜ 之前的条件表达式，即如下的红色代码部分的结果为仕ue 时，直接退出
boolean e = false ;
boolean f = false ;
boolean g = (e= (l==l )) 11 (f= (l==l));
最后e 的值为true, f 的值为fa lse 。假如把｜｜修改为按位或符号｜ ，执行的结果为
e 与f 都是往ue 。
逻辑或、逻辑与运算只能对布尔类型的条件表达式进行运算， 7&&8 这种运算表
达式是错误的。
异或运算没有短路功能，符号在键盘的数字6 上方，在哈希算法申用于离散
晗希值， 对应的位上不一样才是l ， 一样的都是0。比如， I /\ 1 = O I Q /\ O=O 门／＼ Q= I I
t1 ue/\ true=false I true/\ false =true 。
基于0 与l 的信号处理为我们带来了缤纷多彩的计算机世界，随着基础材料和信
号处理技术的发展，未来计算机能够处理的基础信号将不仅仅是二进制信息。比如，
三进制（ 高电平、低电平、断电），甚至十进制信息，届时计算机世界又会迎来一次
全新的变革。
5 1
仅供＇°＇附业用途或交流学习使用
码出高效： Java 开发手册
1.2 浮点数
计算机定义了两种小数，分别为定点数和浮点数。其中，定点数的小数点位置是
固定的，在确定字长的系统中－ ＿§＿指定小数点的位置后，它的整数部分和小数部分也
随之确定。二者之间独立表示，五不干扰。由于小数点位置是固定的，所以定点数能
够表示的范围非常有限。考虑到定点数相对简单，本节不再展开。下面重点介绍应用
更广、更加复杂的浮点数。它是采用科学计数法来表示的，由符号位、有效数字、指
数三部分组成。使用浮点数存储和计算的场景无处不在，若使用不当则容易造成计算
值与理论值不一致，如下示例代码
float a = lf;
float b = 0 . 9f ;
. 1 "I' I 二1
float f = a - b;
执行结果显示计算结果与预期存在明显的误差，本节将通过深入剖析造成这个误
差的原因来介绍浮点数的构成与计算原理。由于浮点数是以科学计数法来表示的，所
以我们先从科学计数法讲起。
1.2.1 科学计数法
浮点数是计算机用来表示小数的一种数据类型。在数学中，采用科学计数法来近
似表示一个极大或极小且位数较多的数。如a × l 旷，其中a 满足l 运问I < i o, iσ
是以10 为底数， n 为指数的事运算表达式。a × lσ 还可以表示成棚，如图1-2 (a ）中计算
器的结果所示。一4.86e 门等价于－4.86 × 1011 ，它们都表示真实值－ 48600 0 000000,
具体格式说明如图1- 2 ( b ）所示。
-4.86e11 符号有效数字指数
7 8
5
9
l 三三阳I < 10
c
’‘
4 6 \-@.86) × 10U
(a)
)
，。
(
图1- 2 科学计数法
科学计数法的有效数字为从第l 个非零数字开始的全部数字，指数决定小数点的
位置，符号表示该数的正与负。值得注意的是，十进制科学计数法要求有效数字的整
6
仅供非商业用途或交流学习佼用
第才章计算机基础
数部分必须在［ 1 , 9］区间内，即图1-2 ( b ） 中的
为“规格化’’ 。科学计数？去可以唯一地表示任何一个数’且所占用的存储空间会更少，
计算机就是利用这特性表示极大或极小的数值。例如，长整型能表示的最大值约为
922 亿亿，想要表示更大量级的数值，必须使用浮点数才可以做到。
1.2.2 j孚点数表示
浮点数表示就是如何用二进制数表示符号、指数和有效数字。当前业界流行的浮
点数标准是IEEE754 ， 该标准规定了4 种浮点数类型单精度、双精度、延伸单精度、
延伸双精度。前两种类型是最常用的，它们的取值范围如表1 -3 所示。
表1 3 单精度和双精度
精度字节数正数取值范围负数取值范围
单精度类型4 1.4←45 至3.4e +38 -3.4e+38 至一I .4e- 45
双精度类型8 4.9e 324 至1.798e+308 - l.798e+ 308 至－4.9e -324
因为浮点数无法表示零值，所以取值范围分为两个区间正数区间和负数区间。
下面将着重分析单精度浮点数，而双精度浮点数与其相比只是位数不同而已，完全可
以触类旁通1 本节不再展开。以单精度类型为例，它被分配了4 个字节，总共32 位，
具体格式如图1-3 所示。
仲； (l 忖） 一＋
.H 30 29 28 27 26 25 24 23 22 21 10 19 IS 17 16 15 14 13 12 II Ill 9 8 7 6 5 4 3 2 I 0
’ |
指数＜ 8f"O .
图1 -3
有生食数·；·： ( 2川但）
单精度浮点数格式
从数学世界的科学计数法映射到计算机世界的浮点数时，数制从十进制改为二进
制，还要考虑内存硬件设备的实现方式。在规格化表示上存在差异，称i冒有所改变’
f旨数称为“ 阶码
制位分另lj称为符号位、阶码位、尾数位，下面详细阐述三个部分的编码格式。
I. 符号位
在最高二进制位上分配l 位表示浮点数的符号， 0 表示正数， 1 表示负数。
2. H介石马位
在符号位右侧分配8 位用来存储指数， IEEE754 标准规定阶码位存储的是指数对
71
仅供非商业用途或交流学习使用
码出高效： J ava 开发手册
应的移码，而不是指数的原码或补码。根据计算机组成原理中对移码的定义可知，移
码是将一个真值在数轴上正向平移个偏移量之后得到的，即［x ］ 移＝ x+2n- J (n 为x
的二进制位数，含符号位）。移码的几何意义是把真值映射到个正数域，其特点是
可以直观地反映两个真值的大小，即移码大的真值也大。基于这个特点，对计算机来
说用移码比较两个真值的大小非常简单，只要高位对齐后逐个比较即可，不用考虑负
号的问题，这也是阶码会采用移码表示的原因所在。
由于阶码实际存储的是指数的移码，所以指数与阶码之间的换算关系就是指数与
它的移码之间的换算关系。假设指数的真值为e ，阶码为E ，贝lj 有E=e+(2n-I 1 ），其
中2n -I 一l 是IEEE754 标准规定的偏移量， n=8 是阶码的二进制位数。
为什么偏移值为2川一l 而不是2n-1 呢？因为8 个二进制位能表示指数的取值范
围为［－ 128,127］，现在将指数变成移码表示，即将区间［－ 128,127］正向平移到正数域，
区间里的每个数都需要加上128 ，从而得到阶码范围为［0,255］。由于计算机规定阶码
全为0 或全为l 两种情况被当作特殊值处理（全0 被认为是机器零，全1 被认为是无
穷大），去除这两个特殊值，阶码的取值范围变成了［ l,254］。如果偏移量不变仍为
128 的话，贝lj 根据换算关系公式［x ］ 阶＝ x + 128 得到指数的范围变成［－ 127,126］，指
数最大只能取到126 ，显然会缩小浮点数能表示的取值范围。所以IEEE754 标准规定
单精度的阶码偏移量为2n-1 一l （即127 ），这样能表示的指数范围为［ 126,127],
指数最大值能取到127 。
3. 尾数位
最右侧分配连续的23 位用来存储有效数字， IEEE754 标准规定尾数以原码表
示。正指数和有效数字的最大值决定了32 位存储空间能够表示浮点数的十进制最
大值。指数最大值为i27 ;::: 1.7 × 1038 ’而有效数字部分最大值是二进制的1.11···1
（小数点后23 个1 ），是个无限接近于2 的数字，所以得到最大的十进制数为
2 × 1.7 × 1038 ’再加上最左l 位的符号，最终得到32 位浮点数最大值为3.4e+38 。
为了方便阅读，从右向左每4 位用短横线断开
nu- l l nu- 11 11 1 11 i l - - l i l l i
· 红色部分为符号位， 值为0 ， 表示正数。
· 绿色部分为阶码位即指数，值为2254-1 27 = i 27;::: 1.7 × 1038。
· 黄色部分为尾数位即有效数字，值为l. 111 l l 11 l l I I I 1111111111 i 。
科学计数法进行规格化的目的是保证浮点数表示的唯性。如同十进制规格化的
要求1 ＂三lal < 10 ， 二进制数值规格化后的尾数形式为l.xyz ，满足1 ＂三lal < 2。为了e
仅供非商业用途或交流学习使用
第 1 章 计算机墓础
仅供二ll'ilii业用途或交流学习使用
节约存储空间，将符合规格化尾数的首个l 省略，所以尾数表面上是23 位，却表示
了24 位二进制数，如图1-4 所示。
22 21 20 19 18 17 16 15 14 13 12 ll 10 9 8 7 6 5 4 J 2 l 0
仰自l 一一， l l I I I I I I I I I I I I I I I I I I I I I I I I
•= 叫宁（川
行｜｜｜各小数点
图 1-4 尾数的规格化表示
常用浮点数的规格化表示如表1 -4 所示。
i孚点数的规格化表示
数值i孚点数二进制表示i兑明
一16 1100- 0001 - 1000-0000-0000-0000-0000-0000
第l 位为负数， 1 31 -127=4 ，即2 的4
次方等于16 ，尾数部分为1.0
16.35 0100 0001 一1 000-0010-1100-1100 1100-1101
符号为正，绿色部分上同，尾数部分见
说明①
0.35 00 I l 一l 110- 1 O!l-0011-0011-0011-0011-0011
此例的目的是说明16.35 和0万的尾数部
分是不样的
1.0 α） 11- 11 I l 一1 000-0000-0000-0000-0000-0000
12 7 -127=0 即2 的0 次＝ l ，尾数部分为
1.0
0.9 00 II 一l 111 - 01 10-0 门0-0110-0 门。一0110-0110 12币－ 127=-1 en o.s ②
表1-4
①尾数部分的有效数字为l.00000101100110011001101 ＇将其转换成十进制值为
1.021875 ， 然后乘以24 得到16 . 35000038。由此可见，计算机实际存储的值可能与
真值是不一样的。
〉王
② 0.9 不能用有限二进制位进行精确表示，所以1-0 .9 并不精确地等于0.1 ， 实际结果
是0 . 100000024 ， 具休原因后面进行分析。
加；咸运算
在数学中，进行两个小数的加减运算时，首先要将小数点对齐，然后同位数进行
加减运算。对两个采用科学计数法表示的数做加减法运算时，为了让小数点对齐就需
要确保指数一样。当小数点对齐后，再将有效数字按照正常的数进行加减运算。
1.2.3
( I ） 零值检测。检查参加运算的两个数中是否存在为0 的数（。在浮点数是一
种规定，即阶码与尾数全为0 ），因为浮点数运算过程比较复杂，如果其中一个数为0,
可以直接得出结果。
91
仅供才l'iiii业用途或交流学习使用
e
仅供二ll'ilii业用途或交流学习使用
码出高效· Java 开发手册
( 2 ) ~－1 [\';' J异件通过比较阶码的大小判断小数点位置是否对齐。当阶码不相等
时表示当前两个浮点数的小数点位置没有对齐， 贝lj 需要通过移动尾数改变阶码的大小，
使二者最终相等， 这个过程便称为对阶。尾数向右移动l 位，贝iJ 阶码值加l ，反之减l 。
在移动尾数时， 部分二进制位将会被移出，但向左移会使高位被移出，对结果造成的
误差更大。所以， IEEE 754 规定对阶的移动方向为向右移动， 即选择阶码小的数进行
操作。
( 3) h＇ 豹三Fγ：n ＂ 当对阶完成后，直接接位相加即可完成求和（如果是负数贝lj 需
要先转换成补码再进行运算）。这个道理与十进制数加法相同，例如9 .8 × 1038 与
6 .5 × 1037 进行求和， 将指数小的进行升阶，即6 .5 × 1037 变成0.65 × I OJs ’ 然后求
和得到结果为10.45 × 1038 。
( 4 ）均票规格仲如果运算的结果仍然满足规格化形式，贝lj 无须处理， 否则需
要通过尾数位的向左或右移动调整达到规格化形式。尾数位向右移动称为右规， 反之
称为左规。如上面计算结果为10.45 × I 03s ’ 右规操作后为1.045 × l 。”。
( 5 ) i L 合人在对阶过程或右规时，尾数需要右移，最右端被移出的位会
被丢弃， 从而导致结果精度的损失。为了减少这种精度的损失， 先将移出的这部分数
据保存起来，称为保护位，等到规格化后再根据保护位进行舍入处理。
了解了浮点数的加；咸运算过程后可以发现， 阶码在加减运算过程中只是用来比较
大小， 从而决定是否需要进行对阶操作。所以， IEEE 754 标准针对这一特性， 将阶码
采用移码表示， 目的就是利用移码的特点来简化两个数的比较操作。下面针对前面例
子从对阶、按位减法的角度分析为什么1.0 - 0.9 结果为0.100000024 ， 而不是理论值0 . 1 。
1.0一0.9 等价于1.0 + ( -0 . 9） ，首先分析l O 与一0.9 的二进制编码
1 0 的二进制为0011-111 卜1000-000。”0000-0000-0000- 0000 。
-0.9 的二进制为1011 」111-0110-01 1 0-0110-0110-0110-0110。
从上可以得出二者的符号、阶码、尾数三部分数据， 如表1-5 所示。
表l 一5 符号、阶码与尾数
浮点数符号阶码尾数（红色表示规格化后最高位） 尾数补码
1.0 。127 I000-0000-0000- 0000- 0000- 0000 1000 0000 0000-0000- 0000- 00()()
一0.9 126 I I LO 011 0 0 110 0110 01 10- 0110 000 1-LOOJ - I 001 一1 001 - 1001 - 1010
®110
仅供才i' iili业用途或交流学习使用
仅供非商业用途或交流学习佼用
第1 章计算机基础
由于尾数位的最左端存在个隐藏位，所以实际尾数二进制分别为： 1000-0000-
0000-0000-0000- 0000 和l 110-0110-0110-0110-0110-0110 ， 红色为隐藏位。下面运算都
是基于实际的尾数位进行的，具体过程如下
( I ) ，－、↑！〈1.0 的阶码为127, -0.9 的阶码为126 ，比较阶码大小后需要向右移
动－ 0.9 尾数的补码，使其阶码变为127 ， 同时高位需要补l ，移动后的结果为1000-
1100-1100-1100-1100-1101 ， 最左的l 是高位补进的。注意， 绿色只是为了方便与表格
右下方的数字进行对比。
( 2 ）尾4、文汉和。因为尾数都转换成补码，所以可以直接接位相力日，注意符号位
也要参与运算，如图1-5 所示。
符号位尾数位
。I I 000-0000-0000-0000-0000-0000
1000-1100-1100-1100-1100-1101
。I 0000-1100-1100- 1100-1100-110 I
图1-5 尾数求和示意
其中最左端为符号位，计算结果为0 ， 尾数位计算结果为0000- 1100-1 100－ 门00-
1100-110 l 。
( 3 ) ;J;y,i 抖化4 上一步计算的结果并不符合要求，尾数的最高位必须是l ， 所
以需要将结果向左移动4 位，同时阶码需要减4。移动后阶码等于123 （二进制为
1111011 ）， 尾数为1100-1100-1100- 11 00－ 川01-0000。再隐藏尾数的最高位，进而变为
I 00- I I 00 I I 00- I I 00- l I 0 1 -0000 。
综上所述，得出运算后结果的符号为0 、阶码为l 11101 l 、尾数为100-1100-1100-
1100-1101- 0000 ，三部分组合起来就是1 .0 -0.9 的结果，对应的十进制值为0 .100000024 。
至此，在本节开始处的减法悬案真相大白。
1.2.4 浮点数使用
在使用浮点数时推荐使用双精度，使用单精度由于表示区间的限制，计算结果会
出现微小的误差，实例代码如下所示
float ff= :J . 9f ;
double dd = O. 9d ; e 才才|
仅供非商业用途或交流学习使用
仅供二ll'ilii业用途或交流学习使用
码出高效： Java 开发手册
System.out . printl 口（ ff/ 1.0 ) ;
System.out .println(dd/ 1 . 0);
在要求绝对精确表示的业务场景下，比如金融行业的货币表示，推荐使用整型存
储其最小单位的值，展示时可以转换成该货币的常用单位，比如人民币使用分存储，
美元使用美分存储。在要求精确表示小数点n 位的业务场景下，比如圆周率要求存储
小数点后1000 位数字，使用单精度和双精度浮点数类型保存是难以做到的，这时推
荐采用数组保存小数部分的数据。在比较浮点数时，由于存在误差，往往会出现意料
之外的结果，所以禁止通过判断两个浮点数是否相等来控制某些业务流程。在数据库
中保存小数时，推荐使用decimal 类型，禁止使用float 类型和double 类型。因为这
两种类型在存储的时候，存在精度损失的问题。
综上所述，在要求绝对精度表示的业务场景中，在小数保存、计算、转型过程中
都需要谨慎对待。
1.3 字符集与乱码
理解0 和l 的物理信号来源及数值表示方式后，如何将0 和l 表示成我们看到的
文字呢？从26 个英文字母说起，大小写共52 个，加上10 个数字达到62 个，考虑到
还有特殊字符（如－ ！ ＠＃$%〈＆ ＊｛｝ ｜等）和不可见的控制字符，必然超过64 个，
这又该如何表示呢？注意这里特别提到了飞4 ”， 因为它的特殊性，即2 的6 次方。
使用刚才的0 与l 组合，至少是7 组连续的信号量。计算机在诞生之初对于存储和传
输介质实在没有什么信心，所以预留了一个bit（ 位）用于奇偶校验，这就是1 个Byte （ 字
节）由8 个bit 组成的来历，也就是A SCII 码。
在A SCII 码中，有两个特殊的控制字符10 和13 ， 前者是LF 即“ \n ”， 后者是
CR 即V”， 在编码过程中，代码的换行虽然是默认不可见的，但在不同的操｛乍系统中’
表示方式是不样的。在UNIX 系统中， 换行使用换行符“＼n
换行使用＂ \r\n
与UNIX 系统丰目同的换行方式。如图1 - 6 所示’当前编码环境使用换行方式是LF ,
这也是推荐的换行方式，避免出现源码在不同操作系统中换行显示不同的情况。
®112
仅供才｜商业用途或交流学习使用
仅供非商业用途或交流学习佼用
第1 章计算机墓础
I ,; s ·p ,.
CRLF - Windows 叭叭n) .
CR - Classic Mac (\r) i
LF: LF - Unix and OS X (\n) I
图I 6 不同操作系统的换行方式
再说汉字的字符集表示，首先汉字的个数远远超过英文字符的个数。毕竟ASCII
码先入为主，必须在它基础上继续编码，也必须想办法和它兼容。个字节只能表示
128 个字符，所以采用双字节进行编码。早期使用的标准GB2312 收录了6763 个常用
汉字。而GBK (K 是拼音kuo 的首字母，是扩展的意思）支持繁体，兼容GB2312 。
而后来的GB18030 是国家标准，在技术上是GBK 的超集并与之兼容。1994 年正式
公布的Unicode ，为每种语言中的每个字符都设定了唯一编码，以满足跨语言的交流，
分为编码方式和实现方式。实现Unicode 的编码格式有三种， UTF-8 、UTF-16 、UTF-
32, UTF ( Unicode Transformation Format ）即Unicode 字符集转换格式，可以理解为
对Unicode 的压缩方式。根据二八原则，常用文字只占文字总数的20% 左右。其中，
UTF-8 是一种以字节为单位，针对Unicode 的可变长度字符编码，用I ～ 6 个字节对
Unicode 字符进行编码压缩，目的是用较少的字节表示最常用的字符。此规则能有效
地降低数据存储和传输成本。
在日常开发中，字符集如果不兼容则会造成乱码。淘宝以前的系统都是GBK 编码，
而国际站使用的是UTF-8 ，在互相查看源码时，使用UTF- 8 的IDE 环境打开GBK 源
码，中文注释基本上都是不可读的乱码。乱码的出现场景并不止于编码环境中，还有
网页展示、文本转换、文件读取等。数据流从底层数据库到应用层，歪IJWeb 服务器，
再到客户端显示，每位开发工程师都会碰到字符乱码的问题，排查起来是一个比较长
的链路。数据库是存储字符之源，在不同层次上都能够设置独立的字符集，如服务器
级别、schema 级另lj 、表级别甚至列级别。为了减少麻烦，所有情况下的字符集设置
最好是一致的。
1.4 CPU 与内存
CPU ( Central Processing Unit ）是一块超大规模的集成电路板，是计算机的核心
部件，承载着计算机的主要运算和控制功能，是计算机指令的最终解释模块和执行模
块。硬件包括基板、核心、针脚，基板用来固定核心和针脚，针脚通过基板上的基座e 13 I
仅供非商业用途或交流学习使用
码出高效· Java 开发手册
连接电路信号， CPU 核心的工艺极度精密，达到10 纳米级别。
和其他硬件设备相比，在实际代码的运行环境中， CPU 与内存是密切相关的两
个硬件设备，本节对CPU 和内存简单介绍下。开发工程师在实际编程中，对这两
个部件有定的掌控性，熟悉CPU 和内存的脾气，让它们以自己期望的方式执行相
关指令。在CPU 的世界里，没有缤纷多彩的图像、悦耳动昕的音乐，只有日复一日
地对O 与l 电流信号的处理。但CPU 内部的处理机制是十分精密而复杂的，总的来说，
就是由控制器和运算器组成的，内部寄存器使这两者协同更加高效。CPU 的内部结
构如图1 - 7 所示。
［控制器酣睡酷）
图1-7 CPU 的内部结构
1. 控制器
控制器由图1-7 中所示的控制单元、指令译码器、指令寄存器组成。其中控制单
元是CPU 的大脑，由时序控制和指令控制等组成；指令译码器是在控制单元的协调
下完成指令读取、分析并交由运算器执行等操作t 指令寄存器是存储指令集，当前流
行的指令集包括X86 、SSE, MMX 等。控制器有点像个编程语言的编译器，输入
。与l 的源码流，通过译码和控制单元对存储设备的数据进行读取，运算完成后，保
存回寄存器，甚至是内存。
2. 运算器
运算器的核心是算术逻辑运算单元，即ALU ，能够执行算术运算或逻辑运算等
各种命令，运算单元会从寄存器中提取或存储数据。相对控制单元来说，运算器是受
® I 才4
仅供非商业用途或交流学习使用
φ
第1 章计算机基础
控的执行部件。任何编程语言诸如a+b 的算术运算，无论字节码指令，还是汇编指令，
最后一定会以0 与l 的组合流方式在部件内完成最终计算，并保存到寄存器，最后送
出CPU 。平时理解的枝与堆，在CPU 眼里都是内存。
最著名的寄存器是CPU 的高速缓存LI 、L2 ，缓存容量是在组装计算机时必问的
两个CPU 性能问题之。缓存结构和大小对CPU 的运行速度影响非常大，毕竟CPU
的运行速度远大于内存的读写速度，更远大于硬盘。基于执行指令和热点数据的时间
局部性和空间局部性， CPU 缓存部分指令和数据，以提升性能。但由于CPU 内部空
间狭小且结构复杂，高速缓存远小于内存空间。
CPU 是一个高内聚的模块化组件，它对外部其他硬件设备的时序协调、指令控制、
存取动作，都需要通过操作系统进行统管理和协调。所谓的CPU 时间片切分，并
非CPU 内部能够控制与管理。CPU 部件是一个任劳任怨的好公民代表，只要有指令
就会马不停蹄地执行，高级语言提供的多线程技术和并发更多地依赖于操作系统的调
配，并行更多依赖于CPU 多核技术。多核CPU 即在同块基板上封装了多个Core。
还有一种提升CPU 性能的方式是超线程，即在一个Core 上执行多个线程，如图1-8
所示为2 个Core ，但是有4 个逻辑CPU ，并有对应独立的性能监控数据。
Processor Speed: 3.1 GHz
Number of Process。rs: 1
T。ta l Number of c。res 2
L2 cact回（ per Core): 256 KB
L3 cache: 4 MB
M凹Y，。叩· 16GB
B。。t ROM Version: MBP121 .0167.821
SMC Vers ion (system): 2.2817
Serial Number (system): C02RC074FVH9
Hard旧re UUIO : “ 541809-4A05-50EE-8495-00B645CA9888
Hlrdw.we
图1-8 多核CPU
CPUt<>• my
CPU 与内存的执行速度存在巨大的鸿沟，如图1 - 8 所示的L2 和L3 分别是
256KB 和4MB ，它们是CPU 和内存之间的缓冲区，但并非所有的处理器都有L3 缓存。
曾几何时，内存就是系统资源的代名词，它是其他硬件设备与CPU 沟通的桥梁，
计算机中的所有程序都在内存中运行，它的容量与性能如果存在瓶颈，即使CPU 再快，
也是枉然。内存物理结构由内存芯片、电路板、控制芯片、相关支持模块等组成，内
15
仅供非商业用途或交流学习使用
码出高效： J ava 开发手册
存芯片结构比较简单，核心是存储单元，支持模块是地址译码器和读写控制器， 如图
1- 9 所示。
卡车更大
更慢
更便宣
跑车11 更小
更快
更贵
a…II:::田1~1>::r，＿…
_ .... 圃由~1u＝－凰
a…&Ellllla
a…噩噩噩3…
.. 噩噩圈··
E噩噩国
圄噩噩
计算机内存条
图1- 9 计算机存储方式
存储芯片
Rll'lffil1 当＇＂＇＇四mr.拯m11•
R"3ilil1 军报’，Y.<m罚担.!i[ll'...
a arr是当E罩’民日百四r.111c•
R"3iM；量mi:tl'!lm罚IC!ill哩’
•:<J~是当币四~ir:lill而II峙’
从图1-9 中可以看出， 越往CPU 核心靠近， 存储越贵， 速度越快。越往下， 存
储越便宣、速度越慢， 当然容量也会更大。云端存储使得应用程序无须关心是分布式
还是集中式， 数据如何备份和窑灾。在本地喝盘与CPU 内部的缓存之间， 内存是一
个非常关键的角色， 但它很敏感， 内存颗粒如果有问题无法存储， 或控制模块出现地
址解析问题， 或内存空间被占满，都会导致无法正常地执行其他应用程序，甚至是操
作系统程序。程序员们最害怕的OO M 通常来源于由于不恰当的编码方式而导致内存
的资源耗尽，虽然现代内存的窑量已经今非昔比， 但仍然是可以在秒级内耗尽所有内
存资源的。
图lθ 中的存储单元都有一个十六进制的编号， 在32 位机器上是Ox 开始的8 位
数字编号， 就是内存存储单元的地址， 相当于门牌号。以C 和C ＋＋为代表的编程语
言可以直接操作内存地址， 进行分配和释放。举个例子，要写一份数据到存储单元中，
就像快递一个包裹， 需要到付并且当面签收，到了对应的住址， 发现收件人不在， 就
抛出异常。如图1 - 10 所示的经典错误， 估计很多人都遇到过，选择要调试程序，单击［ 取
消］ 按钮，并无反应，也不会出现调试界面。内存的抽象就是线性空间内的字节数组，
通过下标访问某个特定位置的数据， 比如C 语言使用malloc （） 进行内存的分配， 然后
使用指针进行内存的读与写。
Q:Y 才6
仅供~I＇商业用途或交流学习佼用
第才章计算机基础
。”O.Cll310030＂肘引用的’叩呵’ 情·仰不胁’，.... .
路蜡：： iH言：黯：：
~一卫生」
图1-10 内存出错警告
而以Java 为代表的编程语言，内存就交给NM 进行自动分配与释放，这个过程
称为垃圾回收机制。这就好像刚才的快递员并不直接访问内存单元，只是把包裹放在
叫只币f 的老大爷家里。付出的代价是到货速度慢了，影响客户体验。毕竟老大爷并
不是实时立马转交的，而是要攒到一定的包裹量再接家接户地给收件人送过去。虽然
垃圾回收机制能为程序员减负，但如果不加节制的话，同样会耗尽内存资源。
1.5 TCP/IP
1.5.1 网络协议
在计算机诞生后，从单机模式应用发展到将多台计算机连接起来，形成计算机网
络，使信息共享、多机协作、大规模计算等成为现实，历经了20 多年的时间。计算
机网络需要解决的第个问题是如何无障碍地发送和接收数据。而这个发送和接收数
据的过程需要相应的协议来支撑，按互相可以理解的方式进行数据的打包与解包，使
不同厂商的设备在不同类型的操作系统上实现顺畅的网络通信。
TCP/IP ( Transmission Control Protocol I Internet Protocol ）中文译为传输控制协
议／因特网互联协议，这个大家族里的其他知名协议还有HTTP, HTT陀、FTP 、
SMTP 、UDP, ARP 、PPP 、IEEE 802.x 等。TCP/IP 是当前流行的网络传输协议框架，
从严格意义上讲它是一个协议族，因为TCP, IP 是其中最为核心的协议，所以就把
该协议族称为TCP/IP。而另一个是耳熟能详的ISO/OSI 的七层传输协议，其中OSI
( Open System Interconnection ）的出发点是想设计出计算机世界通用的网络通信基本
框架，它已经被淘汰，本节目自过。
TCP/IP 是在不断解决实际问题中成长起来的协议族，是经过市场检验的事实标
准，已经很难被取代。就像即使键盘的布局不那么合理，比如字母A 被设计在左手
小指位置，不利于敲击，但原来的键盘布局已经成为群体习惯的事实标准。TCP 分层
框架图如图1-11 所示，为了表示网络拓扑图在连接层面上的机器对等理念，故图1-11
中采用A 机器和B 机器的说法，而不是服务器和客户端的说：去。
17 I
码出高效· Java 开发手册
Q AJ. ~a B 机器
E噩噩圃HTTP I FTP I SMTP 等〉- 。
··画画gm TCP/UDP ··圈圈~ v 仑
圈圈罩困IP I ARP 等.. 韶嚣舅..
。仑
噩噩噩圄IEEE 802.x I PPP等.. 躏霄嚣..
:n,. 仑
物理层
罔l 一l I TCP/IP 协议分层框架
·链路层：单个0 、l 是没有意义的，链路层以字节为单位把0 与l 进行分组，
定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据。图1-12
所示是以太网的帧协议。
链路层报头。！ 帧上数据
「＝· ＝ ~二：圄噩噩圄（
图1 一12 链路层报文结构
MAC 地址长6 个字节共48 位，通常使用十六进制数表示。使用ifconfig-a 命令
即可看到MAC 地址。如图1-13 所示的f4 ：如： 89 ， 即前24 位由管理机构统一分配，
后24 位由厂商自己分配，保证网卡全球唯一。网卡就像家庭地址一样，是计算机世
才8
第才章计算机基础
界范围内的唯一标识。
l 「iet6 :80: : 4 c: la9c: b665: 15d69旨en0 prefixlen 64 secured scopeid 0x4 I jet o5c8~ ／e'
IP地址， inet 1j2'.20.10j·netmask 0xfffffff0 b 「oadcast 172.20.10.15
罔1-1 3 M AC 地址
·网络层： 根据IP 定义网络地址，区分网段。子网内根据地址解析协议（ ARP )
进行MAC 寻址， 子网外进行路由转发数据包，这个数据包即IP 数据包。
·传输层： 数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻
辑端口， 确认身份后，将数据包交给应用程序，实现端口到端口间通信。最
典型的传输层协议是UDP 和TCP 。UDP 只是在IP 数据包上增加端口等部分
信息， 是面向无连接的，是不可靠传输，多用于视频通信、电话会议等（即
使少一帧数据也无妨）。与之相反， TCP 是面向连接的。所谓面向连接， 是
一种端到端间通过失败重传机制建立的可靠数据传输方式，给人感觉是有一
条固定的通路承载着数据的可靠传输。
·应用层： 传输层的数据到达应用程序时，以某种统一规定的协议格式解读数
据。比如， E-mail 在各个公司的程序界面、操作、管理方式都不一样，但是
都能够读取邮件内容， 是因为SMTP 协议就像传统的书信恪式一样，按规定
填写邮编及收信人信息。
总结一下， 程序在发送消息时，应用层接既定的协议打包数据， 随后由传输层加
上双方的端口号，由网络层加上双方的IP 地址，由链路层加上双方的MAC 地址， 并
将数据拆分成数据帧， 经过多个路由器和网关后， 至lj 达目标机器。简而言之， 就是按
“ 端口→ IP 地址→ MAC 地址” 这样的路径进行数据的封装和发送， 解包的时候反过
来操作即可。
1.5.2 IP 协议
IP 是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP
首先规定出IP 地址格式，该地址相当于在逻辑意义上进行了网段的划分，给每台计
算机额外设置了一个唯一的详细地址。既然链路层可以通过唯一的MAC 地址找到机
器， 为什么还需要通过唯的IP 地址再来标识呢？简单地说， 在世界范围内，不可
能通过广播的方式， 从数以千万计的计算机里找到目标MAC 地址的计算机而不超时。
19
码出高效Java 开发手册
在数据投递时就需要对地址进行分层管理。举个例子，一个重要快递从美国发出，要
发给中国浙江省台州市某小区的X 先生。快递公司需要先确定中国的转运中心（如
浙江某转运中心），然后再从转运中心逐级配送到各个下级转运点。当快递到达该小
区后，快递员大喊一声“X 先生领快递啦｜”虽然小区里包括X 先生在内的所有人
都听到了快递员的喊声，但只有X 先生收取快递并当面打开确认，其他人确定不是
叫自己则不用理会。IP 地址如图1- 14 所示，即30.38.48.22 ，右边为物理层发送和接
收数据的统计。
Interface Information
Hardware Address: f4:5c:89:ae:bd:23
IP Address: 30.38.48.22
Link Speed: 11 Mbit/s
Transfer Statistics
Sent Packets: 2,421,565
Send Errors: 0
Recv Packets: 1,479,672
图1 - 14 IP 地址
IP 地址属于网络层，主要功能在WLAN 内进行路由寻址，选择最佳路由。IP 报
文格式如图1-15 所示，共32 位4 个字节，通常用十进制数来表示。四地址的掩码
Ox值班。。表示255.255.255.0 ，掩码相同，则在同一子网内。IP 协议在IP 报头中记录
源IP 地址和目标IP 地址，如图1-15 所示。--E噩噩圈圈总长度（ 16位） ]
卜可1吨） 国国－噩－
I P报头
IDiliil噩噩－盟圃校验和（ 16位） ]
- I P数据
图1 - 15 IP 报文格式
协议结构比较简单，重点说下数据包的生存时间，即TTL ，它是数据包可经
过的最多路由器总数。TTL 初始值由源主机设置后，数据包在传输过程中每经过一
120
第1 章计算机基础
个路由器TTL 值则减l ，当该字段为0 时，数据包被丢弃，并发送ICMP 报文通知
源主机，以防止源主机无休止地发送报文。这里扩展说一下ICMP ( Internet Control
Message Protocol ），它是检测传输网络是否通畅、主机是否可达、路由是否可用等网
络运行状态的协议。ICMP 虽然并不传输用户数据，但是对评估网络健康状态非常重
要，经常使用的ping 、tracert 命令就是基于ICMP 检测网络状态的有力工具。图1-15
中TTL 右侧是挂载协议标识，表示IP 数据包里放置的子数据包协议类型，如6 代表
TCP, 17 代表UDP 等。
IP 报文在互联网上传输时，可能要经历多个物理网络，才能从源主机到达目标
主机。比如在手机上给某个PC 端的朋友发送一个信息，经过无线网的IEEE 802.lx
认证，转到光纤通信上，然后进入内部企业网802.3 ，并最终到达目标PC 。、由于不同
硬件的物理特性不同，对数据帧的最大长度都有不同的限制，这个最大长度被称为最
大传输单元，即MTU ( Maximum Transmission Unit ）。那么在不同的物理网之间就
可能需要对IP 报文进行分片，这个工作通常由路由器负责完成。
IP 是TCP／凹的基石，几平所有其他协议都建立在IP 所提供的服务基础上进行传
输，其中包括在实际应用中用于传输稳定有序数据的TCP 。
1.5.3 TCP 建立连接
传输控制协议（ Transmission Control Protocol, TCP ），是种面向连接、确保
数据在端到端间可靠传输的协议。面向连接是插在发送数据前，需要先建立一条虚拟
的链路，然后让数据在这条链路上“流动”完成传输。为了确保数据的可靠传输，不
仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时
情况时进行重传，还需要通过实现滑动窗口和拥塞控制等机制，避免网络状况恶化而
最终影响数据传输的极端情形。每个TCP 数据包是封装在IP 包中的，每个IP 头的
后面紧接着的是TCP 头， TCP 报文格式如图1-16 所示。
21 I
码出高效： Java 开发手册
TCP 报头
TCP 数据
十i明白叫） ； | 目标机器端口号（ 16位）
|; - 序列号（础即seq,;? ) ·1
［~ ＇~ •· i由时（叫即町
1 ~~： r ［ 结｜ 州FIN I
） ｜ 叫R斗叫I $J'fifl;l)!i!O;k'J' ( 16fil I l
| 平均（~ ~户丁
| 选项（发平机机文段叫咱叫树口） l
数据（最大…由问叫
图1-16 TCP 报文格式
协议第一行的两个端口号各占两个字节，分别表示了源机器和目标机器的端口号。
这两个端口号与IP 报头中的源E 地址和目标IP 地址所组成的囚元组可唯→标识一条
TCP 连接。由于TCP 是面向连接的，因此有服务端和客户端之分。需要服务端先在
相应的端口上进行监昕，准备好接收客户端发起的建立连接请求。当客户端发起第
个请求建立连接的TCP 包时，目标机器端口就是服务端所监昕的端口号。比如一些
由国际组织定义的广为人知端口号一一代表HTTP 服务的80 端口、代表SSH 服务的
22 端口、代表HTTPS 服务的443 端口。可通过netstat 命令列出机器上已建立的连接
信息，其中包含唯标识条连接的四元组，以及各连接的状态等内窑，如图1 - 17 所示，
图中的红框代表端口号。
：“「ess -F ……( st:tc) I 192.168.0.120.50971 74.125.204.100 443 SYN SENT I
192.168.0.120.50970 182.254.44.205.80 ESTABLISHED I
医11-17 IP 地址与端口信息
协议第二行和第二行是序列号，各占4 个字节。前者是指所发送数据包中数据部
分第个字节的序号，后者是指期望收到来自对方的下－个数据包中数据部分第一个
字节的序号。
122
仅供非商业用途或交流学习使用
第才章计算机基础
由于TCP 报头中存在一些扩展字段，所以需要通过长度为4 个bit 的头部长度宇
段表示TCP 报头的大小，这样接收方才能准确地计算出包中数据部分的开始位置。
TCP 的FLAG 位由6 个bit 组成，分别代表ACK 、SYN 、F町、URG 、PSH 、
RST ，都以置l 表示有效。我们重点关注SYN, ACK 和FIN 。SYN ( Synchronize
Sequence Numbers ）用作建立连接时的同步信号i ACK ( Acknowledgement ）用于对
收到的数据进行确认，所确认的数据由确认序列号表示； FIN ( Finish ）表示后面没有
数据需要发送，通常意昧着所建立的连接需要关闭了。
TCP 报头申的其他字段可以阅读盯C793 来掌握，本书在此不加赘述。接下来重
点分析TCP 中连接建立的原理。图1-18 展示了正常情形下通过三次握手建立连接的
过程。显然， B 机器是服务端角色， A 机器是客户端角色，前者需要在后者发起连接
建立请求时先打开某个端口等待数据传输，否则将无法正常建立连接。三次握手指的
是建立连接的三个步骤
•A 机器发出一个数据包并将SYN 置l ，表示希望建立连接。这个包中的序列
号假设是x 。
•B 机器收到A 机器发过来的数据包后，通过SYN 得知这是一个建立连接的
请求，于是发送一个响应包并将SYN 和ACK 标记都置l 。假设这个包中的
序列号是y ，而确认序列号必须是x+l ，表示收到了A 发过来的SYN a 在
TCP 中， SYN 被当作数据部分的一个字节。
•A 收到B 的响应包后需进行确认，确认包中将ACK 置l ，并将确认序列号
设置为y+ l ，表示收到了来自B 的SYNa
23
仅供才｜商业用途或交流学习使用
码出高效 Java 开发手册
cl;) A机器 8机器
「－ω→mz－zc
请求连接
.~-
二二二二二＋
二立Y._~＝＝ 1 ’－些~＂＇X 飞飞飞二～－－飞飞
的〈Z 刀。〈O
4、，守飞 ---
。E生~＂＇－＂
A c.eo?＇！、o -
' f>..C'f..：二三、,
s'<W 飞’
～～~~c~κ-＝＝ 1 飞 ＇－ 二『q:::x叫
～～－＿：＿＿：＿~些＝＝y 叫
～』－－－』』』
～二、～～－
mm→ky∞「－ω工mo
双向数据传输
ω〈Zωmz → mm→〉∞「一的工mo
图1-1 8 TCP 三次握手创建连接
这里为什么需要第3 次握手？它有两个主要目的信息对等和防止超时。先从信
息对等角度来看，如表1 -6 所示，双方只有确定4 类信息，才能建立连接。在第2 次
握手后， 从B 机器视角看还有两个红色的NO 信息无法确认。在第3 次握手后， B 机
器才能确认自己的发报能力和对方的收报能力是正常的。
表1-6 TCP 三次握手确认的信息
A 机器确认B 机器确认
第N 次握手自己自己对方对方自己自己对方对方
发报收报发报收报发报收报发报收报
能力能力能力能力能力能力能力能力
第l 次握手后NO NO NO NO NO YES YES NO
第2 次握手后YES YES YES YES NO YES YES NO
第3 次握手后1 伫气\ES 、E::-' 1 且严、ι、Y£S 飞E5 H S
124
仅供才｜商业用途或交流学习使用
第才重计算机基础
连接三次握手也是防止出现请求超时导致脏连接。TTL 网络报文的生存时间往
往都会超过TCP 请求超时时间， 如果两次握手就可以创建连接， 传输数据并释放连
接后， 第一个超时的连接请求才到达B 机器的话， B 机器会以为是A 创建新连接的
请求， 然后确认同意创建连接。因为A 机器的状态不是SYl'叫SENT ， 所以直接丢弃
了B 的确认数据， 以致最后只是B 机器单方面创建连接完毕， 简要示意图如图1-19
所示。
l;J A机器
：；二雯灿灿州学传输
二重新划生主－－－ ·
B机器
、二’
、H移手些如
委逸1捞拦乒Y
13＼＼＼署名模－－－－－－－－－－
.... 胎
、
茨～
υ句崎二
、创超～
开
断
输接
传连
握
数束
向结
双输
tHY
院毒要丰~－－－－－－－－－
图l 一19 两次握手导致的TCP 脏连接
25
仅供非nli业flJ途或交流学习使用
码出高效· Java 开发手册
如果是三次握手， 贝lj B 机器收到连接请求后，同样会向A 机器确认同意创建连接，
但因为A 机器不是SYN SENT 状态，所以会直接丢弃， B 机器由于长时间没有收到
确认信息， 最终超时导致连接创建失败，因而不会出现脏连接。根据抓包分析，呈现
出三次握手请求过程， SYN+ACK 的应答，告诉A 机器期望下一个数据包的第一个字
节序号为1 ， 如图1 - 20 所示。
ta』
E7 ps tM Cg HMH
-
I
e
--a
zk7 res cv4 ess $79 74
2‘
@
z1 口阳
FH
SEC -
pe
7
-s
gkT -c
3A
-
ZS7 12 aee v68 $47
τ28 $8
2S3 3SS
E
阿飞
回
i
咄
掌
S
M阴阳
y
aLe 3
=
E
Bn
sge 54L ”
4 24
·
=
a
BZn7 na
-
ew3 k2 5
2”
3ki SEW SA 63
阳哺」P
LqE WhZA 414 mMMm SA5 mmmu
ss
－民
@
68
868
s 咱
7·
s
66 6
-
6
S5 787 sas s
－崎
6
776 ppp ccc 777 99 271 322 242 989 55 777 7·7 43a
9
727 111 ·24 898 11
5
777 87· 343 @
6··
se2 389 EBB -
33
·-
3
111 ·23 222
图1-20 TCP 三次握手抓包分析
从编程的角度， TCP 连接的建立是通过文件描述待（ File Descriptor ，“） 完成的。
通过创建套接字获得一个fd ， 然后服务端和客户端需要基于所获得的“ 调用不同
的函数分别进入监昕状态和发起连接请求。由于臼的数量将决定服务端进程所能建
立连接的数量，对于大规模分布式服务来说，当阳不足时就会出现、pen too many
files ” 错误而使得无法建立更多的连接。为此，需要注意调整服务端进程和操作系统
所支持的最大文件句柄数。通过使用ulimit -n 命令来查看单个进程可以打开文件句柄
的数量。如果想查看当前系统各个进程产生了多少旬柄，可以使用如下的命令。
lsof -n I awk ’ ｛ pr工nt $2 ) ’ I sortlun 工q - c ! sort -nrlmore
执行结果如图1 - 21 所示，左侧列是旬柄数， 右侧列是进程号。ls of 命令用于查
看当前系统所打开臼的数量。在Linux 系统中，很多资源都是以臼的形式进行读写的，
除了提到的文件和TCP 连接， UDP 数据报、输入输出设备等都被抽象成了fd 。
图1-21 文件句柄与进程ID 的对应关系
26
®
仅供非商业用途或交流学习使用
第7 章计算机墓础
想知道具体的PID 对应的具体应用程序是谁，使用如下命令即可。
ps -axlgrep 32764
Java 进程示例如图1 -22 所示。
32764 ?? 0:06.65 /Libra 「y/Java/ JavaVirtua lMachines/j dk-11. j dk/Contents/H口me/bin/java ~ I" ,, b 叫b d酬B k叶p 19 p 32764
ead=true -Dpreload.project.path=/Users/yangguanba。／ book/easyCoding -Dpreload.config.path=/Use(
-Dcompile ‘ pa 「allel=false -D 「ebuild.on.dependency.change=true -Djava.net.preferIPv4Stack=true
图1-22 根据进程ID 查询具体进程
TCP 在协议层面支持Keep Alive 功能，即隔段时间通过向对方发送数据表示连
接处于健康状态。不少服务将确保连接健康的行为放到了应用层，通过定期发送心跳
包检查连接的健康度。_§_1L,·、跳包出现异常不仅会主动关闭连接，还会回收与连接相
关的其他用于提供服务的资源，确保系统资源最大限度地被有效利用。
才， 5.4 TCP 断开连接
TCP 是全双工通信，双方都能作为数据的发送方和接收方，但TCP 连接也会有
断开的时候。所谓相爱容易分手难，建立连接只有三次，而晖于断开则需要四次，如
图1 - 23 所示。A 机器想要关闭连接，贝lj 待本方数据发送完毕后，传递FIN 信号给B
机器。B 机器应答ACK ，告诉A 机器可以断开，但是需要等B 机器处理完数据，再
主动给A 机器发送FIN 信号。这时， A 机器处于半关闭状态（ FIN WAIT 2 ），无法
再发送新的数据。B 机器做好连接关闭前的准备工作后，发送FIN 给A 机器，此时
B 机器也进入半关闭状态（ CLOSE_ WAIT）。A 机器发送针对B 机器FIN 的ACK 后，
进入TIME-WAIT 状态，经过2MSL ( Maximum Segment Lifetime ）后，没有收到B
机器传来的报文，贝lj 确定B 机器已经收到A 机器最后发送的ACK 指令，此时TCP
连接正式释放。具体释放步骤如图1 -23 所示。
27
iJi.供才｜商业用这或交流学习使用
码出高效： Java 开发手册
通知应用进程
mmJ「〉田「一的工m口
B机器
双向数据传输
被动关闭
口「OωmEE → 「〉ω→〉口干〈
’协
川g巳.＼＜.°＂＼）.＼－＼ ___..-
. c.eO.~ ＂
队c'f...乡飞’ 飞
＂＂＇币主属协
冒争非克军βY '
U，。守、
』g巳b
• seO.＂＂响、
• 队0生乡、，
r ＇~＂＂ ＇ 、
-----,,,
飞飞飞飞飞『』ACK,,,1
' sen ～ 可『u+1
＇－~~：w叫
－～－－－－－－－－～牛毛－问』
.---
卫Z 〈〈E →－
2Z
<<>-•
N
I .•
I S:
1 m
持｜与
<M~L I )>
l •
()
「－
0
[J)
m
口
图1-23 TCP 四次挥手断开连接
通过抓包分析，如图1 - 24 所示红色箭头表示B 机器已经清理好现场，并发送
FIN+ACK。注意， B 机器主动发送的两次ACK 应答的都是81 ，第一次进入CLOSE
WAIT 状态，第二次应答进入LAST ACK 状态，表示可以断开连接，在绿色箭头处，
A 机器应答的就是Seq=8 1 。
国mmm
图1 -24 TCP 四次挥手抓包分析
®128
®
仅供非商业用途或交流学习佼用
第1 重计算机墓E出
四次挥手断开连接用通俗的说法可以形象化地这样描述。
男生我们分手吧。
女生好的，我的东西收拾完，发信息给你。（ 此时男生不能再拥抱女生了。）
( 1 个小时后）
女生，我收拾好了，分手吧。（此时， 女生也不能再拥抱男生了。）
男生。好的。（此时， 双方约定经过2 个月的过渡期，双方才可以分别找新的
对象。）
图卜23 中的红色字体所示的TIME WAIT 和CLOSE WAIT 分别表示主动关闭和
被动关闭产生的阶段性状态，如果在线上服务器大量出现这两种状态，就会加重机器
负载，也会影响有效连接的创建，因此需要进行有针对性的调优处理。
• TIME_WAIT ： 主动要求关闭的机器表示收到了对方的FIN 报文，并发送出
了ACK 报文，进入TIME WAIT 状态，等2MSL 后即可进入到CLOSED 状
态。如果FIN WAIT I 状态下，同时收到带FIN 标志和ACK 标志的报文肘，
可以直接进入TIME WAIT 状态，而无须经过FIN WAIT 2 状态。
• CLOSE_WAI 丁： 被动要求关闭的机器收到对方请求关闭连接的FIN 报文，
在第一次ACK 应答后，马上进入CLOSE WAIT 状态。这种状态其实表示在
等待关闭，并且通知应用程序发送剩余数据，处理现场信息，关闭相关资源。
在TIME WAIT 等待的2MSL 是报文在网络上生存的最长时间，超过阁值便将报
文丢弃。一般来说， MSL 大于TTL 衰减至0 的时间。在盯C793 中规定MSL 为2 分
钟。但是在当前的高速网络中， 2 分钟的等待时间会造成资源的极大浪费，在高并发
服务器上通常会使用更小的值。既然TIME WAIT 貌似是百害而无利的，为何不直
接关闭，进入CLOSED 状态呢？原因有如下几点。
第，确认被动关闭方能够顺利进入CLOSED 状态。如图1-23 所示，假如最
后一个ACK 由于网络原因导致无法到达B 机器，处于LAST ACK 的B 机器通常
“自信”地以为对方没有收到自己的FIN+ACK 报文，所以会重发。A 机器收到第二
次的FIN+ACK 报文，会重发一次ACK ，并且重新计时。如果A 机器收到B 机器的
FIN+ACK 报文后，发送个ACK 给B 机器，就“自私”地立马进入CLOSED 状态，
可能会导致B 机器无法确保收到最后的ACK 指令，也无法进入CLOSED 状态。这是
A 机器不负责任的表现。
29 I
仅供非商业用途或交流学习佼用
仅供非商业用途或交流学习佼用
Ii~ 出高效： Java 开发手册
第二，防止失效请求。这样做是为了防止己失效连接的请求数据包与正常连接的
请求数据包混淆而发生异常。
因为TIME WAIT 状态无法真正释放旬柄资源，在此期间， Socket 中使用的本地
端口在默认情况下不能再被使用。该限制对于客户端机器来说是无所谓的，但对于高
并发服务器来说，会极大地限制有效连接的创建数量，成为性能瓶颈。所以，建议将
高并发服务器TIME WAIT 超时时间调小。
在服务器上通过变更／巳telsysctl. conf 文件来修改该省略值（秒） '
net.ipv4.tcp_fin_timeout = 30 （建议小于30 秒为宜）。
修改完之后执行／sbin/sysctl -p 让参数生效即可。可以通过如下命令
netstat - n I awk '/<tcp/ {++S[$NF]} END ( for (a 工n S) print a, S [a ]}’
查看各连接状态的计数情况，为了使数据快速生效， 2MSL 从240 秒更改为5 秒。参
数生效后如图1 -25 所示， TIME WAIT 很快从75 个降为1 个。
SYN SENT 5
LAST ACK 3
CLOSE WAIT 2
TIME WAIT 75
ESTABLISHED 52
FIN WAIT 1 4
SYN SENT 4
LAST ACK 2
CLOSE WAIT 2
TI 阿E WAIT 1
ESTABLISH 王D 18
图1 -25 各种TCP 状态的计数
在sysctl.conf 中还有其他连接参数也用来不断地调优服务器TCP 连接能力，以
提升服务器的有效利用率。毕竟现代网络和路由处理能力越来越强，跨国时延通常也
在l 秒钟以内，丢包率极低。如何快速地使连接资源被释放和复用，参数的优化往往
可以取得事半功倍的效果。记得某大公司在大型购物节时，系统岩机，老总下令要加
一倍服务器来解决问题。事实上，如果是参数配置错误导致的系统音机，即使增加硬
件资源，也无法达到好的效果。硬件的增加与性能的提升绝对不是线性相关的，更多
的时候是对数曲线关系。
TIME WAIT 是挥手四次断开连接的尾声，如果此状态连接过多，贝lj 可以通过
优化服务器参数得到解决。如果不是对方连接的异常，一般不会出现连接无法关闭
的情况。但是CLOSE WAIT 过多很可能是程序自身的问题，比如在对方关闭连接
后，程序没有检测到，或者忘记自己关闭连接。在某次故障中，外部请求出现超时
的情况，当时的Apache 服务器使用的是默认的配置方式，通过命令netstat -ant[grep
®130
仅供非商业用途或交流学习使用
仅供非商业用途或交流学习佼用
第才章计算机基础
-i "443"lgrep CLOSE_ WAITlwc -I 发现在HTTPS 的443 端口上堆积7 2.1 万个左右的
CLOSE_ WAIT 状态。经排查发现，原来是某程序处理完业务逻辑之后没有释放流操作，
但程序一直运行正常，直到运营活动时才大量触发该业务逻辑，最终导致故障的产生。
1.5.5 连接池
我们使用连接来进行系统间的交互，如何管理成千上万的连接呢？服务器可以快
速创建和断开连接，但对于高并发的后台服务器而言，连接的频繁创建与断开，是非
常重的负担。就好像我们正在紧急处理线上故障，给同事打电话一起定位问题时，
般情况下都不会挂断电话，直到问题解决。在时间极度紧张的情况下，频繁地拨打和
接听电话会降低处理问题的效率。在客户端与服务端之间可以事先创建若干连接并提
前放置在连接池中，需要时可以从连接池直接获取，数据传输完成后，将连接归还至
连接池中，从而减少频繁创建和释放连接所造成的开销。例如， RPC 服务集群的注册
中心与服务提供方、消费方之间，消息服务集群的缓存服务器和消费者服务器之间，
应用后台服务器和数据库之间，都会使用连接池来提升性能。
重点捏一下数据库连接池，连接资源在数据库端是一种非常关键且有限的系统
资源。连接过多往往会严重影响数据库性能。数据库连接池负责分配、管理和释放连
接，这是种以内存空间换取时间的策略，能够明显地提升数据库操作的性能。但如
果数据库连接管理不善，也会影响到整个应用集群的吞吐量。连接池配置错误加上慢
SQL ，就像屋漏偏逢连夜雨，可以瞬间让一个系统进入服务超时假死音机状态。
如何合理地创建、管理、断开连接呢？以Druid 为例， Druid 是阿里巴巴的一个
数据库连接池开源框架，准确来说它不仅仅包括数据库连接池，还提供了强大的监控
和扩展功能。当应用启动时，连接池初始化最小连接数（ MIN ）；当外部请求到达时，
直接使用空闲连接即可。假如并发数达到最大（ MAX ），贝lj 需要等待，直到超肘。
如果一直未拿到连接，就会抛出异常。
如果MIN 过小，可能会出现过多请求排队等待获取连接，如果MIN 过大，会
造成资源浪费。如果MAX 过小，则峰值情况下仍有很多请求处于等待状态；如果
MAX 过大，可能导致数据库连接被占满，大量请求超时，进而影响其他应用，引发
服务器连环雪崩。在实际业务中，假如数据库配置的MAX 是100 ， 一个请求！ Oms,
则最大能够处理IOOOOQPS 。增大连接数，有可能会超过单台服务器的正常负载能力。
另外，连接数的创建是受到服务器操作系统的“（文件描述符）数量限制的。创建更
多的活跃连接，就需要消耗更多的阳，系统默认单个进程可同时拥有1024 个白，该e 31 I
仅供非商业用途或交流学习佼用
仅供非商业用途或交流学习佼用
码出高效： Java 开发手册
值虽然可以适当调整，但如果无限制地增加，会导致服务器在臼的维护和切换上消
耗过多的精力，从而降低应用吞吐量。
懒惰是人的天性，有时候开发工程师为了图省事还会不依不饶地要求调长
Timeout 时间，如果这个数值过大，对于调用端来说也是不可接受的。如果应用服务
器超时，前台已经失败返回，但是后台仍然在没有意义地重试，并且还有新的处理请
求不断堆积，最终导致服务器崩溃。这明显是不合理的。所以在双十一的场景里，应
用服务器的全链路上不论是连接池的峰值处理，还是应用之间的调用频率，都会有相
关的限流措施和降级预案。
图1-26 所示的是某连接池的监控图。图中连接池最小的连接数是2 ， 一个线程
就是个活跃连接。－般可以把连接池的最大连接数设置在3 0 个左右， 理论上还可
以设置更大的值，但是DBA 般不会允许，因为往往只有出现了慢SQL ， 才需要使
用更多的连接数。这时候通常需要优化应用层逻辑或者创建数据库索引，而不是一昧
地采用加大连接数这种治标不治本的做法。极端情况下甚至会导致数据库服务不晌应，
进而影响其他业务。
bhreads rurmm日趋势图
图1-26 连接池的监控图
从经验上来看，在数据库层面的请求应答时间必须在IOOms 以内，秒级的SQL
查询通常存在巨大的性能提升空间，有如下应对方案，
( I ） 建主高效且合适的索引。索寻｜谁都可以建，但要想建好难度极大。因为索
引既有数据特征，又有业务特征，数据量的变化会影响索引的选择，业务特点不样，
索引的优化思路也不样。通常某个字段平时不用，但是某种触发场景下命中“索召｜
缺失”的字段会导致查询瞬间变慢。所以，要事先明确业务场景，建立合适的索引。
( 2 ）排查连接资源未显式关闭的情形。要特别注意在ThreadLocal 或流式计算
申使用数据库连接的地方。
号I 32
仅供非商业用途或交流学习佼用
第1 章计算机基础
{ 3 ）合并短的请求。根据CPU 的空间局部性原理，对于相近的数据， CPU 会
起提取到内存中。另外，合并请求也可以有效减少连接的次数。
{ 4 ） 合理拆分多个表join 的SQL ， 若是超过三个表则禁止join 。如果表结构建
得不合理，应用逻辑处理不当，业务模型抽象有问题， 那么三表join 的数据量由于笛
卡儿积操作会呈几何级数增加，所以不推荐这样的做法。另外，对于需要join 的字段，
数据类型应保持绝对一致。多表关联查询时，应确保被关联的字段要有索引。
( 5 ） 使用｜临时表。某种情况下，该方法是一种比较好的选择。曾经遇到－个场
景不使用临时表需要执行1 个多小时， 使用临时表可以降低至2 分钟以内。因为在不
断的嵌套查询中，已经无法很好地利用现有的索引提升查询效率，所以把中间结果保
存到临时表1 然后重建索引， 再通过临时表进行后续的数据操作。
( 6 ） 应用层优化。包括进行数据结构优化、并发多线程改造等。
( 7 ） 改用其他数据库。因为不同数据库针对的业务场景是不同的，比如
Cassandra 、MongoDB 。
1.6 信息安全
1.6.1 黑害与安全
黑客是音译词，译自Hacker。黑客的卫生击手段十分多样，大体可分为非破坏性
攻击和破坏性攻击。非破坏性攻击－般是为了扰乱系统的运行，使之暂时失去正常对
外提供服务的能力， 比如DDoS 攻击等。破坏性攻击主要会造成两种后果系统数据
受损或者信息被窃取，比如CS RF 攻击等。黑客使用的攻击手段有病毒式、洪水式、
系统漏洞式等。黑客是计算机世界里永恒的存在，攻与守如同太极阴阳平衡的道家之
道， 不可能有一天黑客会彻底消失。
现代黑客攻击的特点是分布式、高流量、深度匿名。由于国外大量“ 肉鸡”没有登记，
所以国外的服务器遭遇DDoS 攻击时，无法有效地防御。现今云端提供商的优势在于
能提供套完整的安全解决方案。离开云端提供商， 个小企业要从头到尾地搭建一
套安全防御体系，技术成本和资源成本将是难以承受的。所以互联网企业都要建立一
套完整的信息安全体系，遵循C IA 原则， 即保密性（ Confidentiality ) ，完整性（ Integrity ),
可用性（ Availab ility ）。
·保密性。对需要保护的数据（比如用户的私人信息等）进行保密操作， 无论e 33 I
仅供非商业用途或交流学习使用
码出高效J ava 开发手册
是存储还是传输， 都要保证用户数据及相关资源的安全。比如， 在存储文件
时会进行加密，在数据传输中也会通过各种编码方式对数据进行加密等。在
实际编程中，通常使用加密等手段保证数据的安全。黑客不只是外部的，有
可能从内部窃取数据，所以现在大多数企业的用户敏感信息都不是以明文存
储的，避免数据管理员在某些利益的驱动下，直接拖库下载。数据泄露可能
导致黑客进步利用这些数据进行网站攻击，造成企业的巨大损失。
·完整性。访问的数据需要是完整的，而不是缺失的或者被篡改的， 不然用户
访问的数据就是不正确的。比如， 在商场看中一个型号为NB 的手机， 但售
货员在包装的时候被其他人换成了更便宜的型号为LB 的于机，这就是我们
所说的资源被替换了，也就是不满足完整性的地方。在实际编写代码中， 一
定要保证数据的完整性， 通常的做法是对数据进行签名和校验（比如MDS
和数字签名等）。
·可用性。服务需要是可用的。如果连服务都不可用， 也就没有安全这－说了。
比如还是去商场买东西，如果有人恶意破坏商场，故意雇用大量水军在商场
的收银台排队，既不结账也不走， 导致其他人无法付款，这就是服务已经不
可用的表现。这个例子和常见的服务拒绝（ Dos ）攻击十分相似。对于这种情况，
通常使用访问控制、限流等手段解决。
以上三点是安全中最基本的三个要素， 后面谈到的Web 安全问题， 都是围绕这
三点来展开的。
1.6.2 SQL 注入
SQL 注入是注入式攻击中的常见类型。SQL 注入式攻击是未将代码与数据进行
严格的隔离，导致在读取用户数据的时候， 错误地把数据作为代码的一部分执行， 从
而导致一些安全问题。SQL 注入自诞生以来以其巨大的杀伤力闻名。典型的SQL 注
入的例子是当对SQL 语旬进行字符串拼接操作时， 直接使用未加转义的用户输入内
容作为变量，比如
var testCondition ;
testCondi t ion = Request . from （ ” 一str )Jj(, f 工【” ）
var sql ＝ ” 。m 厅1 ~. w t1ere i:l = ’”' • ' t 、·l tL) f 中”’”；
在上面的例子中， 如果用户输入的ID 只是一个数字是没有问题的， 可以执行正
®134
仅供非商业用途或交流学习使用
第才章计算机基础
常的查询语句。但如果直接用“；”隔开，在testCond山on 里插入其他SQL 语旬，贝iJ
会带来意想不到的结果，比如输入drop 、delete 等。
曾经在某业务中，用户在修改签名时，非常偶然地输入咱一！＃（＠这样的内容用
来表达心情，单击保存后触发数据库更新。由于该业务未对危险字符串"# －－＂进行
转义，导致where 后边的信息被注释掉，执行语句变成
update table set memo= # -- !#(@ "where use_id=12345 ;
该SQL 语旬的执行导致全库的memo 字段都被更新。所以， SQL 注入的危害不
必赘述，注入的原理也非常简单。应该如何预防呢？这里主要从下面几个方面考虑
( I ）过滤异户输入参＆中的阿弥字符，从而降低被SQL ,t 入的风险。
( 2 ）禁止通过字符南拼撞的SQL i吾旬，严恪使用参数绑定传人的SQL 参数c
( 3 ）合理使月数据库击可框豆、提供的防左入机制。比如MyBatis 提供的＃｛｝绑
定参数，从而防止SQL 注入。同时谨慎使用$｛｝＇ $｛｝相当于使用字符串拼接SQL 。
拒绝拼撞的SQL i吾旬，使用参数化的语句。
总之，一定要建立对注入式攻击的风险意识，正确使用参数化绑定SQL 变量，
这样才能有效地避免SQL 注入。实际上，其他的注入方式也是类似的思路，身为一
个开发工程师，我们定要时刻保持对注入攻击的高度警惕。
1.6.3 xss 与CSRF
xss 与cs盯两个名词虽然都比较熟悉，但也容易混淆。跨站脚本攻击，即
Cross-Site Scripting ，为了不幸日前端开发中层叠样式表（ css ）的名字冲突，简称为
XSSa XSS 是指黑客通过技术手段，向正常用户请求的HTML 页面中插入恶意脚本，
从而可以执行任意脚本。xss 主要分为反射型xss 、存储型xss 和DOM 型xss 。
xss 主要用于信息窃取、破坏等目的。比如发生在2011 年左右的微博xss 蠕虫攻击
事件，攻击者就利用了微博发布功能中未对action-data 漏洞做有效的过滤，在发布微
博信息的时候带上了包含攻击脚本的URL。用户访问该微博时便加载了恶意脚本，
该脚本会让用户以自己的账号自动转发同条微博，通过这种方式疯狂扩散，导致微
博大量用户被攻击。
从技术原理上，后端Java 开发人员、前端开发人员都有可能造成xss 漏洞，比
如下面的模板文件就可能导致反射型xss
35
仅供二ll'ilii业用途或交流学习使用
码出高效· Java 开发手册
< d 工v>
<h3 ＞反射型XSS 示例＜／ h3>
<br ＞用户： 〈毡＝ request . getParameter （ ” userName ” ）毛〉
<br＞系统错误信息． 〈毛＝ request . getParameter （ ” errorMessage ” ） 毡〉
<Id 工v>
上面的代码从HTTP 请求中取了userName 和errorMesage 两个参数，并直接输
出到HTML 中用于展示， 当黑客构造如下的U虹时就出现了反射型xss ， 用户浏览
器就可以执行黑客的JavaScript 脚本。
http : //xss .demo/self xss . jsp?userName ＝ 张三＜ script>alen: （ ” 张三” ）＜／ script>
&errorMessage=XSS 示例＜ script src=http : //hacker . demo/xss 叮cript . js />
在防范xss 上，主要通过对用户输入数据做过滤或者转义。比如Java 开发人
员可以使用Jsoup 框架对用户输入字符串做xss 过滤，或者使用框架提供的工具
类对用户输入的字符串做HTML 转义，例如Spring 框架提供的HtmlUtils。前端在
浏览器展示数据时， 也需要使用安全的API 展示数据，比如使用innerText 而不是
innerHTML。所以需要前、后端开发人员一同配合才能有效防范xss 漏洞。
除了开发人员造成的漏洞，近年来出现了一种Self-XSS 的攻击方式。Sel f-XSS
是利用部分非开发人员不懂技术，黑客通过红包、奖品或者优惠券等形式， 诱导用户
复制攻击者提供的恶意代码， 并非占贴到浏览器的Console 中运行， 从而导致xss 。由
于Self-XSS 属于社会工程学攻击，技术上目前尚无有效防范机制， 因此只能通过在
Console 中展示提醒文案来阻止用户执行未知代码。
1.6.4 CSRF
跨站请求伪造（ Cross-Site Request Forgery ） ， 简称C SRF ， 也被称为One-click
Attack , !l.D 在用户并不知惰的情况下， 冒充用户发起请求， 在当前已经登录的Web 应
用程序上执行恶意操作，如恶意发帖、修改密码、发邮件等。
cs盯有另lj 于xss ，从政击效果上， 两者有重合的地方。从技术原理上两者有
本质的不同， xss 是在正常用户请求的HTML 页面中执行了黑客提供的恶意代码，
c s盯是黑客直接盗用用户浏览器中的登录信息， 冒充用户去执行黑客指定的操作。
xss 问题出在用户数据没有过滤、转义l cs盯问题出在HTTP 接口没有防范不受信
任的调用。很多工程师会混淆这两个概念，甚至认为这两个卫生击是一样的。
比如某用户A 登录了网上银行，这时黑客发给他个链撞， URL 如下I
https : //net- bank .demo/transfer .do?targetAccount=l2345&amount=l00
136
仅供非商业用途或交流学习使用
第才章计算机基础
如果用户A 在打开了网银的浏览器中点开了黑客发送的URL ，那么就有可能在
用户A 不知情的情况下从他的账户转100 元人民币到其他账户。当然网上银行不会
有这么明显的漏洞。
防范CSRF 漏洞主要通过以下方式，
( I ) CSRF Token 验证，利用浏览器的同源限制，在HTTP 接口执行前验证页面
或者Cookie 中设置的Token ，只有验证通过才继续执行请求。
( 2 ） 人机交互，比如在调用上述网上银行转账接口时校验短信验证码。
1.6.5 HTTPS
在谍战剧里，情报如何不被截获，不被破译，几乎是全剧的主线剧情之一。某电
台通过某个频道发送一串数字，然后潜伏人员般会拿密码本，译码后得到原文。这
个密码本就是对称加密中的密钥， 发送方和接收方按照密码本分别进行加密和解密工
作。如果密码本被敌人截获，则后果极为严重，通常能够做的也就是更换密码本。
早期计算机都是单机状态，保证数据的安全依赖于加密算法的可靠性。如果加密
算法可靠，即使存储介质被窃取，对方想通过密文恢复明文也是十分困难的。DES 加
密算法是一种对称加密算法，它几乎让破解者无法找到规律，即使暴力破解也很难还
原出明文。
发展到网络时代，整个网络中最频繁、最重要的操作就是网络中各终端之间的通
信。在传输层本身不会做任何的加密，这就好比辆满载黄金的马车在驿道奔驰， 很
难不让网络上的黑客视而不见。如何保证通信之间数据传输的安全性，成为了计算机
网络时代最重要的安全课题。说到对网络传输数据的加密，必须要先说安全套接字层
( Secure Socket Layer, SSL ）。SSL 协议工作于传输层与应用层之间，为应用提供数
据的加密传输。而HTTPS 的全称是HTTP over SSL ，简单的理解就是在之前的HTTP
传输上增加了SSL 协议的加密能力。
我们可以通过对称加密算法对数据进行加密，比如DES ，即一个主站与用户之
间可以使用相同的密钥对传输内容进行加解密。是否可以认为这样就完全没有风险
呢？答案显然是否定的。因为密钥几乎没有什么保密性可言，如果与每一个用户之间
都约定一个独立的密钥，如何把密钥传输给对方，又是个安全难题。在互联网上，
IP 报文好比官道上运送粮草、黄金、物资的载体，很容易被人盯上，密钥本身如果被
盗，那么再复杂的密钥也是摆设。自然的想法是在密钥之上再加密，这就是递归的穷
举问题了。
37
仅供二ll0P:Ji业用途或交流学习佼用
码出高效· Java 开发手册
有没有一种方式，使报文被截取之后，黑客依然无计可施呢？一种全新的算法
RSA 出现了。它把密码革命性地分成公钥和私钥，由于两个密钥并不相同，所以称
为非对称加密。私钥是用来对公钥加密的信息、进行解密的，是需要严格保密的。公钥
是对信息进行加密，任何人都可以知道，包括黑客。
非对称加密的安全性是基于大质数分解的困难性，在非对称的加密中公钥和私钥
是一对大质数函数。计算两个大质数的乘积是简单的，但是这个过程的逆运算（即将
这个乘积分解为两个质数）是非常困难的。而在RSA 的算法中，从一个公钥和密文
中解密出明文的难度等同于分解两个大质数的难度。因此在实际传输中，可以把公钥
发给对方。一方发送信息时，使用另一方的公钥进行加密生成密文。收到密文的－方
再用私钥进行解密，这样一来，传输就相对安全了。
但是非对称加密并不是完美的，它有一个很明显的缺点是加密和解密耗时长，只
适合对少量数据进行处理。回到前面的例子中， 我们担心对称加密中的密钥安全问题，
那么将密钥的传输使用非对称加密就完美地解决了这个问题。实际上， HπPS 也正
是通过这样一种方式来建立安全的S SL 连接的。按照上述逻辑，用户甲与用户乙进
行非对称加密传输的过程如下，
( I ）甲π 诉乙， 1Y' 用RSA ＇..（！法进h}J1.\iBo {' J兑．好的。
( 2 ）甲和乙分另lj 根据RSAι 成别ti; 钥，气村发送公钊3
( 3 ）甲使用乙的公钥给乙加步、m 文h 患。
( 4) t'.，收到信写． ．并d 白：均l&; 毛FlH丁解;i'.; 。
( 5 ） ι 使用同样方式给甲气吧信白，回使用唱［ι〕方式证行解密。
这个过程，看起来似于无懈可击， 但是在TCP /IP 里，端到端的通信，路途遥远，
夜长梦多。在（ 2 ） 中， 如果甲的送信使者中途被强盗截住， 在严刑拷打之下，强盗
知道使者是去送公钥的，虽然没有办法破解甲的加密信息，但是可以把这个使者关起
来，自己生成对密钥，然后冒充甲的使者到乙家，把自己的公钥给乙。乙信了，把
银行卡密码、存款金额统统告诉了中间的强盗。
所以，在解决了加密危机之后又产生了信任危机。如何解决信任问题呢？如
果有一个具有公信力的组织来证明身份，这个问题就得到了解决。CA ( Certificate
Authority ）就是颁发HTTPS 证书的组织。HTTPS 是当前网站的主流文本传输协议，
在基于HTTPS 进行连接时， 就需要数字证书。如图1-27 所示， 可以看到协议版本、
签名方案、签发的组织是Globa!Sign ， 这个证书的有效期至2018 年10 月31 日。
38
仅供~I三商业用途或交流学习佼用
协议虑本， 飞Sv'2
密码窜作－ τLS ECDHE RSA_WITH_}\ES_t28 GCM SHA256
密恬直盟国P256
盖在万事： RSA·PKCS1 SHA512
圭吼www. a baba.com
HT丁P 严格由辅置主制STS) <=J;"";用
仕IP.II主己？与阿
证书
苞革结
一边吕昭ICNI · .a oaba com
组织101' A ibaba (Co na) Tecorolcgy Co, ltd
组织单元IOU ） ＇ ＜平可用〉
苗血青
一般吕甜（ CN) : G oba Sign Organizat on Va'idation CA· SHA256 · G2
组织（ 0): Globa S gr nv·sa
组织!l!元｛。UJ: ＜京可用〉
哥姐lift.
起始时间20171"!0~30 日
姿止时间2018王军101'31 日
图1-27 CA 数字证书
访问一个HTTPS 的网站的大致流程如下，
第1 章计算机基础
( I ）浏览器向服务器发送请求，请求中包括浏览器支持的协议，并附带一个随
机数。
( 2 ）服务器收到请求后，选择某种非对称加密算法，把数字证书签有公钥、身
份信息发送给浏览器，同时也附带一个随机数。
( 3 ）浏览器收到后、验证证书的真实性，用服务器的公铝发送握手信息给服务器。
( 4 ） 服务器解密后， 使用主前的随机数计算出，个对称加密的密钥， 以此作为
加密信息并发送。
( 5 ） 后续所有的信息发送都是以对称加密方式进行的。
我们注意到在证书的信息中出现了传输层安全协议（ Transport Layer Security,
TLS ）的概念。这里先解释TLS 和SSL 的区别。TLS 可以理解成SSL 协议3.0 版本
的升级，所以TLS 的1.0 版本也被标识为SSL 3 . 1 版本。但对于大的协议枝而言，
SSL 和TLS 并没有太大的区别，因此在Wireshark 里，分层依然用的是安全套接字层
(SSL ）标识。
在整个HTTPS 的传输过程中，主要分为两部分首先是HTTPS 的握手，然后
是数据的传输。前者是建立一个HTTPS 的通道，并确定连接使用的加密套件及数据
传输使用的密钥。而后者主要使用密钥对数据加密并传输。
首先来看HTTPS 是如何进行握手的，如图1 -28 所示是一个完整的SSL 数据流
和简单流程。
39
仅供二｜｜商业用途或交流学习使用
仅供＇°＇商业用途或交流学习使用
码出高效： Ja va 开发手册
........................................
卢二二一一一二千千斗斗d 隔麟’盹嚣.. 蠕黯． ....，..」4旦』冒”酬鸭””酬酬同田丁左翼E
v。””蝇’·“’（A(:t(JS.”.，呻缸”扬“
与~且且战~凶溢：＝，；，，孟凶远L岳出’＂＇＂
K’ ”’~361 ~“’ υ旺则’饵’2’•2 Ack”“2 W'U.1121“ U伽··
T比如L ’“‘”""”“'"' TlC..• ·~旬，＂＂＂翩。时，
A中几
C li 叫
Serve 「确定采布后丽习自己会话I D
一
｛患
DH
一书
剑
一
正
k-E 州
一发
户－hMF
r
’－－
c
-m e Q
)
e G4 nA
JH
av
』A
h
山
:
t
w川坷
’U
「
巳
E
J
FR puje
r
k
剑
l
「
C
f
e
们mv
叶川
mue q
〉户U
1. Ce「tificat白j 揣韶；；；～
Change Ciphe 「Spec
E nc「ypted Handshake Message
双向数据传输
图1- 28 HTIPS 连接建立过程
140
B 机器
.
仅供11＇ 附业月1 途或交流学习使用
第才章计算机基础
第一， 客户端发送了个Client Hello 协议的请求在Client Hello 中最重要的信
息是Cipher Suites 字段，这里客户端会告诉服务端自己支持哪些加密的套件。比如在
这次SSL 连接中， 客户端支持的加密套件协议如图1-29 所示。
..,. Ciphe 「Suites (20 suites)
Ciphe 「Suite: TLS_ECDHE_ECDSA_WITH_AES_256_GC伺＿SHA384 (0xc02c)
Ciphe 「Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)
Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 (0xc024)
Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 (0xc023)
Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA (0xc00a)
Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xc009)
Ciphe 「Suite: TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 (0xcca9)
Cipher Suite : TLS_ECDHE_RSA_WITH_AES_256_GC”_SHA384 (0xc030)
Ciphe 「Suite: TLS_ECDHE_RSA_WITH_AES_128_GC”_SHA256 (0xc02f)
Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 (0xc028)
Cipher Suite: TLS_ECDHE_RSA_WITH.λES_128_CBC_SHA256 (0xc027)
Ciphe 「Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xc014)
Ciphe 「Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)
Cipher Suite: TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xcca8)
Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)
Cipher Suite: TLS_RSA_WITH_AES_128_GO咱＿SHA256 (0x009c)
Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA256 (0x003d)
Ciphe 「Suite: TLS_RSA_WITH_AES_128_CBC_SHA256 (0x003c)
Ciphe 「Suite: TLS_RSA_WITI仁AE5_256_CBC_SHA (0x0035)
Ciphe 「Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)
图1-29 Ciph 巳r Suites
第二， 服务端在收到客户端发来的Client Hello 的请求后， 会返回一系列的协议
数据， 并以一个没有数据内容的Server Hello Done 作为结束。这些协议数据有的是单
独发送，有的则是合并发送， 这里分别解释下几个比较重要的协议， 如图1 -30 所示。
~， ......司ol."'!i'r.I冒~ilim•a•• 司………………………………………………………
..,. TLSvl. 2 Re co 「d Layer : Handshake Protocol: Server Hello
Content Type: Handshake (22)
Version: TLS 1.2 (0x0303)
Length: 108
..,. Handshake Protocol: Server Hello
Handshake Type: Server Hello (2)
Length: 104
Version: TLS 1.2 (0x0303)
"' Random: lb765bad74b75dc2a547bcd0914bb32304f9374e981a5e08 •••
Session ID Length: 32
Session ID: a92819230cd672adfedfb36e2970ca8b3550736decb08c0e •••
Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
Compression Method: null (0)
Extensions Length: 32
1> Extension: se 「ve 「＿name (len=0)
1> Extension: renegotiation_info (len=l)
1> Extension: ec_point_fo 「mats (len=4)
1> Extension: application_laye 「_protocol_negotiation ( len=ll)
图1-30 SSL ↑办议．
41
仅供才｜ 商业用途或交流学习使用
码出高效： Java 开发手册
( I ) Server Hell o 协议。主要告知客户端后续协议中要使用的TLS 协议版本，
这个版本主要和客户端与服务端支持的最高版本有关。比如本次确认后续的TLS 协
议版本是TLSvl.2 ，并为本次连接分配个会话ID ( Session ID ）。此外，还会确
认后续采用的加密套件（ Cipher Suite ）， 这里确认使用的加密套件为TLS_ECDHE
RSA WITH AES 128 GCM SHA256。该加密套件的基本含义为， 使用非对称协议
加密（ RSA ） 进行对称协议加密（ AES ）密钥的加密，并使用对称加密协议（ AES )
进行信息的加密。
( 2 ) Certificate 协议。主要传输服务端的证书内容。
( 3 ) Server Key Exchange 。如果在Certificate 协议中未给出客户端足够的信患，
则会在Server Key Exchange 进行补充， 如图1-31 所示。比如在本次连接中Certificate
未给出证书的公钥（ Public k巳y ）， 这个公钥的信息将会通过Server Key Exchange 发
送给客户端。
"' EC Diffie-Hellman Se 「ver Params
Cu 「ve Type: named_cu 「ve (0x03)
Named Cu 「ve: secp256rl （自x0017)
Pubkey Length: 65
Pubkey: 04dc07762b35c80628dff85f77dc82ce80afb5fc727af261 ...
,,. Signatu 「E Algo 「ith m ：「sa_pkcsl_sha512 (0x0601)
Signatu 「E Length: 256
Signatu 「e: 0cc2955ce3b90aebbc6246f6ad8cf8d61eade05112f6b494 •.
图1-31 Server Key Exchange
( 4 ) Certificate Req u est。这个协议是一个可选项， 当服务端需要对客户端进行
证书验证的时候， 才会向客户端发送一个证书请求（ Certificate Request ） 。
( 5 ）最后以Server Hello Done 作为结束信息， 告知客户端整个Serve r Hello 过
程结束。
第二， 客户端在收到服务端的握手信息后， 根据服务端的请求， 也会发送系列
的协议。
( I ) Certifi cate 。它是可选项。因为上文中服务端发送了Certificate Request 需要
对客户端进行证书验证， 所以客户端要发送自己的证书信息。
( 2 ) Cli ent Key Exc h a nge。它与上文中Server Key Exchange 类似， 是对客户端
C ertificate 信息的补充， 在本次请求中同样是补充了客户端证书的公钥信息， 如图1-32
所示。
I 42
仅供＇ °＇ n有业用途或交流学习使用
... Handshake P 「otocol: Client Key Exchange
Handshake Type: Client Key Exchange (16)
Length: 66
,.. EC Diffie-Hellman Client Params
Pubkey Length: 65
第才章计算机基础
Pubkey: 0441504d4054613e豆元d30170c34d822e8dc44dfac040e9... ]
图1 -32 Client Key Exc hange
( 3 ) Certification Verity 对服务端发送的证书信息进行确认。
· 4 · Change Cipher 飞p..:c 该协议不同于其他握手协议（ Ha n dshake P rotoco l ) ,
而是作为一个独立协议告知服务端，客户端己经接收之前服务端确认的加密套件， 并
会在后续通信中使用该加密套件进行加密。
( 5 ) Encrypted I landslrnke Message 用于客户端给服务端加密套件加密一段
Finish 的数据， 用以验证这条建立起来的加解密通道的正确性。
第四， 服务端在接收客户端的确认信息及验证信息后， 会对客户端发送的数据进
行确认， 这里也分为几个协议进行回复。
I Change Cipher 、pee 通过使用私钥对客户端发送的数据进行解密， 并告知
后续将使用协商好的加密套件进行加密传输数据。
( 2 ）上11 川yptcd I landshakc Message 与客户端的操作相同， 发送－段F in is h 的加
密数据验证加密通道的正确性。
最后，如果客户端和服务端都确认加解密无误后， 各自按照之前约定的Sessio n
Secret 对Application Data 进行加密传输。
1.7 编程语言的发展
编程语言以既定的语法规则，使用－ t.且自定义的特定标记字符流或关键字， 实现
基本的顺序、条件、循环处理， 这样的逻辑通过编译或解释形成计算机底层硬件可以
执行的一系列指令， 来自动化执行某种逻辑计算或实现某种需求。计算机语言诞生的
历史虽然很短， 可是已经产生了上千种编程语言。为什么编程语言如此之多？其实这
反映了一种生物多样化的自然属性。随着时代的进步， 编程语言就像一棵树， 树根是
O 与l ，越往上生长树枝越多，这些树枝快速产生的原因和计算机技术应用的快速蓬
勃发展有关。计算机从单机时代， 到网络时代、移动时代、云计算， 直至目前的A I
43
仅供11＇ 附业月1 途或交流学习使用
码出高效： Java 开发手册
时代， 总有一批编程语言随着大潮退去，又有批新的语言随着浪潮诞生。从编程语
言类型的角度， 可划分为三个编程语言时代
第一代，机器语言时代。机器语言的编程就是单纯的0 与l 的二进制流输入。机
器语言的优点是可以直接对芯片进行指令操作，最大的问题也来源于此。换套不同
的硬件环境， 机器语言几乎100 % 卡壳。另外，指令不利于记忆，语言的生产率非常低。
汇编语言本质上与机器语言处于同一个时代，只是在与机器指令对应的字符编程方式，
以及助记符之上增加了编译功能。
第二代，高级语言时代。高级语言正是当前百花齐放的时代。正因为机器语言面
向机器编程，理解度差，复用度低。无论是面向过程，还是面向对象，都是面向问题编程，
不是描述计算机具体应该执行什么样的分步操作，而是更倾向于描述需要解决的问题
本身。面向过程更多描述的是解决问题的步骤，在实际步骤中协调各个参与方达成最
后的目标，面向对象是抽象问题各方的参与者，包括领域对象、问题域、运行环境等，
然后定义各个参与者的属性与行为，最后合力解决问题。高级语言时代，尤其是C 、
C＋＋、Java 、Python 等这些工业级语言的诞生和发展，使计算机行业得到极大的发展，
推动了五联网和人工智能的快速发展。
第三代，自然语言时代。自然语言编程是面向思维或模糊语义的编程方式，软件
生产只是思考问题本身的存在性和合理性，而不是定义问题的解决方式和解决步骤。
这个时代很遥远， 但很唯美。相信随着A I 科技的不断进步，一定会实现。
存在即是合理， 本节并非讨论编程语言的高低优劣，对编程语言历史的回顾，只
是让我们更加热爱从事的编程事业，了解那些大师们的伟大，体验语言背后的魅力与
时代特征。
早在1936 年，图灵在〈论数字计算在决断难题中的应用〉论文中提出了图灵机
的设想。图灵机假想有一条无限长的纸带， 纸带上有一系列带有某种信息的方格， 机
器会根据当前状态和控制规则， 处理当前方格上的信息，然后纸带移动或跳转一格。
编写这个纸带的过程就是最初的编程雏形，形成的规则来操控图灵机进行顺序读取，
或者直接跳至某个方格，在另一条纸带上写入某些信息。
冯· 诺依曼被称为“计算机之父”，从世界上第一台计算机EN I AC 到现在的服务器、
笔记本、手机，基本上沿用了他的计算机结构设计理念。它根据电子元件双稳工作的
特点，从简化机器逻辑线路的角度出发，明确提出了二进制理论，采用0 与l 代表十
进制数值，提出计算机的基本工作原理是存储数据、处理数据、相关控制， 定义出新
44
®
仅供才｜商业用途或交流学习使用
第1 章计算机基础
代机器的雏形，即分成五个部分，运算器、控制器、存储器、输入设备和输出设备。
任何程序要想运行都需要加载到内部存储器（内存）中， 在内存中才有资格和运算器、
控制器进行对话， 执行逻辑运算和数据处理，计算机雏形如图1-3 3 所示。
数据流E’ 指令流＋ 控制流
.. …··嚣用…...·...
．它’ ? 输出设备＋
! Ii圈’ 噩噩•1------------J
图1-33 计算机的基本结构
1946 年， 按此设想的第一台计算机诞生， 从此自动化处理的场景越来越多。计
算机能够自动化处理的事情是需要以它可以理解的方式进行设计并录入的，这个过程
称为编码。计算机只能消化两种信息录入0 或l 。在机器语言编程的时代， 编码就
是这样枯燥的0 与l 的数据流录入。汇编语言以方便记忆的代号表示0 与1 的指令流，
在执行时， 再反向转成0 或l 的二进制流，这个过程称为编程。不再直接编写0 或l
的机器码指令， 而是以一定的方式组织成程序。至此， 可以阅读的代码开始出现。到
了20 世纪70 年代， 丹尼斯· 里奇设计的C 语言在BCPL 语言基础上诞生。UNIX 和
Linux 系统成功推动了C 语言的普及，至今C 语言仍然是TOP 的主流语言， 在操作系统、
底层编译、硬件设备上依然发挥着不可替代的价值。C 语言是高级语言时代中的低级
语言， 低级的意思是更加贴近于硬件底层。这类低级语言使编程者有机会深入了解底
层硬件， 后续的众多高级语言的编译器本身就是由C 语言编写的。
后来出现的一种高级语言，火了－个岛屿和一种饮料。爪哇岛和咖啡，即Java
语言。它的校验首字段即为十六进制的cafe babe ， 诉说着与咖啡的不解之缘， 这是第
个真正面向对象的语言。
据不完全统计， 当前编程语言超过1000 种， 优秀的程序员至少需要掌握3 门语言，
这有助于知晓不同语言的各自特性，更重要的是洞悉语言的共性和编程语言思想， 跨
越语言的抽象思维和架构掌控力。但是掌握不等于精通， 真正的大师， 需要醉心在某
种语言，不断研究、不断打磨、不断回炉，才能达到炉火纯青、登峰造极的境界。我
45
仅供非商业ITJj主或交流学习使用
码出高效： J ava 开发手册
们写的每一行代码都是站在巨人的肩膀上，使我们看得更远。虽然任何编程语言的结
构都是顺序、条件、循环，任何编程语言的本质都是输入与输出，但是0 与l 的世界
一定会因为编程而变得更加智能、更加美好。
® 46
φ
仅供｜非附；lkHJ 途或交流学习使用
第2 章面向对象
自树菩提，一‘门’一世界。”一切皆对象，万物有三问·我是谁？
我从哪里来？我到哪里去？
A萨\\
食
仅供非商业用途或交流学习使用
码出高效J ava 开发手册
本章开始讲解面向对象思想，并以Java 为载体讲述面向对象思想在具体编程语
言中的运用与实践。当前主流的编程语言有5 0 种左右，主要分为两大阵营面向对
象编程与面向过程编程。
面向对象编程（ 0均ect-Oriented Programming, OOP ）是划时代的编程思想变革，
推动了高级语言的快速发展和工业化进程。OOP 的抽象、封装、继承、多态的理念
使软件大规模化成为可能，有效地降低了软件开发成本、维护成本和复用成本。面向
对象编程思想完全不同于传统的面向过程编程思想，使大型软件的开发就像措积木
样隔离可控、高效简单， 是当今编程领域的一股势不可当的潮流。OOP 实践了软件
工程的三个主要目标可维护性、可重用性和可扩展性。
2.1 OOP 理念
面向过程让计算机有步骤地顺次做件事情， 是种过程化的叙事思维。但是在
大型软件开发过程中， 发现用面向过程语言开发，软件维护、软件复用存在着巨大的
困难， 代码开发变成了记流水账，久而久之就成为“面条” 代码， 模块之间互相辑合，
流程互相穿插， 往往牵发而动全身。面向对象提出一种计算机世界里解决复杂软件
工程的方法论，拆解问题复杂度，从人类思维角度提出解决问题的步骤和方案。
比如“ 开门”这个动作，面向过程是、pen (Door door)
作对象的参数传人方法的， 方法内定义开门的具体步骤实现。而在面向对象的世界里，
首先定义一个对象“ Door ” ， 然后抽象出门的属性和相关操作，属性包括门的尺寸、
颜色、开启方式（往外开还是往内开）、防盗功能等，门这个对象的操作必然包括
open （） 和close（） 两个必备的行为。面向过程的结构相对松散， 强调如何流程化地解决
问题；面向对象的思维更加内聚，强调高内聚、低藕合，先抽象模型，定义共性行为，
再解决实际问题。
但是， 编程语言仅是一个工具，就像练武之人的剑， 武功高者草木皆剑，武功差
者即使莫那剑在身也依然平庸。所以，能否将工具的价值发挥得淋漓尽致， 最终还是
取决于开发工程师本身。优秀的开发工程师用面向过程的语言也能把程序写得非常内
聚，可扩展性好， 具备定的复用性；而平庸程序员用面向对象语言一样能把程序写
得松散随意、毫无抽象与建模、模块间藕合严重、维护性差。
传统意义上， 面向对象有三大特性封装、继承、多态。本书明确将“ 抽象” 作
为面向对象的特性之，支持面向对象“四大特性” 的说法。抽象是程序员的核心素
®148
仅供非商业用途或交流学习使用
®
仅供非商业用途或交流学习佼用
第2 章面向对象
质之，体现出程序员对业务的建模能力，以及对架构的宏观掌控力。虽然面向过程
也需要进行定的抽象能力，但是相对来说，面向对象思维，以对象模型为核心， 丰
富模型的内涵，扩展模型的外延，通过模型的行为组合去共同解决某一类问题，抽象
能力显得尤为重要， 封装是一种对象功能内聚的表现形式， 使模块之间辑合度变低，
更具有维护性，继承使子类能够继承父类，获得父类的部分属性和行为，使模块更有
复用性； 多态使模块在复用性基础上更加有扩展性，使运行期更有想象空间。
抽象是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力
是后续的封装、继承、多态的基础， 是软件大厦的基石。在面向对象的思维中，抽象
分为归纳和演绎。前者是从具体到本质，从个性到共性，将一类对象的共同特征进行
归一化的逻辑思维过程a 后者则是从本质到具体，从共性到个性，逐步形象化的过程。
在归纳的过程中，需要抽象出对象的属性和行为的共性，难度大于演绎。演绎是在已
有问题解决方案的基础上，正确地找到合适的使用场景。演绎错误在使用集合时比较
常见，比如针对查多改少的业务场景， 使用链表是非常不合理的，底层框架技术选型
时如果有错误，则有可能导致技术架构完全不适应业务的快速发展。
Java 之父Gosling 设计的Object 类，是任何类的默认父类，是对万事万物的抽象，
是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。我们都知
道哲学的三大经典问题我是谁，我从哪里来，我到哪里去。在Object 类中，这些问
题都可以得到隐约的解答．
( I ）我是谁？ getClass（）说明本质上是谁，而toString（）是当前职位的名片。
( 2 ）我fl 吨里来？ Object（） 构造方法是生产对象的基本步骤， c lone（）是繁殖对
象的另一种方式。
( 3 ）我歪I；斗呈去叮finalize（） 是在对象销毁时触发的方法。
这里重点介绍clone（） 方法， 它分为浅拷贝、一般深拷贝和彻底深拷贝。浅拷贝
只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指
向的实际对象，而彻底深拷贝是在成功clone 个对象之后，此对象与母对象在任何
引用路径上都不存在共享的实例对象，但是引用路径递归越深，贝iJ 越接近NM 底层
对象， 且发现彻底深拷贝实现难度越大。介于浅拷贝和彻底深拷贝之间的都是般深
拷贝。归根结底， 慎用Object 的clone（） 方法来拷贝对象，因为对象的clone（） 方法默
认是浅拷贝，若想l实现深拷贝，贝！J 需要覆写clone（） 方法实现引用对象的深度遍历式
拷贝。
49
仅供才l0i1ii业用途或交流学习使用
仅供非商业用途或交流学习使用
码出高效· Java 开发手册
另外， 0怜ject 还映射了社会科学领域的一些问题：
( I ) tH 界是在因你而不同？ hashCode（） 和equ als（） 就是判断与其他元素是否相
同的组方法。
( 2 ）与他人枉何协调？ wait（）和notify（）是对象间通信与协作的一组方法。
随着时代的发展，当初的抽象模型部分不适用当下的技术潮流，比如finalize()
方法在JDK9 之后直接被标记为过时方法。而wait（）和notify（） 同步方式事实上已经
被同步信号、锁、阻塞集合等取代。
封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的
方式暴露哪些信息。抽象是要找到属性和行为的共性，属性是行为的基本生产资料，
具有定的敏感性，不能直接对外暴露；封装的主要任务是对属性、数据、部分内部
敏感行为实现隐藏。对属性的访问与修改必须通过定义的公共接口来进行，某些敏感
方法或者外部不需要感知的复杂逻辑处理， 般也会进行封装。封装使面向对象的世
界变得单纯，对象之间的关系变得简单，各人自扫门前雪，精合度变弱，有利于维护。
智能化的时代，对封装的要求越来越高，产品使用更加简单方便、轻松自然。就像天
猫精灵，唯一的接口就是语音输入，隐藏了指令内部的细节实现和相关数据，｛吏外部
用户无法访问，大大降低了使用成本，有效地保护内部数据安全。
设计模式七大原则之一的迪米特法则就是对于封装的具体要求，即A 模块使用
B 模块的某个接口行为，对B 模块中除此行为之外的其他信息知道得尽可能少。比如。
耳塞的插孔就是提供声音输出的行为接口，只需关心这个插孔是否有相应的耳塞标记，
是否是圆形的，有没有声音即可，至于内部CPU 如何运算音频信息，以及各个电窑
如何协同工作，根本不需要去关注，这使模块之间的协作只需忠于接口、忠于功能实
现即可。
封装这件事情是由俭入奢易，由奢入俭难。属性值的访问与修改需要使用相应的
ge出r/setter 方法，而不是直接对public 的属性进行读取和修改，可能有些程序员存在
疑问，既然通过这两个方法来读取和修改，那与直接对属性进行操作有何区别？如果
某一天，类的提供方想在修改属性的setter 方法上进行鉴权控制、日志记录，这是在
直接访问属性的情形中无法做到的。若是将已经公开的属性和行为直接暴力修改为
private ，贝IJ 依赖模块都会编译出错。所以，在不知道什么样的访问控制权限合适的时候，
优先推荐使用private 控制级别。
继承是面向对象编程技术的基石，允许创建具有逻辑等级结构的类体系1 形成
®150
仅供非商业用途或交流学习使用
®
第2 章面向对象
个继承树， 让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复
用或增强复用，父类的能力通过这种方式赋予子类。继承把枯燥的代码世界变得更有
层次感，更有扩展性，为多态打下语法基础。
人人都说继承是is-a 关系，那么如何衡量当前的继承关系是否满足is-a 关系呢？
判断标准即是否符合里氏代换原则（ Liskov Substitution Principle, LSP ）。LSP 是指
任何父类能够出现的地方，子类都能够出现。从字面上很难深入理解，先打个比方，
警察在枪战片中经常说放下武器，把手举起来！而对面的匪徒们有的使用手枪，有
的使用匕首， 这些都是武器的子类。父类出现的地方， 即“放下武器” ， 那么，放下
手枪，是对的，放下匕首，也是对的｜在实际代码环境中，如果父类引用直接使用子
类引用来代替，可以编译正确并执行，输出结果符合子类场景的预期，那么说明两个
类之间符合LSP 原则，可以使用继承关系。
继承的使用成本很低，一个关键字就可以使用别人的方法，似乎更加轻量简单。
想复用别人的代码，跳至脑海的第一反应是继承它，所以继承像抗生素一样窑易被滥
用， 我们传递的理念是谨慎使用继承， 认清继承滥用的危害性， 即方法污染和方法爆
炸。方法污染是指父类具备的行为， 通过继承传递给子类，子类并不具备执行此行为
的能力，比如鸟会飞，驼鸟继承鸟， 发现飞不了，这就是方法污染。子类继承父类，
则说明子类对象可以调用父类对象的－切行为。在这样的情况下，总不能在继承时，
添加注释说明哪几个父类方法不能在子类中执行，更不能覆写这些无法执行的父类方
法，抛出异常，以阻止别人的调用。方法爆炸是指继承树不断扩大，底层类拥有的方
法虽然都能够执行，但是由于方法众多，其中部分方法并非与当前类的功能定位相关，
很窑易在实际编程中产生选择困难症。比如某些综合功能的类，经过多次继承后达到
上百个方法， 造成了方法爆炸，因而带来使用不便和安全隐患。在实际故障中， 因为
方法爆炸，父类的某些方法签名和子类非常相似，在IDE 中，输人类名＋点之后，
在自动提示的极为相似的方法签名中选择错误，导致线上异常。综上所述， 提倡组合
优先原则来扩展类的能力，即优先采用组合或聚合的类关系来复用其他类的能力，而
不是继承。
多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个
方法产生不同的运行结果，使同一个行为具有不同的表现形式。多态是面向对象天空
中绚丽多彩的礼花，提升了对象的扩展能力和运行时的丰富想象力。我们来明确两个
非常容易混淆的概念、verride ” 和、verload ＇’ ， “ override ” 译成“ 覆写”， 是子
类实现接口， 或者继承父类时， 保持方法签名完全相同，实现不同的方法体， 是垂直
51
仅供才｜商业用途或交流学习使用
码出高效Java 开发手册
方向上行为的不同实现。、ve rload ”译成“重载”，方法名称是相同的，但是参数
类型或参数个数是不相同的，是水平方向上行为的不同实现。多态是指在编译层面无
法确定最终调用的方法体， 以覆写为基础来实现面向对象特性，在运行期由口创4 进
行动态绑定， 调用合适的覆写方法体来执行。重载是编译期确定方法调用， 属于静态
绑定，本质上重载的结果是完全不同的方法，所以本书认为多态专指覆写。自然界的
多态最典型例子就是碳家族，据说某化学家告诉他女朋友将在她的生日晚会上送她一
块碳，女朋友当然不高兴，可收到的却是5 克拉的钻石。钻石就是碳元素在不断进化
过程中的一种多态表现。严格意义上来说，多态并不是面向对象的一种特质，而是一
种由继承行为衍生而来的进化能力而已。
2.2 初识Java
面向对象编程思想把所有的有形或无形的事物都看作对象，并给对象赋予相应
的属性和行为， 建立对象之间的联系， 使程序员更加立体、形象地解决编程领域的问
题。面向对象语言的忠实代表是Java 语言， 它是一门富有生命力的语言， 在最受欢
迎的语言排行榜上， 多年位居第一。Java 语言是1995 年由Sun 公司首次发布的。次
年Java 开发工具包发布， 即Java Development Kit ， 简称JDKl.O ， 这是Java 发展的一
个重要里程碑，标志着Java 成为一门独立的成熟语言。随后， Sun 公司再接再厉发布
了Just - in - time 编译器， 简称JIT ， 不断进步的JIT 技术使Ja va 的执行速度接近甚至超
过其他高级语言。
JDK 随着时代不断往前发展。在众多版本中，最具划时代影响力的版本是
JDKS ，项目代号Tiger。Doug Lea 推出的并发包， 使Java 如虎添翼， 成为工业级语言，
在企业服务端得到极为广泛的应用。随着后续版本的陆续推出， Java 的发展与时俱进，
推出了diamond 语法、函数式、模块化、var 类型推断等新特性。最新的JDK 版本是
JDKl l 。
J阻（ Java Runtime Environment ） 即Jav a 运行环境， 包括NM 、核心类库、核
心配置工具等。其中口币-1: ( Java Virtual Machine ）即Java 虚拟机， 它是整个Java 体
系的底层支撑平台， 把源、文件编译成平台无关的字节码文件， 屏蔽了Java j原代码与
具体平台相关的信息， 所以Java 源代码不需要额外修改即可跨平台运行。川币4 不
仅支撑着Java 语言， 还包括Katlin 、Scala 、Python 等其他流行语言。其中Katlin 是
Jetbrains 开发的跨平台语言， 其语法简洁、类型安全，可以编译成字节码运行在JVM 上，
φ I 52
仅供才｜商业用途或交流学习佼用
第2 章面向对象
与Java 语言非常方便地进行混合编程。1999 年， Sun 公司发布公开版本的HotSpot,
它是当前主流的Java 虚拟机。2006 年，在JavaOne 大会上开源相关核心技术1 启动
OpenJDK 项目，逐步形成了活跃的OpenJDK 社区。在社区的带动下， Java 生态也随
之繁荣，包括AJDK 、S pring 、Hadoop 、Du bbo 、JStorm 、RocketMQ 等Java 相关解决
方案，极大地提升了Java 语言的生产效率。
Java 语言拥有跨平台、分布式、多线程、健壮性等主要特点，是当下比较主流的
高级编程语言。它的类库相当丰富、功能强大、简单易用，对开发者相当友好，不仅
吸收了C＋＋的优点，还摒弃了其难以掌控的多继承、指针等概念。Java 比较好地实
现了面向对象理论，允许开发工程师以优雅的思维方式处理复杂的编程场景。
2.3 类
2.3.1 类的定义
类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实
现关键字、父类或接口名称等组成。类的访问级别有pub lic 和无访问控制符，类型分
为class 、interface 、en um 。
Java 类主要由两部分组成成员和方法。在定义Java 类时，推荐首先定义变量，
然后定义方法。由于公有方法是类的调用者和维护者最关心的方法，因此最好首屏展
示，保护方法虽然只被子类关心，但也可能是模板设计模式下的核心方法， 因此重要
性仅次于公有方法，而私有方法对外部来说是一个黑盒实现，因此一般不需要被特别
关注B 最后是gette r/setter 方法，虽然它们也是公有方法，但是因为承载的信患价值较低，
一般不包含业务逻辑，所以所有ge阳r/setter 方法须放在类最后。
2.3.2 接口与抽象类
正如面向对象四大特性（抽象、封装、继承、多态）所述，定义类的过程就是抽
象和封装的过程，而接口与抽象类则是对实体类进行更高层次的抽象，仅定义公共行
为和特征。接口与抽象类的共同点是都不能被实例化，但可以定义引用变量指向实例
53 1
仅供＝II＝商业用途或交流学习佼用
码出高效· J ava 开发手册
对象。本节主要分析两者的不同之处， 首先从语法上进行区分，如表2 -1 所示。
表2一1 接口与抽象类的语法区别
语法维度抽象类接口
定义关键字abstract interface
子类继承或实现关键字extends implements
方法实现可以有不能有，但在JD K8 及之后，允许有d efault 实现
方法访问控制符无限制有限制，默认是publi c abstract 类型
属性访问控制符无限制有限制，默认是public static final 类型
静态方法可以有不能有
s tatic ｛｝ 静态代码块可以有不能有
本类型之间扩展单继承多继承
本类型之间扩展关键字extends extends
抽象类在被继承时体现的是is-a 关系，接口在被实现时体现的是can-do 关系。
与接口相比3 抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方
法、属性变量。如果一个抽象类只有一个抽象方法， 那么它就等同于一个接口。is- a
关系需要符合里氏代换原则， 例如Eagle is a Bird. Bird is an Object。can-do 关系要符
合接口隔离原则， 实现类要有能力去实现并执行接口中定义的行为，例如Plane can
fly. Bird can fly， 中应该把fly 定义成一个接口， 而不是把fly（） 放在某个抽象类中，再
由Plane 和Bird 利用i s- a 关系去继承此抽象类。因为严格意义上讲， 除fly 这个行为外，
在Plane 和Bird 之间很难找到其他共同特征。
抽象类是模板式设计，而接口是契约式设计。抽象类包含一组相对具体的特征，
性格偏内向， 比如某品牌特定型号的汽车， 底盘架构、控制电路、刹车系统等是抽象
出来的共同特征， 但根据动感型、舒适型、豪华型的区分， 内饰、车头灯、显示屏等
可以存在不同版本的实现。接口是开放的， 性格偏外向， 它就像一份合同， 定义了方
法名、参数、返回值，甚至抛出异常的类型。谁都可以来实现它， 但如果想实现它的
类就必须遵守这份接口约定合同，比如， 任何类型的车辆都必须实现如下接口
public interface VehicleSafe {
/**
吹自param initSpeed 刹车时的初始速度
女＠ pararn brakeTime 从initSpeed 开始刹车到停才行驶的时间， 单位是毫吵
I 54
仅供非商业用途或交流学习使用
第2 章面向对象
女e ，、uτ口’i in 工tsr 叫：1 吁非当飞丰们l HI ？当可~： i笃
double brake(int initSpeed, int brakeTime);
刹车是个开放式的强制行为规范，任何车辆都必须具有刹车的能力，要明确在
特定初速度的情况下，刹车时间多久，刹车距离多长。此规范对任何车辆都是强约束
的，这就是契约。
接口是顶级的“类”，虽然关键字是interface ，但是编译之后的字节码扩展名还
是.class。抽象类是二当家，接口位于顶层，而抽象类对各个接口进行了组合，然后
实现部分接口行为，其中Abs位actCollection 是最典型的抽象类
public abstract class AbstractCollection<E> implements Collection<E> {
」u1 ＋－》γ 气λ ；
/ ｛、叮L B 、t.l'"'' ,, ..一」、阳4 … P 工ι （）这气：F 、＇／；； A'J 「气：、乖叫日！气’丧r: ' t才＇~＇ ' ＇~ a 飞
public abstract int size();
／／马： JW Collection t~ 口的飞个7 法， I可~ -i·r Abs 卜rac1二1.,ol lect ion 的f 二是
I I t: I 『扛0 忖＇·.， ,, ' ~；，ξ 霎
I ~空、1 才5词 'I 于 ' V 一 i丰口 ino: () ·: ~·' 11
public boolean isEmpty() {
’ 1: ＇＇.［.巳1 咱ec 「l n 叩品
return size() == 0 ;
// 其（＼i~ Kt, ·t·牛和部’＋＃！？共一叮：呗…·
Java 语言中类的继承采用单继承形式，避免继承泛滥、菱形继承、循环继承，甚
至“四不像”实现类的出现。在口创4 中，一个类如果有多个直接父类，那么方法的
绑定机制会变得非常复杂。接口继承接口，关键字是extends ，而不是implements,
允许多重继承，是因为接口有契约式的行为约定，没有任何具体实现和属性，某个实
体类在实现多重继承后的接口时，只是说明气an do many things ，，。当纠结定义接口
还是抽象类时，优先推荐定义为接口，遵循接口隔离原则，按某个维度划分成多个接
口，然后再用抽象类去imp lements 某些接口，这样做可方便后续的扩展和重构。
2.3.3 内部类
在个.java 源文件中，只能定义一个类名与文件名完全致的公开类，使用
public class 关键字来修饰。但在面向对象语言中1 任何一个类都可以在内部定义另外
55 1
仅供非商业用途或交流学习使用
码出高效. Java 开发手册
一个类，前者为外部类，后者为内部类。内部类本身就是类的一个属性，与其他属性
定义方式一致。比如，属性字段private static String str ，由访问控制符、是否静态、类型、
变量名组成，而内部类private static class Inner ｛｝，也是按这样的顺序来定义的，类型
可以为class 、enum ，甚至是interface ，当然在内部类中定义接口是不推荐的。内部类
可以是静态和非静态的，它可以出现在属性定义、方法体和表达式中，甚至可以匿名
出现，具体分为如下四种。
·静态内部类，如static class StaticinnerC!ass {} ;
·成员内部类，如： private class InstancelnnerC!ass {} ;
·局部内部类，定义在方法或者表达式内部，
·匿名内部类，如： (new Thread(){} ).start（）。
如下是最精筒的4 种内部类定义方式·
public class OuterClass {
56
／／晓员内部类
private class InstancelnnerClass {}
／／静~内部建
static class StaticinnerClass {}
public static v。id main (String [) args) {
// 奇1-..Bf 名内部4!' 兮另ii -it 『... ＇弓2 - 1 所占气习。utei:Class$1 和OuterClass$2
(new Thread () {}) . start ();
(new Thread() {}).start();
／／芮4、方安内吾f 导． r 引＜t .~ ~ 2 1 听示的OuterClass$1MethodClassl 和
II OuterClass$1MethodClass2
class MethodClassl {}
class MethodClass2 {}
无论是什么类型的内部类，都会编译成一个独立的. class 文件，如图2- 1 所示。
仅供非商业用途或交流学习佼用
Name
inner
OuterClass.c lass
OuterClass$1.class
OuterClass$1 MethodC lass1.class
OuterClass$1Mett,odClass2.class
OuterClass$2.class
''"", OuterClass$1nstancelnnerClass.class
OuterClass$StaticlnnerClass.class
图2-1 外部类和内部类.class 文件
第2 章面向对象
，、
外部类与内部类之间使用$ 符号分隔， 匿名内部类使用数字进行编号， 而方法内
部类，在类名前还有一个编号来标识是哪个方法。匿名内部类和静态内部类是比较常
用的方式。在本书的示例代码中经常使用匿名类来启动线程，节约了若干行代码。而
静态内部类是最常用的内部表现形式， 外部可以使用OuterClass.StaticinnerClass 直接
访问， 类加载与外部类在同一个阶段进行， 在JDK j原码中， 定义包内可见静态内部
类的方式很常见，这样做的好处是
( I ）作用域不会扩散到包外。
( 2 ）可以通过”外部类． 内部类”的方式直接访问。
( 3 ）内部类可以访问外部类申的所有静态属性和方法。
static class Node<K, V> implements Map .Entry<K , V> {
final int hash ;
final K key ;
volatile V val ;
volatile Node<K , V> next ;
如上所示的源码是在ConcurrentHashMap 中定义的Node 静态内部类， 用于
表示个节点数据， 属于包内可见，包内其他集合要用到这个Node 肘， 直接使用
ConcurrentHashMap.Node。仅包内可见， 可以阻止外部程序随意使用此类来生成对
象， Node 的父类Entry 是Map 的静态内部类， 之所以可以被Node 成功继承， 是
因为两个外部类同属一个包。在JDK 源码中， 使用内部类封装某种属性和操作的
方式比较常见，比如应用类加载器Launcher 的AppClassLoader, ReentrantLock 中
继承自AbstractQueuedSynchronizer 的内部类Syn c, Array List 中的私有静态内部类
57 1
码出高效· J ava 开发手册
Sub Li st。内部类中还可以定义内部类，形成多层嵌套， 如在ThreadLocal 静态内部类
ThreadLocalM ap 申还定义个内部类Entry ，如图2 -2 所示。
图2-2 ThreadLocalMap 的内部类Entry
因为访问权限可见，所以在同一包内的Thread 可以直接使用如下方式声明自己
的属性
ThreadLocal . ThreadLocalMap threadLocals = null ;
ThreadLocal . ThreadLocalMap 工nheritableThreadLocals = null ;
2.3.4 访问权限控制
面向对象的核心思想之一就是封装， 只把有限的方法和成员公开给别人，这也是
迪米特法则的内在要求， 使外部调用方对方法体内的实现细节知道得尽可能少。如何
实现封装呢？需要使用某些关键字来限制类外部对类内属性和方法的随意访问， 这些
关键字就是访问权限控制符。在详细介绍访问权限之前， 我们明确个概念一一是否
可见，如下示例代码
package a ;
public class Vi sibleScope {
public void publicMethod() {}
pr。tected void protectedMethod () {}
void noneMethod () {}
private void privateMethod () {}
在package b 中， 图2-3 左侧对VisibleScope 类进行实例化， 通过~I 用变量， 仅
能看到publicMethod（） 方法， 我们称为publicMethod（） 方法是当前可见的1 使用同一
个类， 图2-3 右侧对VisibleScope 子类VisibleScopelnvoke 进行实例化， 通过引用变量，
可以看到两个方法， 新增了红色框内的protectedMethod（） 方法， 那么这两个方法是当
I 58
仅供非商业用途或交流学习使用
第2 章面向对象
前可见的，如果这个类也在package a 中， 那么noneMethod 是可见的，在任何情况下，
类外部实例化出来的对象均无法调用私有方法，比如本示例中的pri vateMethod 方法。
图2-3 方法可见范围示例代码
Java 中的访问权限包括四个等级，权限控制严格程度由低到高，如表2 -2 所示。
表2 2 访问权限控制及可见范围
访问权限控制符任何地方包外子类包内类内
public OK OK OK OK
protected :\() OK OK OK
无\{) \() OK OK
private 1\0 NO NO OK
• public ：可以修饰外部类、属性、方法，表示公开的、无限制的，是访问限
制最松的一级，被其修饰的类、属性和方法不仅可以被包内访问，还可以跨类、
跨包访问，甚至允许跨工程访问。
• protected : 只能修饰属性和方法，表示受保护的、有限制的，被其修饰的属
性和方法能被包内及包外子类访问。注意，即使并非继承关系， protected 属
性和方法在同一包内也是可见的。
·无·即无任何访问权限控制符，如示例中的noneMethod 方法，没有任何
修饰符。千万不要说成default ， 它并非访问权限控制符的关键字，另外，在
JDK8 接口中引入default 默认方法实现， 更加容易混淆两者释义。无访问权
限控制符仅对包内可见。虽然无访问权限控制符还可以修饰外部类，但是定
义外部类极少使用无控制符的方式，要么定义为内部类，功能内聚，要么定
义公开类，即public class ，包外也可以实例化。
59 1
仅供非商业用途或交流学习佼用
码出高效， Java 开发手册
• privat巳只能｛嗲饰属性、方法、内部类。表示
格的级’被其修饰的属性或方法只能在该类内部访问’子类、包内均不能
访问， 更不允许跨包访问。
由此可见，不同的访问权限控制符对应的可见范围不同。在定义类时，要慎重思
考该方法、属性、内部类的访问权限， 提倡严控访问范围。过于宽泛的访问范围不利
于模块间解藕及未来的代码维护。试想，在进行代码重构时， private 方法过旧， 我们
可以直接删除，且无后顾之忧。可是如果想删除一个public 的方法，是不是要谨慎又
谨慎地检查是否被调用。变量就像自己的小孩，要尽量控制在自己的视线范围内， 如
果作用域太大， 无限制地到处乱跑，就会担心其安危。因此，在定义类时，推荐访问
控制级别从严处理．
( I ）如果不允许外部直接通过new 创建对象， 构造方法必须是pnvale 。
( 2 ）工具类不允许有p u b l ic 或default 构造方法。
( 3 ）类非stat ic 成员变雪并且与子类共享， 必须是protected 。
( 4 ）类非stat i c 成员变量并且仅在本类使用， 必须是private 。
( 5 ）类stat i c 成员变量如果仅在东类使用， 必须是private o
( 6 ）若是stat i c 成员变量， 必须考虑是否为final o
( 7 ）类成员方法只供类内部调用， 必须是private 。
( 8 ）类成员方法只对继承类公开， 那么限制为protected 。
2.3.5 this 与super
对象实例化时，至少有条从本类出发抵达0均ect 的通路， 而打通这条路的两
个主要工兵就是thi s 和super ，逢山开路， 遇水搭桥。但是thi s 和super 往往是默默无
闻的，在很多情况下可以省略，比如．
·本类方法调用本类属性。
· 本类方法调用另一个本类方法。
· 子类构造方法隐含调用super（） 。
任何类在创建之初，都有个默认的空构造方法，它是s uper（） 的一条默认通路。
构造方法的参数列表决定了调用通路的选择；如果子类指定调用父类的某个构造方法，
super 就会不断往上溯源，如果没有指定，贝lj 默认调用super（）。如果父类没有提供默
I 60
仅供~ l ' n可业用途或交流学习使用
第2 章面向对象
认的构造方法， 子类在继承时就会编译错误，如图2 -4 所示。
图2-4 父类默认构造方法缺失
如果父类坚持不提供默认的无参构造方法， ． 必须在本类的无参构造方法中使用
super 方式调用父类的有参构造方法，如public Son() { super(l2 3 ）；｝。
一个实例变量可以通过this. 赋值另一个实例变量；一个实例方法可以通过this.
调用另一个实例方法，甚至一个构造方法都可以通过this. 调用另一个构造方法。如
果this 和super 指代构造方法， 贝lj 必须位于方法体的第一行。换句话说， 在一个构造
方法中， this 和super 只能出现一个， 且只能出现一次，否则在实例化对象时， 会因
子类调用到多个父类构造方法而造成混乱。
由于this 和sup巳r 都在实例化阶段调用，所以不能在静态方法和静态代码
块申使用this 和super 关键字。this 还可以指代当前对象，比如在同步代码块
synchronized( this) { ... ｝ 中， super 并不具备此能力。但super 也有自己的特异功能， 在
子类覆写父类方法时，可以使用super 调用父类同名的实例方法。最后总结－下this
和super 的异同点， 如图2-5 所示。
- 单独使用时，表示当前对象1 都是关键字，起擂代作用在子类覆写父类方法时，
2. 在构造方法中必须出现在第一行访问父类同名万法
图2 -5 thi s 和sup er 的异同点
61
仅供非商业用途或交流学习佼用
码出高效： Java 开发手册
2.3.6 类关系
关系是指事物之间存在单向或相互的作用力或者影响力的状态。类与类之间的关
系可分成两种·有关系与没关系， 这似乎是一旬非常正确的废话， 难点在于确定类与
类之间是否存在相互作用。证明类之间没关系是一个涉及业务、架构、模块边界的问
题，往往由于业务模型的抽象角度不同而不同，是一件非常棘手的事情。如果找到了
没有关系的点， 就可以如启丁解牛一样1 进行架构隔离、模块解相等工作。有关系的
情况下， 包括如下5 种类型，
·［ 继承］ extends (is-a） 。
·［ 实现］ implements (can - do） 。
·［ 组合］ 类是成员变量（contai ns-a） 。
·｛ 聚合｝ 类是成员变量（has-a） 。
·［ 依赖］ import 类（use-a） 。
继承和实现是比较容易理解的两种类关系。在架构设计中，要注意组合、聚合和
依赖这三者的区别。
组合在汉语中的含义是把若干个独立部分组成整体， 各个部分都有其独立的使用
价值和生命周期。而类关系中的组合是一种完全绑定的关系，所有成员共同完成一件
使命， 它们的生命周期是一样的。组合体现的是非常强的整体与部分的关系， 同生共
死， 部分不能在整体之间共享。
聚合是一种可以拆分的整体与部分的关系， 是非常松散的暂时组合， 部分可以被
拆出来给另一个整体。
依赖是除组合和聚合外的类与类之间的关系， 这个类只要import ， 那就是依赖关
系
在类图中，用空心的三角形表示继承， 用实心的菱形表示组合， 用空心的菱形表
示聚合， 这三者都是用实线连接的。用三角形来表示实现， 用一个箭头表示依赖， 与
前面的区别是这两者都是用虚线连接的。在画类图时， 菱开豆、箭头、三角形放在哪一
侧呢？在很多类图中， 这个处理是非常随意的。如果方向画反了， 那么类结构的认知
也就反了。有一个规律， 有形状的图形符号律放在权力强的这一侧，如表2-3 所示。
62
第 2 章 面向对象
仅供才｜商业用途或交流学习使用
表 2-3 类关系示例图
示例说明
小狗继承于动物，完全
符合里氏代换
小狗实现了狗叫的接口
行为
类关系 英文名 描 述 权力强侧 类图示例
父类方
的
可
之
类咀
子府
与
类系
父关
继承Generalization
接口与实现类之间
的关系： can-do
头只能是身体强组合的
一部分，两者完全不可分
具有相同的生命周期
小狗和狗绳之间是暂时
聚合关系，狗绳完全可
以复用在另一条小狗上
人l喂养小狗，小狗作为
参数传人，是一种依赖
关系
国
实现 Realization 接口方
整体方
比聚合更强的关系：
组合 Composil!on
组装方
暂时组装的关系：
聚合 Aggregation
一个类用到另一个
类： use-a
依赖 Dependency 被依赖方
随着业务和架构的发展，类与类的关系是会发生变化的， 必须用发展的眼光看待
类图。比如表2 -3 中的Body 和Head ，如果有一天，动物的脑袋可以随意地移植，那
么就从组合关系变成聚合关系了。狗与狗绳之间的约束，虽然很弱，但是如果防疫局
在狗绳上标记疫苗记录，那么它们之间的关系就会变强， 就变成组合关系了。在业务
重构过程中，往往会把原来强组合的关系拆开来，供其他模块调用，这就是类图的
种演变。
63
仅供非商业用途或交流学习佼用
码出高效， Java 开发手册
2.3.7 序列化
内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。将数
据对象转换为二进制流的过程称为对象的序列化（ Serialization ）。反之，将二进制流
恢复为数据对象的过程称为反序列化（ Deserialization ）。序列化需要保留充分的信息
以恢复数据对象，但是为了节约存储空间和网络带宽，序列化后的二进制流又要尽可
能小。序列化常见的使用场景是盯C 框架的数据传输。常见的序列化方式有三种I
( I )Java 原主序列化l Java 类通过实现S erializable 接口来实现该类对象的序列化，
这个接口非常特殊，没有任何方法，只起标识作用。Java 序列化保留了对象类的元数
据（如类、成员变量、继承类信息等），以及对象数据等，兼容性最好，但不支持跨
语言，而且性能一般。
实现S eri alizable 接口的类建议设置seria!VersionUID 字段值，如果不设置，那么
每次运行时，编译器会根据类的内部实现， 包括类名、接口名、方法和属性等来自
动生成seria!VersionUID。如果类的源代码有修改，那么重新编译后seria!VersionUID
的取值可能会发生变化。因此实现S erializable 接口的类一定要显式地定义
seria!Version UID 属性值。修改类时需要根据兼容性决定是否修改serialVersionUID 值
·如果是兼容升级，请不要修改seria!VersionUID 字段， 避免反序列化失败。
· 如果是不兼容升级，需要修改serialVersionUID 值，避免反序列化混乱。
使用Java 原生序列化需注意， Java 反序歹lj化时不会调用类的无参构造方法，而
是调用native 方法将成员变量赋值为对应类型的初始值。基于性能及兼容性考虑，不
推荐使用Java 原生序歹lj 化。
( 2 ) Hessian 序歹lj 化。Hessian 序列化是一种支持动态类型、跨语言、基于对象
传输的网络协议。Java 对象序列化的二进制流可以被其他语言（ 如C＋＋、Python ）反
序列化。Hessian 协议具有如下特性．
· 自描述序列化类型。不依赖外部描述文件或接口定义， 用一个字节表示常用
基础类型， 极大缩短二进制流。
· 语言无关，支持脚本语言。
· 协议简单，比Java 原生序列化高效。
相比Hessian 1.0, Hessian 2.0 中增加了压缩编码，其序列化二进制流大小是Java
序列化的50% ， 序列化耗时是Java 序列化的30% ，反序列化耗时是Java 反序列化的
20% 。
I 64
仅供非Rli 业用途DJt 交流学习佼月1
第2 章面向对象
Hessian 会把复杂对象所有属性存储在一个Ma p 申进行序列化。所以在父类、子
类存在同名成员变量的情况下， Hessian 序列化时，先序列化子类，然后序列化父类，
因此反序列化结果会导致子类同名成员变量被父类的值覆盖。
3 ) JSON , , fr JSON ( JavaScript O 同ect Notation ）是一种轻量级的数据交
换格式。JSON 序列化就是将数据对象转换为JSON 字符串。在序列化过程中抛弃了
类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式，
JSON 可读性比较好，方便调试。
序歹lj 化通常会通过网络传输对象， 而对象中往往有敏感数据，所以序列化常常
成为黑客的攻击点，攻击者巧妙地利用反序列化过程构造恶意代码，使得程序在反序
列化的过程中执行任意代码。Java 工程中广泛使用的A pache Commons Collections 、
Jackson 、fastjson 等都出现过反序列化漏洞。如何防范这种黑客攻击呢？有些对象的
敏感属性不需要进行序列化传输，可以加transient 关键字，避免把此属性信息转化为
序列化的二进制流。如果一定要传递对象的敏感属性，可以使用对称与非对称加密方
式独立传输，再使用某个方法把属性还原到对象中。应用开发者对序列化要有一定的
安全防范意识， 对传入数据的内容进行校验或权限控制，及时更新安全漏洞，避免受
到攻击。
2.4 方法
2.4.1 万法签名
方法签名包括方法名称和参数列表，是NM 标识方法的唯一索引， 不包括返回值，
更加不包括访问权限控制符、异常类型等。假如返回值可以是方法签名的一部分， 仅
从代码可读性角度来考虑，如下示例
long f () {
return lL ;
double f () {
return 二. Od ;
var a = f ();
65
仅供非商业用途或交流学习使用
仅供才｜商业用途或交流学习佼用
码出高效： Java 开发手册
那么类型推断的var 到底是接收1.0d 还是lL ？从静态阅读的角度，根本无从知
道它调用的是哪个方法。
2.4.2 参数
在高中数学中计算函数flx,y)=x2+2y - 3 ，将x=3, y=7 代入公式得到32+2 × 7 -
3=20 ，这里f飞XJ'） 的x 与y 就是形式参数， 简称形参，而3 与7 是实际参数，简称实
参。参数是自变量，而f(x,y） 函数， 即代码中的方法是因变量，是一个逻辑执行的结果。
参数又叫parameter ， 在代码注释中用＠param 表示参数类型。参数在方法中，属于方
法签名的一部分， 包括参数类型和参数个数，多个参数用逗号相隔， 在代码风格申，
约定每个逗号后必须要有个空格， 不管是形参， 还是实参。形参是在方法定义阶段，
而实参是在方法调用阶段， 先来看看实参传递给形参的过程
public class ParamPassing {
66
private static int intStatic ＝ 二Z ;
private static String stringStatic =
private static StringBuilder stringBuilderStat 工C
= new StringBuilder ( '
public static void main(String[] args ) {
method(intStatic);
method(stringStatic);
method(stringBuilderStatic, stringBuilderStatic);
（ 第1 处）
System . out . println(intStatic);
method() ;
System . out . println(intStatic) ;
I , . ，飞； J
（ 第2 在l: )
System. out.println(stringStatic);
System . out.println(stringBuilderStatic );
public static void method(int intStatic) {
intStatic ＝ 寸7 7;
仅供才｜商业用途或交流学习使用
仅供•I ＇ 附业月1途或交流学习伎月1
第2 章面向对象
public static void method() {
工ntStat 工C = 088 ;
public static void method(String stringStatic) {
stringStatic = ” · ,
public static void method(StringBuilder stringBuilderStaticl ,
StringBuilder stringBuilderStatic2) {
（第3 处）
stringBuilderStaticl . append ( ". ‘e ho >.. 1:r: ".t ” );
stringBuilderStatic2.append ( ” t l.0d. < - J }[ ) ;
stringBuilderStaticl = new StringBu 工lder(
stringBuilderStaticl.append （ ＂ ~ t f F ’ r •. i ” );
如果不了解形参与实参的传递方式，对于第l 处和第2 处是存在疑问的。第1 处，
通过有参方法执行i ntStatic = 777 ， 居然没有修改成功，而使用无参的method 方法却成
功地把静态变量intStatic 的值修改为888 。字节码实现如图二6 所示。
『J 吁，
78
HnF
』
MN
SHR HUnUHU
n
俨
T’
γl
TASE FDT4nR
.
吨
4
气，ι
写
d
| 1. SIPUSH 888
2. PUTSTATIC Pa 俨amPassi n g.intStati c :
3. RETURN
) 2U J
t
飞、
) ED ，
，
E
、
度12-6 字节码示意图
有参的A 方法字节码如图2-6 (a ）所示，参数是局部变量，拷贝静态变量的
777 ， 并存入虚拟机枪中的局部变量表的第一个小格子内。虽然在方法内部的intStatic
与静态变量同名，但是因为作用域就近原则，它是局部变量的参数，所有的操作与静
态变量是无关的。而无参的B 方法字节码如图2-6 ( b ）所示，先把本地赋值的888
压人虚拟机枪中的操作枝， 然后给静态变量intStatic 赋值。有两个参数的D 方法中，
我们再分析第3 处StringBuilder 的疑问
67
仅供－11，商业用途或交流学习佼用
仅供二ll'ilii业用途或交流学习使用
码出高效： J ava 开发手册
pub工ic static method(Ljava/lang/StringBuilder ; Ljava/lang/StringBuilder ;) V
LO
ALOAD 0
LDC ". method . f 工rst "
INVO阻VIRTU且a java/lang/StringBuilder.append (Ljava/lang/Str 工ng; )
Ljava/ l ang/StringBuilder ;
POP
Ll
ALOAD 1
LDC ” method . second "
工NVOKEVIRTUAL java/lang/StringBuilder . append (Lj a飞ra/lang/String ; )
Ljava/lang/StringBuilder ;
POP
L2
NEW java/lang/Str 工ngBuilder
DUP
LDC ” new stringBuilder”
工NVOKESPECIAL java/lang/StringBuilder.<init> (Ljava/lang/String ; )V
ASTORE 0
L3
ALOAD 0
LDC ” new method ’ s append”
工NVOKEVIRTU.且a java/lang/StringBuilder.append (Ljava/lang/String ; )
Ljava/lang/Str 工ngBuilder ;
POP
RETURN
注意上述字节码中的两个ALOAD 0 ，是把静态变量的引用赋值给虚拟机枝的桔
帧中的局部变量表， 然后ALOAD 操作是把两个对象引用变量压入操作枝的枝I页。注
意， 这两个引用都指向了静态引用变量指向的new StringBuilder("old stringBuilder”）对
象在method(stringB uilderStatic, stringBuilderStatic）的执行结果后的值，其中红绿字符
串分别是两次append 的结果
old stringBuilder.method. first- method.second-
在D 方法中， new 出来个新的StringBuilder 对象，赋值给stringBuilderStatic 1 。
注意， 这是一个新的局部引用变量， 使用AS TORE 命令对局部变量表的第一个位
置的引用变量值进行了覆盖， 然后再重新进行ALOAD 到操作枝顶，所以后续对于
stringBuilderStatic 1 的append 操作， 与类的静态引用变量stringBuilderStatic 没有任何
关系。
综上所述，无论是对于基本数据类型，还是引用变量， Java 中的参数传递都是值
168
仅供二ll'ilii业用途或交流学习使用
第2 章面向对象
复制的传递过程。对于引用变量，复制指向对象的首地址，双方都可以通过自己的引
用变量修改指向对象的相关属性。
再来介绍一种特殊的参数一一可变参数。它是在JDK5 版本中引人的，主要为了
解决当时的反射机制和printf 方法问题，适用于不确定参数个数的场景。可变参数通
过“参数类型． ． ．”的方式定义，如PrintStream 类中printf 方法使用了可变参数
public PrintStream printf(String format , Object ... args) {
return format ( format , args) ;
／／词吁； printf 方法尔对
System . out . printf （ ” 宅d” ， n); （第1 处）
System . out . printf （ ” 毛d ' S” , n , ” something" ) ; （第2 处）
如上示例代码，虽然第1 处调用传人了两个参数，第2 处调用传入了三个参数，
但它们调用的都是printf(String format, Object ... args ）方法。看上去可变参数使方法调
用更简单，省去了手工创建数组的麻烦。有人说可变参数是语法糖，个人觉得是恶魔
果实。如果在实际开发过程中使用不当，会严重影响代码的可读性和可维护性。因此，
使用时要谨慎小心，尽量不要使用可变参数编程。如果一定要使用，贝lj 只有相同参数
类型，相同业务含义的参数才可以3 并且一个方法中只能有一个可变参数， 且这个可
变参数必须是该方法的最后一个参数。此外，建议不要使用。同ect 作为可变参数，如
下警示代码，
public static void listUsers(Object ... args) {
System.out.println(args . length);
public static void main(String[) args) {
/ ，人下代♂绘出结果吁： 3
listUsers ( 1 , 2 , 3 );
／以下作＠示出结果句： 1
listUsers(new int [] { l , 2 , 3 }) ;
I I ~·， 下代码奉告ti' 结果为： L （第1 处）
listUsers ( 3 , new String[) {” 1 ” , ” 2 ” });
! t . ＇下f七4 绘出结果勺： 3 （第2 处）
listUsers (new Integer [) { 1 , 2 , 3 } ) ;
/ 儿不代号输出唁柔勺： 2 （第3 处）
listUsers( 3 , new Integer[] { l , 2 , 3 });
通过上面的例子可以看到，使用Object 作为可变参数时过于灵活，类型转换场
景不好预判，比如第2 处和第3 处申Integer ［］ 可以转型为Object ［］， 也可以作为一个
69
仅供~I＇商业用途或交流学习佼用
码出高效Java 开发手册
Object 对象，所以导致第2 处输出结果为3 ，第3 处输出结果为2。而int［］ 只能被当
作一个单纯的Object 对象。同时0均ect 又很容易破坏“可变参数具备相同类型，相
同业务含义”这个大前提，如上例中第1 处的整型和字符串数组类型混用，因此要避
免使用Object 作为可变参数。
以上是参数定义的相关内容，那么如何正确地使用参数呢？方法定义方并不能保
证调用方会按照预期传入参数，因此在方法体中应该对传入的参数保持理性的不信任。
方法的第步骤并不是功能实现，而应该是参数预处理。参数预处理包括两种
( I )<_.., 1: t' 虽然“人参保护”被提及的频率和认知度远低于参数校验，但
是其重要性却不能被忽略。人参保护实质上是对服务提供方的保护，常见于批量接口。
虽然批量接口能处理批数据，但其处理能力并不是无限的，因此需要对入参的数据
量进行判断和控制，如果超出处理能力，可以直接返回错误给客户端。某业务曾发生
过一个严重故障，就是由一个用户批量查询的接口导致的。虽然在API 文档中约定了
每次最多支持查询的用户ID 个数，但在接口实现中没有做任何入参保护，导致当调
用方传人万级的用户ID 集合查询信息时， 服务器内存被塞满， 再无任何处理能力。
( 2 ） 参~.'T',:;!( 参数作为方法间交互和传递信患的媒介， 其重要性不言而喻。
基于防御式编程理念，在方法内， 无论是对方法调用方传入参数的理性不信任，还是
对参数有效值的检测都是非常有必要的。但是，由于方法间交互是非常频繁的， 如果
所有方法都进行参数校验，就会导致重复代码及不必要的检查影响代码性能。综合两
个方面考虑， 汇总需要进行参数校验和无须处理的场景。
I 70
需要进行参数校验的场景，
·调用频度低的方法。
·执行时间开销很大的方法。此情形中， 参数校验时间几乎可以忽略不计， 但
如果因为参数错误导致中间执行回退或者错误，贝lj 得不偿失。
·需要极高稳定性和可用性的方法。
· 对外提供的开放接口。
· 敏感权限入口。
不需要进行参数校验的场景
· 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。
·底层调用频度较高的方法。参数错误不太可能到底层才会暴露问题。一般
仅供非商业用途或交流学习使用
第2 章面向对象
DAO 层与Serv ice 层都在同个应用中，部署在同一台服务器中，所以可以
省略DAO 的参数校验。
·声明成private 只会被自己代码调用的方法。如果能够确定调用方法的代码传
入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。
2.4.3 构造方法
构造方法（ Constructor ）是方法名与类名相同的特殊方法，在新建对象时调用，
可以通过不同的构造方法实现不同方式的对象初始化， 它有如下特征，
( I ）构造1J 沽名称必示与吴兵相同。
( 2 ）均圭方江主二没有返国类在二呐，即使是void tli，－怀能有z 它返回对象的地址，
并赋值给引用变量。
( 3 ）枯l z 丁、－t: 吉~ ~t~ .. ,’ .(..' T 市被ff 弓. -.T 'i「妒土I'" 调用途径有三种
一是通过new 关键字，二是在子类的构造方法中通过super 调用父类的构造方法，三
是通过反射方式获取并使用。
( 4 ）吴王飞jj fo~ ＋「J 认－~ .＿送去均王元、去但是如果显式定义了有参构造方法，
则此无参构造方法就会被覆盖，如果依然想拥有，就需要进行显式定义。
( 5 ）均生于1 、主以和平外部无法使用私有构造方法创建对象。
在接口中不能定义构造方法，在抽象类中可以定义。在枚举类中，构造方法是特
殊的存在， 它可以定义， 但不能力日public 修饰， 因为它默认是private 的，是绝对的单例，
不允许外部以创建对象的方式生成枚举对象。
一个类可以有多个参数不同的构造方法，称为构造方法的重载。为了方便阅读，
当一个类有多个构造方法时， 这些方法应该被放置在一起。同理， 类中的其他同名方
法也应该遵循这个规则。
单一职责， 对于构造方法同样适用，构造方法的使命就是在构造对象时进行传参
操作，所以不应该在构造方法中引入业务逻辑。如果在一个对象生产中，需要完成初
始化上下游对象、分配内存、执行静态方法、赋值旬柄等繁重的工作， 其中某个步骤
出错，导致没有完成对象初始化，再将希望寄托于业务逻辑部分来处理异常就是一件
不受控制的事情了。故推荐将初始化业务逻辑放在某个方法中，比如init（）， 当对象
确认完成所有初始化工作之后，再显式调用。
类中的static { ... ｝代码被称为类的静态代码块，在类初始化时执行，优先级很高。
71
仅供才l0Ji\j业用途或交流学习使用
码出高效· Java 开发手册
下面看一下父子类静态代码块和构造方法的执行顺序·
class Son extends Parent {
static { System . out . println （ ” Son 静怒代码炉” ）；｝
Son () { System . out . println ( "Son t与生方；去” ）； }
public static void main(String[] args) {
new Son();
new Son();
class Parent {
static { System.out . println ( ” Parent ~争态代码＇ it ” ）； }
public Parent() { System.out.println( " Parent 构金矿法” ） ； ｝
执行结果如下I
Pa re nt 静态代码块
Son 静态代码块
P a r ent 构造方法
So n 构造方法
P a rent 构造方法
Son 构造方法
从以上示例可看出，在创建类对象时，会先执行父类和子类的静态代码块， 然后
再执行父类和子类的构造方法。并不是执行完父类的静态代码块和构造方法后，再去
执行子类。静态代码块只运行一次，在第二次对象实例化时，不会运行。
2.4.4 类内方法
在面向过程的语言中，几乎所有的方法都是全局静态方法，在引人面向对象理念
之后， 某些方法才归属于具体对象，即类内方法。构造方法无论是有形、无形、私有、
公有，在一个类中是必然存在的。除构造方法外，类中还可以有三类方法实例方法、
静态方法、静态代码块。
I. 实例方法
又称为非静态方法。实例方法比较简单，它必须依附于某个实际对象，并可以通
过引用变量调用其方法。类内部各个实例方法之间可以相互调用，也可以直接读写类
内变量，但是不包含this。当.c lass 字节码文件加载之后，实例方法并不会被分配方
法人口地址， 只有在对象创建之后才会被分配。实例方法可以调用静态变量和静态方
172
仅供＃商业用途或交流学习使用
第2 章面向对象
法，当从外部创建对象后，应尽量使用“类名．静态方法”来调用，而不是对象名，
一来为编译器减负，二来提升代码可读性。
2. 静杏元1云
又称为类方法。当类力日载后，即分配了相应的内存空间，由于生命周期的限制，
使用静态方法需要注意两点
( 1 ）静态为法甲平能使用实切！成员交量和实例方法。
( 2 ）静态为法不能使用super 和th is 关键字， 这两个关键字捐代的都是需要被
创建出来的对象。
通常静态方法用于定义工具类的方法等，静态方法如果使用了可修改的对象，那
么在并发时会存在线程安全问题。所以，工具类的静态方法与单例通常是相伴而生的。
3. 静态代码块
在代码的执行方法体中，非静态代码块和静态代码块比较特殊。非静态代码块又
称为局部代码块，是极不推荐的处理方式，本节不再展开。而静态代码块在类加载的
时候就被调用，并且只执行一次。静态代码块是先于构造方法执行的特殊代码块。静
态代码块不能存在于任何方法体内，包括类静态方法和属性变量。观察如下示例代码·
public class StaticCode {
II prior•：／.：须定义在last 前边、否则编译出错： illegal forward reference
static String prior = ” done " ;
II fid:.ii!] ，有f （）的生采． -1司运Jt: 符为true . 执行g （），最后赋值成功
static String last = f() ? g() : prior;
public static boolean f() {
return true;
public static String g() {
return ” hello world" ;
static {
／／命态代码块可以访问传态变ilf 和静态方法
System _out-println(last);
g ();
仅供二ll'iili业用途或交流学习使用
73
码出高效· J ava 开发手册
在上述代码中，由于last 依赖了变量prior ，所以两者之间存在先后关系，而静
态方法与静态变量之间没有先后关系。在实际应用中例如容器初始化时，可以使用静
态代码块实现类加载判断、属性初始化、环境配置等。很多容器框架会在单例对象初
始化成功后调用默认in it（） 方法，完成例如RPC 注册中心服务器判断、应用通用底层
数据初始化等工作。某框架的初始化代码如下所示
public class RpcProv 工derBea 口｛
public void init() throws RpcRuntimeException {
this ． 工nitReg 工ster () ;
this . publish ();
／／其他逻辑
public void initRegister() {
if ( this . i 口工ted . compareAndSet ( false , true )) {
this . checkConfig() ;
this . metadata.init() ;
public void p ublish( ) {
／／将本地服务信息、发送到注册中心
2.4.5 getter 与setter
在实例方法中有类特殊的方法，即ge忧er 与se忧er 方法，它们一般不包含任何
业务逻辑， 仅仅是为类成员属性提供读取和修改的方法， 这样设计有两点好处I
（ ！ ）满足面向对象语言封装的特’生。尽可能将类中的属性定义为private ，针对
属性值的访问与修改需要使用相应的getter 与se位er 方法， 而不是直接对public 的属
性进行读取和修改。
( 2 ）有利于统一控制。虽然直接对属性进行读取、修改的方式和使用相应的
getter 与se忧er 方法在效果上是一样的， 但是前者难以应对业务的变化。例如， 业务
要求对某个属性值的修改要增加统一的权限控制， 如果有setter 作为统一的属性修改
方法则更窑易实现， 这种情况在些使用反射的框架中作用尤其明显。
因此， 在类成员属性需要被外部访问的类中， ge忧er 与setter 方法是必备的。除
特殊情况需要增加业务逻辑外， 它们仅仅是对成员属性的访问和修改操作， 其承载的
信息价值比较低，所以， 建议在类定义中， 类内方法定义Jll页序依次是公有方法或保
74
第2 章面向对象
护方法＞私有方法＞ getter/setter 方法。
最典型的getter 与setter 方法使用是在POJO ( Plain Ordinary Java Object ， 简单的
Java 对象）类中。在本书中， POJO 专指只包含ge忧町、setter 、toString 方法的简单类，
常见的POJO 类包括DO(Domain Object） 、BO(Business O均ect） 、DTO(Data Transfer
Object） 、VO(View O同ect）、A O(Application O均ect） 。POJO 作为数据载休，通常用于
数据传输，不应该包含任何业务逻辑。因此，在POJO 类中， getter 与setter 不但是重
要的组成部分， 更是与外界进行信息交换的桥梁。getter 与se tter 方法定义参考示例
如下
public class T 工cketDO {
private Long id ;
private String destination ;
守Pt'" ‘… ζ fr Jr-''- ?l 7 ’”’浅’护ft:.. F 五I 71 'k 牛二号将
public Long getid() {
return id;
public String getDestination ( ) {
return destination ;
＇~ ·:z t 1 t L 丰s . 民页飞得7'[ ·； ， 尽f'· 干：峙’ 1口~各主
public void setid (Long id) {
this .id = id;
public void setDestination(String destination ) {
this . destination = destinat 工on ;
g巳忧er 与setter 方法的定义非常简单， 正因如此， 工程师们会放松对它们的警惕，
导致在实际应用中因为不当操作出现问题。下面来罗列那些易出错的ge忧er 与setter
方法定义方式
( I getter :sdlLr ι 、于－ ＂立了南问题出现时， 程序员的惯性思维会忽略
ge出r/setter 方法的嫌疑， 这会增加排查问题的难度。如下示例代码， 在getData（） 中
增加了逻辑判断， 修改了原属性值， 如出现属性值不一致的情况， 这里可能会是程序
员最后被排查到的地方。
public Int eger getData () {
75
码出高效： Java 开发手册
if (condition) {
return this .data + 100 ;
} else {
return this .data - 100 ;
( 2 ）同时定义isXxx（）叩getXxx （）。在类定义中，两者同时存在会在iBATIS 、
JSON 序列化等场景下引起冲突。比如， iBATIS 通过反射机制解析加载属性的getter
方法时，首先会获取对象所有的方法，然后筛选出以get 和is 开头的方法，并存储到
类型为HashMap 的getMethods 变量中。其中key 为属性名称， value 为ge出r 方法。
因此isXxx （）和getXxx（）方法只能保留一个，哪个方法被后存储到getMethods 变量中，
就会保留哪个方法，具有一定的随机性。所以当两者定义不同时，会导致误用，进而
产生问题。
( 3 ）相同的属哇名窑易得芬歧义。在编程过程中，应该尽量避免在子父类的成
员变量之间、不同代码块的局部变量之间采用完全相同的命名。虽然这样定义是合法
的，但是要避免。这样使用非常容易引起混淆，在使用参数时，难以明确属性的作用
域，最终难以分清查lj 底是父类的属性还是子类的属性。扩展开来，对于非setter/getter
的参数名称也要避免与成员变量名称相同。
public class ConfusingName [
public int al 工baba;
／／反！到． 非setter/getter 方法的参数名称． 不允许与卒~.~员是量同名
public void get(String alibaba) {
if ( true ) {
final int taobao = 15;
for (int i = O; i < 10 ; i++) {
／／在同一方法体中， 不允许与其他代码块中的taobao 命名相同
final int taobao = 15 ;
class Son extends ConfusingName {
76
／／反句r］ ： 不允许与飞类约决员1: L 名称中自同
public int alibaba;
第2 重面向对象
2.4.6 同步与异步
同步调用是因lj 性调用，是阻塞式操作，必须等待调用方法体执行结束。而异步调
用是柔性调用，是非阻塞式操作，在执行过程中，如调用其他方法，自己可以继续执
行而不被阻塞等待方法调用完毕。异步调用通常用在某些耗时长的操作上，这个耗时
方法的返回结果，可以使用某种机制反向通知，或者再启动一个线程轮询。反向通知
方式需要异步系统和各个调用它的系统进行辑合，而轮询对于没有执行完的任务会不
断地请求，从而加大执行机器的压力。
异步处理的任务是非时间敏感的。比如，在连接池中，异步任务会定期回收空闲
线程。举个现实中的例子，在代码管理平台中，提交代码的操作是同步调用，需要实
时返回给用户结果。但是当前库的代码相关活动记录不是时间敏感的，在提交代码时，
发送一个消息到后台的缓存队列中，后台服务器定时消费这些消息即可。
某些框架提供了丰富的异步处理方式，或者是把同步任务拆解成多个异步任务等。
2.4.7 覆写
多态中的overr i de ，本书翻译成覆写。如果翻译成重写，那么与重构意思过于
接近；如果翻译成覆盖，那么少了“写”这个核心动词。如果父类定义的方法达不到
子类的期望，那么子类可以重新实现方法覆盖父类的实现。因为有些子类是延迟加载
的，甚至是网络加载的，所以最终的实现需要在运行期判断，这就是所谓的动态绑定。
动态绑定是多态性得以实现的重要因素，元空间有一个方法表保存着每个可以实例化
类的方法信息， 只矶4 可以通过方法表快速地激活实例方法。如果某个类覆写了父类
的某个方法，贝lj 方法表中的方法指向引用会指向子类的实现处。代码通常是用这样的
方式来调用子类的方法，通常这也被称作向上转型，
Father father= new Son();
II Son 得写了此，？法
father . doSomething() ;
向上转型时，通过父类引用执行子类方法时需要注意以下两点·
l I 1 无忍曰同f』于天甲忖仓‘ llJ .x、多毫不身不存在口、l刀店。
' 2 ＼百以1用电羽rz 类由fil't? 7 ；，；－类的芦子，这旦神多态实现。
想成功地覆写父类方法，需要满足以下4 个条件
( I I 访l 司叹限不能支’ I 访问控制权限变小意昧着在调用时父类的可见方法无
77
码出高效Java 开发手册
法被子类多态执行，比如父类中方法是用public 修饰的，子类覆写时变成pri vate 。设
想如果编译器为多态开了后门， 让在父类定义申可见的方法随着父类调用链路下来，
执行了子类更小权限的方法，贝IJ 破坏了封装。如下代码所示，在实际编码中不允许将
方法访问权限缩小1
class Father {
public void method() {
System . out.println （ ” 「ather ’ s method " );
class So口extends Father {
I I . ~p ~.丁允.＇； . ＂力. f＂：气布萨严格的f:t－竹n
自override
private void method() {
System.out.println （ ” 〉川’ L m the· " );
( 2 ） 、百［］斗宵节，..，，，， ~. I ~~ "T" - 'j '', 叶，自h
名的一部分’但是在覆写时， 父类的方法表指向了子类实现方法，编译器会检查返
回值是否向上兼容。注意，这里的向上转型必须是严格的继承关系，数据类型基本
不存在通过继承向上转型的问题。比如int 与Integer 是非兼容返回类型，不会自动装
箱。再比如，如果子类方法返回int ，而父类方法返回lon g ，虽然数据表示范围更大，
但是它们之间没有继承关系。返回类型是Object 的方法，能够兼容任何对象，包括
class 、en um 、interface 等类型。
3 号雪什苓司;; .. ' a 、ι4 臣也异常分为c hecked 和unchecked 两种
类型。如果父类抛出一个checked 异常，贝lj 子类只能抛出此异常或此异常的子类。而
unchecked 异常不用显式地向上抛出， 所以没有任何兼容问题。
( 4 ）歹去:;z 参生丰吁J ｝ 寸含1f' T 市地可c 为了使编译器准确地判断是否是
覆写行为，所有的覆写方法必须加＠Override 注解。此时编译器会自动检查覆写方
法签名是否一致，避免了覆写时因写错方法名或方法参数而导致覆写失败。例如，
AbstractCollection 的clear 方法，当覆写此方法时，写成clear ，注意是数字的l ， 这
会导致定义了两个不同的方法。此外，＠ Override 注解还可以避免因权限控制可见范
围导致的覆写失败。如图2 -7 所示， Father 和Son 属于不同的包，它们的method（） 方
法无权限控制符修饰，是默认仅包内可见的。F ather 的method 的方法在Son 中是不
78
第2 章面向对象
可见的。所以， Son 中定义的method 方法是个“新方法”，如果加上＠ O verr ide,
则会提示， Me thod does not override method from its superclass 。
图2-7 Father 和Son 的覆写关系
综上所述，方法的覆写可以总结成容易记忆的口诀“ 一大两小两同”。
·一大子类的方法访问权限控制符只能相同或变大。
· 两小，抛出异常和返回值只能变小， 能够转型成父类对象。子类的返回值、
抛出异常类型必须与父类的返回值、抛出异常类型存在继承关系。
· 两同i 方法名和参数必须完全相同。
根据这个原则， 再看一个编译和运行都正确的覆写示例代码，
class Father {
protected Number doSomething( int a , Integer b , Object c) throws
SQLException {
System . out.println （ ’＇~ 'th r ’ dodonPt. · n< ) ;
return new Integer( - );
class Son extends Father {
..喝
女1. 仪底打’ -fc. ;b protρct c:d ;1! public （一大）
* 2 ，过UJff' 'c 戈主自•，， ~.t ..,l :r ii~. j 主（两小）
女3 . .lfl ttJ 异常ιSQLExc ept io.'1 飞j
贺4 . 斗’ J ~ ，／；否. ＋；丰γ ( j何同）
* c .歹~x z 专＇J i、古. 'L 旷
• t .. ~. ！＇ 句i @uτ .， y i.J.
自Override
79
码出高效： Java 开发手册
public Integer doSomething( i n t a , Intege r b, Object c) throws
SQLClientinfoException {
i f (a == 0 ) {
throw new SQLClientinfoException();
return new Integer ( 17 );
覆写只能针对非静态、非final、非构造方法。由于静态方法属于类，如果父类
和子类存在同名静态方法，那么两者都可以被正常调用。如果方法有final 修饰，则
表示此方法不可被覆写。
如果想在子类覆写的方法中调用父类方法， 贝lj可以使用super 关键字。在上述示
例代码中，在S on 的doS omething 方法体里可以使用super. doSomething(a丸c）调用父
类方法。如果与此同时在父类方法的代码中写一句this.doSomething（）， 会得出什么样
的运行结果呢？
public class Father {
protected void doSomething() {
Syst.em . out .println ( ” Father 『s doSomething ” );
this .doSomething();
public static void main(String[] args) {
Father father= new Son();
father . doSomething() ;
class Son extends Father {
@Overr 工de
public void doSometh 工ng( ) {
System . out . println ( ” Son ’ s doSomething ” );
super .doSomething();
在经过了系列的父子方法循环调用后， 阿M 崩溃了，发生了
StackOverflow Error ，如图2- 8 所示。
J 80
Fathe r ' s doS- t hin9
Sen ’筝doS 011Cthin9
Fothc r's d0Sooc t hln9
s。n’， doS帽e thin9
阳t her 's doSOllCt hl呵
第2 章面向对象
”事J•vo . \an9 . in引＂＂国nt ASSERn 刷FA!ι四”·．…~error。utstaod 扫9" wi协oessa9e tr•nsfono oethod 臼ll 阳tled Bt JPL!S 句ent.c lin°' 8<4
Exception tn thcead ＂旧旷a Java. la呵· ”E曰”’叮ill.lii"l•••n •
罔2 - 8 瞿写产生的Stac kOverfl ow Erro r
2.5 重载
在同一个类中， 如果多个方法有相同的名字、不同的参数，即称为重载， 比如一
个类中有多个构造方法。S trin g 类中的valueOf 也是比较著名的重载案例， 它有9 个
方法，可以将输入的基本数据类型、数组、Object 等转化成为字符串。在编译器的眼里，
方法名称＋参数类型＋参数个数，组成一个唯一键，称为方法签名， 只币4 通过这个
唯一键决定调用哪种重载的方法。注意， 方法返回值并非是这个组合体中的一员，所
以在使用重载机制时，不能有两个方法名称完全相同，参数类型和个数也相同， 但是
返回类型不同的方法。如下示例代码，
public class SameMethodSignature {
public void methodForOverload () {}
, I γ♀ L手刘J告＂＇~ _;,1 ’巧J 矿L 扩， ！＇ ?. 3~ －部子
public final int method F orOverload () {
return ;
"i:S ..」晏1』i
- '.' J丁一部分
private void methodForOverload() {}
／／终i~ tt! 错：争夺＇ j· if' ··.吃手，」宁主名的一部1t
public static void meth odForOverloa d () {}
／／结手出f苦fiPal ;’Y lf，俨·fl, 』、ζ 宇法二字：！ J 一吉；＂ ?private
final void methodForOverload () {}
重载似乎是比较容易理解和掌握的编程技能， 有时仅凭肉眼判断就能知道应调用
哪种重载方法，特别是如下代码所示的第种方法和第二种方法。前者是无参的， 后
者参数是int param ， 但是后边的三种方法， 只是参数类型不同罢了。这时，如果调用
methodF or0verload(7 ）， 猜猜，到底调用的是谁呢？
81
码出高效Java 开发手册
public class OverloadMethods {
public void overloaclMethod () {
System . out . println （ ” 王ι 肯飞” ） ；
public void methodForOverload(int param) {
System . out.println （ ” 苓＂ ＂；气扛雯型inι 的Ji ，＿ ” ） ;
其i .
F‘ ·
public v。id methodForOverl o ad(Integer param) {
System . out . println （ ” 参＇h ·7 包要走近j Integ r. f"J 年凉” ）；
public void methodForOverload (Integer . . . pa ram) {
System . out . println(
public void methodForOverload(Object param) {
System . out.println(
先看这五种方法对应的字节签名有何异同点。
public overloaclMethod () V
'1 t_岳， •l 冉r
public methodForOverload(I)V
L :;t 唱、‘ 飞、a （第1 在l:l
public methodForOverload(Ljava/lang/Integer ; )V
足？ （第2 绞）
public varargs methodForOverload ( [ L] ava/lang/Integer ; ] V
l ＇，，拿
public methodForOverload(Ljava/lang/Object ;) V
82
第2 章面向对象
第l 处与第2 处的区别是后者加了varargs 标识，即可变参数，参数个数可以
是0 或多个，也就是说，它和第1 、2, 3 个方法都是有可能争抢地盘的。首先，如
果调用methodForOverload （） ，假如在无参方法缺席的情况下，也会调用至lj 可变参
数方法。但是如果无参方法在场，就不需要可变参数方法了。现在对这个类来说$
methodF or0verload(7 ） 到底花落谁家？ 口币4 在重载方法中，选择合适的目标方法的顺
序如下
I I ）精辅IT§「，。
{ 2 ） 归：~ J:l ~t 丰、；；；H.,, '± Jt 吨向zν一转换成（，.＿ ＊、式；； +u.11 自f t1U弘支只1c
( 3 ）垂头，＿ 1 吗l'-t~ ；自］在怕。
( 4 ）王i~ ；＇主J I 吗？啡， f ！； ~l!支仿次吃自ll 。
I 气1 、f,: 7f ：＂在Ir
精确匹配优先，这是毫无疑问的。int 在和Integer 的较量中胜出，因为不需要自
动装箱，所以7 会调用int 参数的方法。如果是new Integer （？） 的话， Integer 参数的方
法胜出。
如果本方法只有methodForOverload(long ）， 贝lj 可以接收methodForOverload(3 ） 的
实参调用； 反之， 如果只有methodF orOverload( int）， 而传人long 值，则会编译出
错。基本数据类型转化为表示范围更大的基本数据类型优先于自动装箱， 即int 转为
long ， 优先于装箱为Integer 。
注意， null 可以匹配任何类对象，在查找目标方法时，是从最底层子类依次向上
查找的。在本例中， 如果methodForOverload(null ）， 贝lj 会调用参数为Integer 的方法。
第一， 因为Integer 是一个类，第二， 它是0 均ect 的子类。在示例代码中， 如果还有
单个String 类型参数的方法，贝lj 会编译出锚，因为null 不知道该选择Integer ， 还是
String 。
根据上述匹配顺序，可变参数在竞争中明显处于弱势地位。如果调用
methodF orOverload( 13 , 14 ），此时有两个参数，虽然有自动装箱的开销，但可变参数仍
会执行这种方法请求。
最后，有些程序员好奇心特别强， 刚才不是说7 是匹配基本数据类型优先， 而
new Integer （？） 是匹配包装类优先的，那如果这样定义。
public void methodForOverload( int paraml , Integer param2 ) {}
public void methodForOverload(Integer param3 , int param4) {}
仅供非商业用途或交流学习使用
83
码出高效· Java 开发手册
这种定义方式就是在考验编译器的忍耐底线，虽然编译器的内心是崩
溃的，但是这样定义是可以编译通过的，这也是一种重载方式。但此时调用
methodF orOverload( 13, 14 ） 会彻底让编译器失控，如图2-9 所示。
P' .b' c c»:v· 吨， J ·J ,: mai.n ( Stri.ng 口args) {
’也I Overload~le t hods(). method For的er l o日d( >
} Ambiguous method call. Both
methodFo币verl 臼d (Int, Int钳制in OVerloadMethods and
method For。V町1 。“（ Integer ，阳t) in 0Ver1 幽dMethods match
图2-9 相似重载方法调用： I:\ 销
最后，假如一个类申只有methodForOverload(Object param )
和methodF orOverload(Integer. .. param ） 两种方法，根据目标方法匹配顺序，
methodForOverload(7 ） 先自动装箱，然后向上转型，遇到O bject 。这个规则优先
于调用可变参数的重载方法。
父类的公有实例方法与子类的公有实例方法可以存在重载关系。不管继承关系如
何复杂，重载在编译时可以根据规则知道调用哪种目标方法。所以，重载又称为静态
绑定。
2 .6 泛型
泛型的本质是类型参数化，解决不确定具体对象类型的问题。在面向对象编程语
言中，允许程序员在强类型校验下定义某些可变部分，以达到代码复用的目的。泛型
(generic ）、天才（ ge nius ）、基因（ ge ne ）三个英文单词的词根都是gen ，最神奇的
是，它们无论是拼写还是发音都十分相像， 在沟通中往往比较含糊。可以这样理解，
泛型就是这些拥有天才基因的大师们发明的。
Java 在引入泛型前， 表示可变类型，往往存在类型安全的风险。举一个生活中的
例子，微波炉最主要的功能是加热食物，即加热肉、加热汤都有可能。在没有泛型的
场景中，往往会写出。
class Stove {
I 84
public static Object heat(Object food) {
System . out.println(food + ” is done ” );
return food;
public static void main (St ri ng[] args) {
仅供非商业用途或交流学习使用
Meat meat= new Meat();
meat= (Meat)Stove.heat(meat);
Soup soup= new Soup();
soup= (Soup)Stove . heat(soup);
第2 章面向对象
为了避免给每种食材定义一个加热方法，如heatMeat （）、heatSoup（）等，将heat()
的参数和返回值定义为0 均ect ，用“向上转型”的方式，让其具备可以加热任意类型
对象的能力。这种方式增强了类的灵活性，但却会让客户端产生困惑，因为客户端对
加热的内容一无所知，在取出来时进行强制转换就会存在类型转换风险。泛型则可以
完美地解决这个问题。
泛型可以定义在类、接口、方法中，编译器通过识别尖括号和尖括号内的字母来
解析泛型。在泛型定义肘，约定俗成的符号包括E 代表Element ，用于集合中的元素；
T 代表the Type of object ，表示某个类； K 代表K町、V 代表Value ，用于键值对元素。
我们用一个示例彻底地记住泛型定义的概念，对泛型不再有恐惧心理。如果下面代码
编译出错，请指出编译出错的位置在哪里
public class GenericDefiniti 。nDemo<T> {
static <String, T, Al 工baba> Str 工ng get( String string, Alibaba alibaba) {
return string;
public static void main(String[) args) {
Integer first = 222 ;
Long second = 333L ;
／／询「rJ J If}( '/... :i·J get 刀／l.
Integer result= get(first, second);
事实上，以上代码编译正确且能够正常运行， ge咱是一个泛型方法，曲st 并非是
java.lang. String 类型，而是泛型标识＜String>, second t旨代Alibaba 。ge均中其他没有被用
到的泛型符号并不会导致编译出错，类名后的T 与尖括号内的T 相同也是合法的。当然
在实际应用时，并不会存在这样的定义方式，这里只是期望能够对以下几点加深理解：
( l ）尖捂号里的每个元素都指代一种未知类型。String 出现在尖括号里，它就
不是java.lang.String ，而仅仅是一个代号。类名后方定义的泛型＜T> 和get （）前方定
义的＜T＞是两个指代，可以完全不同，互不影响。
85 1
仅供非商业用途或交流学习佼用
码出高效· Java 开发手册
( ~ ）尖括号的fi/.'f1 非常讲究，必须在奕启z frci<X. h 川、工豆r f句？前。
( 3 \ ：：＇； 三7 』‘’... ~ [ 1 尺L.J ’ Object 」－~ '.1-. 俨因此想在get（） 内部执行
string.longValue() + alibaba.intValue（） 是做不到的，此时泛型只能调用Object 类中的方
法，如to String（）。
、斗iA ， 斗”.>r2 J口的牛勺叭1U ~· . 宾主‘三古，＿，， 〉号飞L•. 七、去~：；＞＇＇户，、俨
11月（ ~之型只是一种哺.， , -<-1( :UU. R-t P士、语法岭查。在使用泛型元素肘，会执行强制类型转换·
INV。KESTATIC com/alibaba/easy/coding/generic/GenericDefini t i onDemo . get
(Ljava/lang/Ob ject ; Ljava/lang/Object ;)Ljava/lang/Object ;
CHECKCAST java/lang ／工ηteger
这就是坊间盛传的类型擦除。CHECKCAST 指令在运行时会检查对象实例的类
型是否匹配， 如果不匹配，贝iJ 抛出运行时异常ClassCastException。与C＋＋根据模板
类生成不同的类的方式不同， Java 使用的是类型擦除的方式。编译后， get（） 的参数是
两个0均ect ， 返回值也是Object ， 尖括号里很多内容消失了， 参数中也没有String 和
Alibaba 两个类型。数据返回给Integer result 时， 进行了类型强制转化。因此， 泛型
就是在编译期增加了一道检查而己， 目的是促使程序员在使用泛型时安全放置和使用
数据。使用泛型的好处包括
· 类型安全。放置的是什么， 取出来的自然是什么， 不用担心会抛出
ClassCastException 异常。
· 提升可读性。从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类
型是什么。
· 代码重用。泛型合并了同类型的处理代码，使代码重用度变高。
回到本节开头微波炉加热食材的例子， 使用泛型可以很好地实现， 示例代码如下。
public class St ove {
I 86
public static <T> T heat (T food ) {
System . out . pr 工ntln (food + "is ~ic,n " ) ;
return food ;
public static v。id main(Str 工ng[) args) {
Meat meat = new Meat() ;
仅供二｜｜商业用途或交流学习使用
meat= Stove .heat(meat);
Soup soup= new Soup();
soup= Stove.heat(soup);
第2 章面向对象
通过使用泛型，既可以避免对加热肉和加热汤定义两种不同的方法，也可以避免
使用Object 作为输入和输出，带来强制转换的风险。只要这种强制转换的风险存在，
依据墨菲定律，就一定会发生ClassCastException 异常。特别是在复杂的代码逻辑中，
会形成网状的调用关系，如果任意使用强制转换，无论可读性还是安全性都存在问题。
最后，泛型与集合的联合使用，可以把泛型的功能发挥到极致，很多程序员
不清楚List 、L ist<Object> 、List＜？＞三者的区别，更加不能区分＜？ extends T＞与
<?super T＞的使用场景。具体请参考第6.5 节。
2.7 数据类型
2.7. 才基本数据类型
虽然Java 是面向对象编程语言，－切皆是对象，但是为了兼容人类根深蒂固的
数据处理习惯，加快常规数据的处理速度，提供了9 种基本数据类型，它们都不具备
对象的特性，没有属性和行为。基本数据类型是指不可再分的原子数据类型，内存
中直接存储此类型的值，通过内存地址即可直接访问到数据，并且此内存区域只能
存放这种类型的值。Java 的9 种基本数据类型包括boolean 、byte 、char 、sho川、int 、
long 、float 、double 和refvar。前8 种数据类型表示生活中的真假、字符、整数和小
数，最后一种refvar 是面向对象世界中的引用变量，也叫引用句柄。本书认为它也
是一种基本数据类型。前8 种都有相应的包装数据类型，除char 的对应包装类名为
Character, int 为Integer 外，其他所有对应的包装类名就是把首字母大写即可。这8
种基本数据类型的默认值、空间占用大小、表示范围及对应的包装类等信息如表2 -4
所示。
87
仅供＃商业用i主或交流学习使用
码出高效· Java 开发手册
表2-4 基本数据类型
序号类型名称默认值大小最小值最大值包装类缓存区间
boolean false l B O(false) l(tru Boolean 无
2 byte (byte)O l B 128 127 Byte 128 ~ 127
3 char ’\uOOOO’ 2B '\uOOOO’ ’\uFFFF’ Character (ch 缸）0 ～（char) l27
4 short (short)O 2B 一2" 2"-1( 32767) Short 128 ~ 127
5 int 。4B 一23 1 231 一l Integer -128 ~ 127
6 long OL SB 一263 263一l Long 128 ~ 127
7 float O.Of 4B 1.4e-45 3.4e+38 Float 无
8 double O.Od SB 4.9e 324 1.798e+308 Double 无
默认值虽然都与0 有关，但是它们之间是存在区别的。比如， boolean 的默认值
以0 表示的false , JVM 并没有针对boolean 数据类型进行赋值的专用字节码指令，
boolean flag= false 就是用ICONST一0 ，即常数0 来进行赋值， byte 的默认值以一个字
节的0 表示，在默认值的表示上使用了强制类型转化， float 的默认值以单精度浮点数
O.Of表示，浮点数的0 0 使用后缀f和d 区别标识； char 的默认值只能是单可｜号的’＼uOOOO’
表示NUL ，注意不是null ， 它就是一个空的不可见字符，在码表中是第一个，其码值
为0 ，与W 换行之类的不可见控制符的理解角度是一样的。注意，不可以用双引号
方式对char 进行赋值，那是字符串的表示方式。在代码中直接出现的没有任何上下
文的0 和0 0 分别默认为int 和double 类型，可以使用JDKIO 的类型推断证明var
a=O; Long b=a：，代码编译出锚，因为在自动装箱时， 0 默认是int 类型，自动装箱为
Integer ，无法转化为Long 类型。
所有数值类型都是有符号的，最大值与最小值如表2-4 所示。因为浮点数无法
表示零值，所以表示范围分为两个区间，正数区间和负数区间。表2 -4 中的float 和
double 的最小值与最大值均指正数区间，它们对应的包装类并没有缓存任何数值。
引用分成两种数据类型百｜用变量本身和引用指向的对象。为了强化这两个概念
的区分，本书把寻｜用变量（ Reference Variable ）称为refvar ，而把引用指向的实际对
象（ Referred Object ）简称为refo均。
188
仅供＃商业用i主或交流学习使用
第2 章面向对象
r巳fvar 是基本的数据类型， 它的默认值是null ，存储r巳fobj 的首地址，可以直接
使用双等号＝＝进行等值判断。而平时使用refvar.hashCode（） 返回的值， 只是对象的
某种晗希计算，可能与地址有关，与refvar 本身存储的内存单元地址是两回事。作为
个引用变量，不管它是指向包装类、集合类、字符串类还是自定义类， refvar 均占
用4B 空间。注意它与真正对象refobj 之间的区别。无论refobj 是多么小的对象，最
小占用的存储空间是12B （ 用于存储基本信息， 称为对象头） ， 但由于存储空间分配
必须是8B 的倍数， 所以初始分配的空间至少是16B 。
一个refvar 至多存储一个refobj 的首地址，一个refobj 可以被多个refvar 存储下
它的首地址， 即个堆内对象可以被多个refvar ~ I 用指向。如果refo均没有被任何
refvar 指向，那么它迟早会被垃圾回收。而refvar 的内存释放， 与其他基本数据类型
类似。
基本数据类型int 占用4 个字节， 而对应的包装类Integer 实例对象占用16 个字
节。这里可能会有人问Integer 里边的代码就只占用16B ？这是因为字段属性除成
员属性int value 外， 其他的如MAX VAL四、MIN VA LUE 等都是静态成员变量，
在类加载时就分配了内存， 与实例对象容量无关。此外，类定义中的方法代码不占用
实例对象的任何空间。IntegerCache 是Integer 的静态内部类， 容量占用也与实例对象
无关。由于refobj 对象的基础大小是12B ， 再加上int 是4B ，所以Integer 实例对象占
用16B ， 按此推算Double 对象占用的存储容量是24B ，示例代码如下。
class RefObjDemo {
／／对象头最小占用空间12 个字节（第l 处）
／／下方4 个byte 委型分配后，对象占用大小是16 个字节
byte bl;
byte b2 ;
byte b3 ;
byte b4;
／／下方每个引用变量占用是4 个字节，共20 个字节
Ob] ect objl ;
Object ob j 2;
Object obj3 ;
Object obj4 ;
Object ob] 5;
II RefOb 〕Other 实例占用空间并千计算在本对穿内，依然只计算引用变量大小4 个字节
RefObjOther ol = new RefOb] Other() ;
89 1
仅供非商业用途或交流学习佼用
码出高效Java 开发手册
(4B ×与） + (4BX2) = 44 ↑、；：节
RefObjOther o2 = new RefObjOther() ;
／／综上. RefObjDemo 对于占用： 12B + (lB × 4) +
／／取8 的倍数为48 1 、c／节
class RefObjOther {
II double i类型占用8 个字节，！旦此处是教组引用变茸
／／所以对象头12B + 4B = 16B ，并非是8012 个字节
／／立个数纽引哨的是double ［］是型． 指向实际',j- 自己的放哨？问首灿址
／／在new 对象时． 已结实际分自己专i可
double [ ] d = new double [ 1 ] 00 ];
在上述示例代码中，第l 处提到的对象头最小占用空间1 2 为个字节，其内部存
储的是什么信息呢？下面来分析其内部结构，如图2 -1 O 所示，对象分为三块存储区域。
一副一者自
一则一椭E
E 一同－ 析’ 白一川一俑’
圃圈圈
圃噩噩
| 类元信息 | 回噩噩
| 实例数据|
｜［对齐填充］！
节
｛于
<i
句’ι
头
象
41
π且
图2一10 对象头的内部结构
( I ）对象头（ Object !leader )
对象头占用12 个字节，存储内容包括对象标记（ markOop ）和类元信息（ klassOop ）。
对象标记存储对象本身运行时的数据，如晗希码、GC 标记、锁信息、线程关联信息等，
这部分数据在64 位NM 上占用8 个字节，称为
态f言息’ 对象轩、记的存储恪式是非固定的（具休与J飞1M 的实现有关）。类元信患、存
储的是对象指向它的类元数据（即Klass ）的首地址’占用4 个字节，与refvar 开销一致。
( 2 ） 实例数据（ Instance Data )
存储本类对象的实例成员变量和所有可见的父类成员变量。如Integer 的实例
仅供才｜商业用途或交流学习使用
I 90
第2 章面向对象
成员只有一个private int value ，占用4 个字节，所以加上对象头为16 个字节1 再
如，上述示例代码的R巳fObjDemo 对象大小为48 个字节，一个子类RefO bjSon 继承
RefObjDemo ， 即使子类内部是空的， n ew RefObjSon 的对象也是占用48 个字节。
( 3 ）对齐填充（ Padding )
对象的存储空间分配单位是8 个字节，如果一个占用大小为16 个字节的对象，
增加一个成员变量byte 类型，此时需要占用17 个字节，但是也会分配24 个字节进
行对齐填充操作。
2.7.2 包装类型
前8 种基本数据类型都有相应的包装类，因为Java 的设计理念是一切皆是对
象，在很多情况下，需要以对象的形式操作，比如hash Code（）获取晗希值，或者
getC l ass （）获取类等。包装类的存在解决了基本数据类型无法做到的事情泛型类型
参数、序列化、类型转换、高频区间数据缓存。尤其是最后－项，我们都知道Integer
会缓存－ 128～ 127 之间的值，对于Integer var=？在－ 128～ 127 之间的赋值， Integer 对
象由I ntegerCache . cache 产生，会复用已有对象，这个区间内的Integer 值可以直接使
用＝＝进行判断，但是这个区间之外的所有数据都会在堆上产生，并不会复用已有对象，
这是一个大问题。因此，推荐所有包装类对象之间值的比较3 全部使用equals （）方法。
事实上，除F loat 和Double 外，其他包装数据类型都会缓存， 6 个包装类直接赋
值时，就是调用对应包装类的静态工厂方法va lueOf（）， 以I nteger 为例，源码如下·
@HotSpotintrinsicCandidate
public static Integer valueOf( int i) {
if (i >= IntegerCache.low && i <= IntegerCache.high)
return IntegerCache.cache[i + (- IntegerCache.low)];
return new Integer （工）；
如上源代码，赋值数据i 在缓存区间内直接返回缓存中的I nteger 对象，否则就
会new 一个对象。在IDK9 直接把new 的构造方法过时，推荐使用va lu eOf（），合理
利用缓存，提升程序性能。各个包装类的缓存区间如下
•Boolean ：使用静态final 变量定义， valueOf（）就是返回这两个静态值。
•Byte: 表示范围是－ 128～ 127 ，全部缓存。
• Sho时，表示范围是一32768 ～ 32767 ，缓存范围是－ 128 ～ 127 。
仅供＇II＇商业用途或交流学习使用
9才
码出高效： Java 开发手册
• Character: 表示范围是O～65535 ，缓存范围是O～ 127 。
•Long ：表示范围是［－263, 263一l ］，缓存范围是一128-1270
•Integer ，表示范围是［ 231, 231 一l ］。最后详细介绍Integer ，因为它是Java 数
据世界里应用最广的数据类型，缓存范围是128～ 127。但它是唯一可以修改
缓存范围的包装类，在VM options 加入参数－XX:AutoBoxCacheMax=7777,
即可设置最大缓存值为7777 ， 示例代码如下
public class LongintegerCacheTest {
public static void main(String[] args) {
TU.Y,.U,
叮f 叮，，
？』q4
1414
－一一－
TUOTUnUO qnJ q aJ b
System . out . println( "Long max cached value is 127,”
+ ” and the result is :" + (a== b) );
Long al = 128L;
Long bl = 128L;
System . out . println ( ” Long=l28 cache is " + (al== bl)) ;
Long c = - 1281;
Long d = - 1281 ;
System . out.println ( ” Long m 工n cached value is - 128,”
+ "and the result i s :” + (c == d));
Long cl = - 129L;
Long dl = - 129L;
System . out.println （ ” Lo 口g= - 129 cache is " + (cl == dl));
II Long 类型只续存－ 128 ～ 127 之间的数值
Long e = 10001 ;
Lo口g f = 10001 ;
System . out . pr 工ntln （ ” Long=lOOO is H 十（ e == f)) ;
II JVM AutoBoxCacheMax 只对Integer 对象有效
Integer x = 1001 ;
Integer y = 1001 ;
System.out .println ( ” Integer=lOOl i s ” + (x == y));
92
执行结果如下
Long max cached value is 127, and the result is: true
Long=l28 cache 工s false
Long min cached value is -128, and the result is : true
Long= - 129 cache i s false
Long=lOOO is false
Integer=lOOl is true
第2 章面向对象
该例很好地说明了Lon g 只是缓存了－ 128～ 127 之间的值，而JOOOL 没有被缓存；
在将Integer 最大缓存值改为777 7 后， 1001 被成功缓存。合理掌握包装类的缓存策略，
防止遇到问题是一个方面，使自己的程序性能最大化，更是程序员的情怀所在。在选
择使用包装类还是基本数据类型时，推荐使用如下方式
( I ) pf 有的POJO 5+.J,•~·1 飞必纺、使用包装数据失早、
( 2 ) RPC 方法的返［〈值却参数必须使用包装数据类型。
( 3 ）所有的局部交rJt-tt 荐使用基本数据类型。
2 . 7.3 字符串
字符串类型是常用的数据类型1 它在JVM 中的地位并不比基本数据类型低，
JVM 对字符串也做了特殊处理。String 就像是流落到基本数据类型部落的一个副首领，
虽然很神气， 但是终归难以得到族人对它的认同，毕竟它是堆上分配来的。
字符串相关类型主要有三种String 、Strin gBuild町、Strin g Buffer 。String 是只读
字符串，典型的immutabl e 对象， 对它的任何改动， 其实都是创建一个新对象，再把
引用指向该对象。Strin g 对象赋值操作后， 会在常量池中进行缓存，如果下次申请创
建对象时， 缓存中已经存在， 贝lj 直接返回相应引用给创建者。而StringBuffer 贝lj 可以
在原对象上进行修改， 是线程安全的。JDK5 号｜入的Stri ngBuilder 与StringBuffer 均继
承自AbstractStringBui Ider ， 两个子类的很多方法都是通过飞uper. 方法。” 的方式调
用抽象父类中的方法， 此抽象类在内部与String 一样， 也是以字符数组的形式存储字
符串的。StringBuilder 是非线程安全的， 把是否需要进行多线程加锁交给工程师决定，
操作效率比StringBuffer 高。线程安全的对象先产生是因为计算机的发展总是从单线
程到多线程，从单机到分布式。
在非基本数据类型的对象中， Strin g 是仅支持直接相加操作的对象。这样操作比
较方便， 但在循环体内，字符串的连接方式应该使用String Builder 的append 方法进
行扩展。如下的方式是不推荐的
93
码出高效. Java 开发手册
String str = ” start ";
for (int i = O; i < 100; i++) {
str = str + ” hello ” ;
此段代码的内部实现逻辑是每次循环都会new 个StringBuilder 对象， 然后进
行append 操作，最后通过toString 方法返回String 对象， 不但造成了内存资源浪费，
而且性能更差。
I 94
第3 章代码风格
流水淡，碧天长，鸿雁成行。编码风格，简捷清爽，反亏｜无限风光。
-<l 『〈？气:J ＿！＿江气孔
码出高效Java 开发手册
在美剧〈硅谷〉中有这样一个经典镜头，主人公Richard 与同为开发工程师的女
友闹分手，理由是两人对缩进方式有着截然不同的编程习惯，互相鄙视对方的代码风
格。Richard 认为＂ one tab saves four spaces ”，缩进使用Tab 键操作更快，更节省存
储空间，而女友坚持使用空格缩进，连续四次敲击空格的声音，把Richard 折磨到几
近崩溃，认为这是种精神折磨。Richard 觉得难以相处，吵完架下楼梯时，不小心
摔倒了， 还淡定地说， "I just tried to go down the stairs four steps at a time” （这只是
表达我的立场而已）。Tab 键和空恪键的争议在现实编程中确实存在。除此之外，在
其他代码风格上， 也存在不同的处理方式，往往是谁也说服不了谁，都站在自身“完
全正确”的立场上，试图说服对方。这在团队开发效率上，往往是一个巨大的内耗，
无休止的争论与最后的收益是成反比的。所以， 我们认为致性很重要，就像交通规
则样， 我国规定靠右行驶，有些国家则规定靠左行驶，并没有绝对的优劣之分，但
是在同个国家或地区内必须要有统的标准。代码风格也是如此， 无论选择哪一种
处理方式，都需要部分人牺牲小我， 成就大我，切实提升团队的研发效能。
代码风格并不影响程序运行， 没有潜在的故障风险，通常与数据结构、逻辑表达
无关，是指不可见字符的展示方式、代码元素的命名方式和代码注释风格等。比如，
大括号是否换行、缩进方式、常量与变量的命名方式、注释是否统一放置在代码上方
等。代码风格的主要诉求是清爽统一、便于阅读和维护。统一的代码风格可以让开发
工程师们没有严重的代码心理壁垒， 每个人都可以轻松地阅读并快速理解代码逻辑，
便于高效协作， 逐步形成团队的代码“昧道”。
3.1 命名规约
代码元素包括类、方法、参数、常量、变量等程序中的各种要素。合适的命名，
可以体现出元素的特征、职责，以及元素之间的差异性和协同性。为了统一代码风格，
元素的命名要遵守以下约定。
1. 命名符合本语言特性
当前主流的编程语言有50 种左右，分为两大阵营一一面向对象与面向过程，但
是按变量定义和赋值的要求， 分为强类型语言和弱类型语言。每种语言都有自己的独
特命名风格， 有些语言在定义时提倡以前缀来区分局部变量、全局变量、控件类型。
比如Ii_count 表示local int 局部整型变量， dw_report 表示data window 用于展示报表
数据的控件。有些语言规定以下画线为前缀来进行命名。这些语言的命名风格， 自成
I 96
第3 章代码风格
一派， 也无可厚非，但是在同种语言中，如果使用多种语言的命名风格， 就会引起
其他开发工程师的反感。比如，在Java 中，所有代码元素的命名均不能以下画线或
美元符号开始或结束。
2 . 合字体」叽；代码元支特征
命名上可体现出代码元素的特征， 仅从名字上即可知道代码元素的属性是什么，
有利于快速厘清代码脉络。面向对象代码元素的命名形式分为两大类，即首字母大写
的UpperCamel Case 和首字母小写的lowerC amel Case ，前者俗称大驼峰， 后者俗称小
驼峰。类名采用大驼峰形式，一般为名词，例如Object 、StringBuff町、Fil einp utStream 等。
方法名采用小驼峰形式，一般为动词，与参数组成动宾结构，例如。同ect 的wa it（）、
StringBuffer 的append(Stri n g） 、Fi l einputStream 的read（） 等。变量包括参数、成员变量、
局部变量等， 也采用小驼峰形式。常量的命名方式比较特殊，字母全部大写，单词之
间用下画线连接。常量和变量是最基本的代码元素，就像血液中的红细胞一样无处不
在。合理的命名， 有利于保障代码机体的清爽、健康。
在命名时若能体现出元素的特征， 贝lj 有助于快速识另iJ命名对象的作用， 有助于快
速理解程序逻辑。我们推荐在Java 命名时， 以下列方式体现元素特征·
· 包名统使用小写，点分隔符之间有且仅有个自然语义的英语单词。包名
统一使用单数形式，但是类名如果有复数含义， 贝lj 可以使用复数形式。
· 抽象类命名使用Abstract 或Base 开头； 异常类命名使用Exception 结尾， 测
试类命名以它要测试的类名开始，以Test 结尾。
· 类型与中括号紧挨相连来定义数组。
· 枚举类名带上En um 后缀，枚举成员名称需要全大写，单词间用下画线隔开。
3. 命名最好望灭知x..
望文知义是在不需要额外解释的情况下， 仅从名称上就能够理解某个词旬的确切
含义。在代码元素命名时做到望文知义， 从而减少注释内容， 达到自解释的目的。在
实践中， 望文知义的难度是最大的， 就好像给孩子起名一样需要反复斟酌。文不对题
的命名方式， 肯定会加大理解成本，更大的罪过是把程序员引导到一个错误的理解方
向上。某些不规范的缩写会导致理解成本增加， 比如condition 缩写成condi ， 类似随
意的缩写会严重降低代码的可理解性。再比如， 以单个字母命名的变量，在上下文理
解时， 会带来很大的困扰。本书中的所有示例代码都比较精筒， 没有具体业务含义，
重点在于阐述示例背后的编程思维，所以采用单字母的简洁命名方式，在实际业务代
97
仅供才l0iili业用途或交流学习使用
码出高效： Java 开发手册
码中请勿模仿。
主流的编程语言基本上以英语为基础，此处望文知义的“ 文” 指的是英文。随着
开源社区的发展与繁荣，各国程序员踊跃参与开源项目的共建，国际交流与合作越来
越频繁，英语能力已经成为程序员必备的基础技能之一。虽然有人认为命名方式应该
符合本国语言习惯，拼音这种命名方式，应该是被允许的，但是在国际化项目或开源
项目中，对于非汉语国家的开发工程师而言，拼音这种命名方式的可读性几乎为零。
即使在汉语系国家，拼音也存在地区差异。中英文混合的方式，更不应该出现， 比如
在某业务代码中，曾经出现过DaZePromotion ，猜了很久才被命名者告知是打折促销
的类。最让人无法容忍的是拼音“首字母”简写的命名方式，即使发挥极致的想象
力，也很难猜出具体的含义，比如PfmxBuilder ， 名称意思是评分模型的创建工厂类l
这些命名方式，极大增加了程序的理解戚本。所以，正确的英文拼写和语法可以让阅
读者易于理解，避免歧义。alibaba 、taobao 、hangzhou 等国际通用的名称，可视同英
文。某些复合语义的情况下，尽量使用完整的单词组合来达到望文知义的目的， 比如
KeyboardShortcutsHandler 、AtomicReferenceFieldUpdater。
命名要符合语言特性、体现元素特征。命名做到望文知义、自解释是每个开发工
程师的基本素质之一。我们在思量更好的代码元素命名的同时，也要敢于修改已有的
不合理的命名方式。
在所有代码元素中，常量和变量最为常见，优雅地定义与使用好它们，是开发工
程师的基本功之一。
3.1.1 常量
什么是常量？常量是在作用域内保持不变的值， 般用final 关键字进行修饰，
根据作用域区分，分为全局常量、类内常量、局部常量。全局常量是指类的公开静态
属性， 使用public static final 修饰；类内常量是私有静态属性， 使用private static final
修饰，局部常量分为方法常量和参数常量，前者是在方法或代码块内定义的常量，后
者是在定义形式参数时， 增加final 标识， 表示此参数值不能被修改。全局常量和类
内常量是最主要的常量表现形式，它们的命名方式比较特殊，采用字母全部大写、单
词之间加下画线的方式。而局部常量采用小驼峰形式即可。示例代码如下：
public class Constant {
198
public static final String GLOBAL CONSTANT = ” shared in global ” ;
private static final String CLASS CONSTANT = ” shared in class ";
仅供才l0iili业用途或交流学习使用
第3 章代码风格
public v。id f(String a) {
final String methodConstant = ” shared in method ” ;
public void g( final int b) {
／／纳泽出结． F 允许对’，~＇ lit 参哇进行重新成［自
b = " ;
常量在代码中具有穿透性，使用甚广。如果没有－个恰当的命名，就会给代码阅
读带来沉重的负担，甚至影响对主干逻辑的理解。首当其冲的问题就是到处使用魔法
值。魔法值即“共识层面” 上的常量，直接以具体的数值或者字符出现在代码中。这
些不知所云的魔法值极大地影响了代码的可读性和可维护性。下面先来看一段实际业
务代码。
public void getOnlinePackageCourse(Long packageid, Long userid) {
if (packageid == <) {
logger . error （ ” 线下课程． 天法在线观看” ）；
return ;
／／吨他逻辑处理
PackageCourse online = packageService.getByTeacherid(userid);
if (online.getPackageid() == L ) {
logger.error （ ” 未审核课程” ）；
return ;
／／其他逻将处理
以上示例代码中， 信手拈来的2 和3 分别表示未审核课程和线下课程，仅仅是两
个数字，似乎很容易记忆。但事实上除2 和3 两种状态外，还有l 、4 、5 分别代表新
建、审核未通过、审核通过。在团队规模较小时，口口相传，倒也勉强能够记住这五
个数字的含义，早期还有零星的注释，驾轻就熟的情况下，连注释也省了。现实是残
酷的，团队迅速扩大后，课程状态个数也在逐步增加，新来的开发工程师在上线新功
能模块时，把“审核通过”和“未审核课程” 对应的数字搞反了，使得课程展示错误，
导致用户大量投诉。随着应用变得越来越复杂，这些魔法值几乎成了整个后台服务代
码中的梦魔。团队架构师终于下定决心进行系统重构，把这些魔法值以合适的命名方
式定义成全局常量。使用Enum 枚举类来定义课程类型，示例代码如下
99
仅供二ll'iili业用途或交流学习使用
码出高效： Java 开发手册
public enum CourseTypeEnurn {
/**
＊允许官方和讲师告1J 范和运营
*/
V工DEO COURSE( l , ” 录插课程” ），
／＊女
＊只允许官方创建和运营于'fl 始ft 必须设置合理的报名人数上限
*/
LIVE COURSE( 2 ， ” 直插课程·· ），
/**
＊只允许官方创建和运营
老l
OFFLINE COURSE ( 3 ， ” 线下课枝” ）；
private int seq;
private String desc ;
CourseTypeEnurn (int seq, String desc) {
this . seq = seq;
this . desc = desc ;
public int getSeq() {
return seq;
public String getDesc() {
return desc ;
上述示例代码把课程类型分成三种录播课程、直播课程、线下课程。枚举类型
几乎是固定不变的全局常量，使用频率高、范围广，所以枚举常量都需要添加清晰的
注释，比如业务相关信息或注意事项等。再把课程状态分为新课程、未审核课程、审
核通过、审核未通过、已删除五种状态。考虑到后续课程状态还会再追加， 并且状态
没有扩展信息， 所以用不能实例化的抽象类的全局常量来表示课程状态，示例代码如
下：
public abstract c工ass BaseCourseState {
100
public static final int NEW COURSE = 1 ;
public static final int UNAUTHED COURSE = 2 ;
仅供二ll'illi业用途或交流学习使用
仅供＃商业用途或交流学习使用
第3 章代码风格
public static final int PASSED COURSE = 3 ;
public static final int NOT PASSED COURSE = 4;
public stat工c final int DELETED COURSE = 5;
使用重构后的常量修改原有的魔法值，对比一下代码的可读性
public void getPackageCourse(Long packageid, Long userid) {
if (packageid == CourseTypeEnum . OFFLINE COURSE . getSeq()) {
logger . error （ ” 线下课程咱无法在绞观看＂ ） ；
return;
VideoCourse course= packageService . getByTeacherid(userid) ;
if (course.getState() == BaseCourseState . UNAUTHED COURSE) {
logger . error （ ” 来审核课程” ） ；
return;
我们认为，系统成长到某个阶段后，重构是种必然选择。优秀的架构设计不是
去阻止未来切重构的可能性，毕竟技术枝、业务方向和规模都在不断变化，而是尽
可能让重构来得晚一些，重构幅度小一些。
即使类内常量和局部常量当前只使用一次，也需要赋予一个有意义的名称，目的
有两个I 第一、望文知义，方便理解1 第二、后期多次使用时能够保证值出同源。因此，
无论如何都不允许任何魔法值直接出现在代码中，避免魔法值随意使用导致取值不一
致，特别是对于字符串常量来说，应避免没有预先定义，就直接使用魔法值。所谓常
在河边走，哪有不湿鞋，在反复的复制与粘贴后，难免会出现问题，警示代码如下
d
γ4
r a d e
＋」
+
。
a
J
b
)
o
e
a
u
品L 14
#
a
d
v
γ4
..
y,
=
k e
yt 、
-KeUt
p
qJ
-
recnL he
←」a
sc
上述代码是保存信息到缓存中的方法， 即使用魔法值组装Key。这就导致各个调
用方到处复制和粘贴字符串Id#taobao ， 这样似乎很合理。但某一天，某个粗心的程
序员把Id#taobao 复制成为Id#taobao ，少了下画线。这个错误在测试过程中，并不
容易被发现， 因为没有命中缓存，会自动访问数据库。但在大促时， 数据库压力急剧
上升，进而发现缓存全部失效，导致连接占满，查询变慢。小处不小，再次说明魔法
值害人害己。
某些公认的字面常量是不需要预先定义的，如for( int i=O; ... ）这里的0 是可以直
才O丁
仅供＃商业用i主或交流学习使用
仅供非商业用途或交流学习使用
码出高效： Java 开发手册
接使用的。true 和false 也可以直接使用，但是如果具备了特殊的含义，就必须定义
出有意义的常量名称，比如在TreeMap 源码中，表示红黑树节点颜色的true 和fal se
就被定义成为类内常量，以方便理解
private static f主nal boolean RED = false ;
private static final b。。lean BLACK = true ;
常量命名应该全部大写，单词间用下画线隔开，力求语义表达完整清楚，不要嫌
名字长，比如，把最大库存数量命名为MAX STOCK corn叮，把缓存失效时间命
名为CACHE EXPI阻D TJ ME。
3.1 .2 变量
什么是变量？从广义来说，在程序中变量是切通过分配内存并赋值的量，分为
不可变量（常量）和可变变量。从狭义来说，变量仅指在程序运行过程中可以改变其
值的量，包括成员变量和局部可变变量等。
一般情况下，变量的命名需要满足小驼峰格式，命名体现业务含义即可。存在一
种特殊情况，在定义类成员变量时，特别是在POJO 类中，针对布尔类型的变量，命
名不要加i s 前缀，否则部分框架解析会引起序列化错误。例如，定义标识是否删除的
成员变量为Boolean isDe l eted ，它的getter 方法也是i sDeleted（），框架在反向解析的时
候， “误以为”对应的属性名称是d e l eted ，导致获取不到属性，进而抛出异常。但是
在数据库建表中，推荐表达是与否的值采用is xxx 的命名方式，针对此种情况，需要
在＜resultMap＞中设置，将数据表中的i s_xxx 字段映射歪IJ POJO 类中的属性Xxx 。
3.2 代码展示风格
3.2.1 缩进、空格与空行
缩进、空格与空行造就了代码的层次性和规律性，有助于直观、快速、准确地理
解业务逻辑。没有缩进、空格和空行的代码可读性极差。如下反例所示
table=newTab;
if (oldTab!=null ) {
for (int ]=O, ]<oldCap; ++j) {if ( ( e=oldTab [ j] ) ! =null ) {
oldTab[j]=null ;
if (e . next==null )
newTab[e . hash&(newCap- ))=e ; else if (e 工nstanceof TreeNode)
才02
仅供＇II二商业用途或交流学习使用
仅供二ll'iili业用途或交流学习使用
if (loTail==null )loHead=e; else oTail. 口ext=e;
modCount++;
if ( (tab=table) ! =null &&size>=O) {
for (int i= ;i<tab.length;++i)tab[i)=null ;
// 、吨代玛．
I. 如二廿
第3 章代码风格
缩进表示层次对应关系。使用Tab 键缩进还是空格缩进长期以来备受争议，形成
两大阵营。每当在分享会现场调研缩进方式选择的时候，参与度几乎都是100% ， 通
常支持空格的人数多于支持Tab 键的人数。这时候Tab 键方一般都会提出“空格不
是有2 、4 、8 个之分吗？不如让空格方继续投票一下，我们Ta b 键方还是非常团结一
致的”。某报告对40 万个开源代码库进行了调研，发现近75 % 的代码文件使用了空
格进行缩进。对于团队协作来说，一致性风格很重要。我们推荐采用4 个空格缩进，
禁止使用Tab 键。
由于不同编辑器对Tab 的解析不一致，因此视觉体验会有差异，而空格在编辑器
之间是兼容的。2 个空格缩进的层次区分度不明显，超过4 个空格的缩进方式又留白
过多， 且大多数IDE 默认为4 个空格缩进， 所以我们采用4 个空恪的缩进方式。对
习惯用Tab 键的工程师来说，唯一的福音是很多IDE 工具提供了Tab 键与空恪之间
的快速转换设置。IDEA 设置Tab 键为4 个空格时，请勿勾选Use tab character ：，而在
Eclipse 申，必须勾选Insert spaces for tabs 。
2 空咯
空格用于分隔不同的编程元素。空格可以让运算待、数值、注释、参数等各种编
程元素之间错落有致，方便快速定位。空格的使用有如下约定，
( I ）仔何同、Ri~ ＃符的产击两边击1S必须加个y梢
( 2 ） 注释的双斜纯与注释内容之间有E 仅有－个空恪。
( 3 ）方法参数在应义和传入时，多个参数逗号局边必须加~~格。
( 4 ）没有必；要增加在f 空哨位变丑的赋值等；：｝ tj 1 f丁对应他E 的等-E；对茹c
( 5 ）虫！：果是大riE c｝句λ 店， Jllj 简洁地写成U R卜， 大到＇.： ~P o＇］元须唤仁和主恪。
( 6 ）左右I, 'f.~ ~ t J j吕号，句却自叫自织宇t-t~ ’ c ］／·、王啥叫空咯c
( 7 ）兰大t~~ 号前百要jJr_J 守恪。
103
仅供才l0P:li业用途或交流学习使用
仅供二ll'iili业用途或交流学习使用
码出高效： Java 开发手册
例如，有些工程师习惯在多行赋值语旬中对齐等号，如果增加了一条较长的赋值
语旬，工程师需要更新之前所有的语旬对齐格式，这种做法无疑提高了开发成本。此
外，虽然不推荐空大括号的代码出现，但可能会存在于某些测试代码或者流程语句中，
我们推荐空大括号中间无须换行和空格。详细的示例代码如下，重点看注释内容
public class SpaceCodeStyle {
I 104
／／吁有必姿J•;v 加若干空格使变莹的吠t室等号与上一i于对应位置的等号对齐
private static 工nteger one = l ;
private static Long tw。＝ 2L;
private static Float three = 3F;
private static StringBuilder sb = new StringBuilder { ” code style :”);
／／缩进4 i、空格（注意：本代码中的任何注悸在.:'ft 科线与注择内容之间有且｛又育一个空格）
public static void main (String [] args) {
／／继续缩进4 乍空格
try {
／／任何二目运算符的方右必须有一俨空格
int count = O;
／／三臼运算符的左右两边都必须育一个空格
boolean condition = (count == 0) ? true : false ;
／／关佟词if 与左侧小括号之间必须有一个空格
／／左括号内的字号c 与左括号、卒母n 与右括号都不斋要空格
／／古括号与左大括号前加空格且不换行． 左犬括号后必须换行
if (condition) {
System.out.println( "world” );
II else 的前后都必须加空恪
／／右大括号前执行， 古犬摇号后有else 时． 不用换行
} else {
System.out.println ( ” ok" );
／／在右大括号后直接结束， 则必须换行
／／如果是犬括号内为空．则简洁地写成门即可． 大括号中间无须按灯和空格
} catch (Exception e) {}
／／在每于实悉这号之后必须有一1、空格
String result = getStri 口g (one, two , three, sb);
System . out . println(result);
／／方法之间．通过空行进行隔断在方法定义中，每俨形朱乏后必须有一空格
private static String getString(Integer one, Long two , Float three,
Str 工ngBu 工lder sb) {
仅供二ll'illi业用途或交流学习使用
仅供＃商业用途或交流学习使用
第3 章代码风格
II H"1 弓运”符叫）工会1、俯1 1、空’l岳，包报町、f良主J）符，加号运11 j子等
Float temp = o 口e + two + three;
sb . append(temp);
return sb . toString();
3. 空俨
空行用来分隔功能相似、逻辑内聚、意思相近的代码片段，使得程序布局更加清
晰。在浏览代码时，空行可以起到自然停顿的作用，提升阅读代码的体验。哪些地方
需要空行呢？在方法定义之后、属性定义与方法之间、不同逻辑、不同语义、不同业
务的代码之间都需要通过空行来分隔。
3.2.2 换行与高度
I. 换行
代码中需要限定每行的字符个数，以便适配显示器的宽度，以及方便
CodeReview 时进行di ff 比对。对于无节制的行数字符，需要不断地拉取左右滚动条
或者键盘移动光标，那是多么差的体验。因此， 约定单行字符数不超过120 个，超出
则需要换行，换行时遵循如下原则
( I ）第二行咱对第h缩进斗＂＂？格， 从第一行严始， 不再继续缩进， 参考示例。
( 2 ） 运算符与丁、文－赳换行。
( 3 ）方法i周用的点符号与！、文一起换行。
( 4 ）方法调用中的多个参数需要换行时， 在逗号后换行。
( 5 ）在括号前不要换衍。
StringBuffer sb = new StringBuffer ();
／／超过120 俨字符的怡，兄下、换行fjf 进4 个空格． 并且方法前的点号一起换行
sb.appe 口d （ ” ma " ). append (” chu ” )...
. append （ ” ga 。” ）．
. append (” x ia 。” ）．
. append (” yeah " );
2 . 方法行数限制
水平方向上对字符数有限制，那么垂直方向上呢？对于类的长度， 只要类功能内
聚，不做强制要求。但方法是执行单位， 也是阅读代码逻辑的最高粒度模块。庞大的
105
仅供机商业用途或交流学习使用
仅供二ll'iili业用途或交流学习使用
码出高效： Java 开发手册
方法窑易引起阅读疲劳， 让人抓不住重点。代码逻辑要分主次、个性和共性。不要把
不同层次的逻辑写在一个大方法体里，应该将次要逻辑抽取为祖立方法， 将共性逻辑
抽取成为共性方法（比如参数校验、权限判断等），便于复用和维护，使主干代码逻
辑更加清晰。
高内聚、低辑合是程序员最熟悉的口号。如何内聚和解辑， 其实方法的行数限制
就引发了这些维度的思考。把相关的功能强内聚，把弱相关的功能拆解开来， 重新抽
象、重新封装。在拆分方法的过程中，通常会纠结对参数的处理， 因为拆分的各个方
法之间需要通过参数才能传递数据。有这种纠结的前提是方法需要传人大量的参数，
事实上这是另外个话题。限制参数列表过长的方式有很多， 比如包装成类、隐式传
递或放在集合中等。
综上所述，约定单个方法的总行数不超过80 行。详细的判定标准如下， 除注释
之外，方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数
不超过80 行。为什么是80 行？心理学认为人对事物的印象通常不能超过3 这个魔法
数， 三屏是人类短期记忆的极限，而80 行在一般显示器上是两屏半的代码量。另外，
通过对阿里代码抽样调查显示， 只有不到5% 的方法才会超过80 行， 而这些方法通
常都有明显的优化空间。
最后有人说， 80 行的硬性要求会让程序员在写代码时刻意将多个变量定义在→
行， 或者i f 后不写大括号，或者catch 代码后使用空语旬｛｝结束。每个公司都有
些强制的代码风格，肯定有些是大家的代码素养决定的，少数人偏偏冒天下之大不毡，
被这个群体淘汰也是迟早的事情。
3.2.3 ；空制语句
控制语句是底层机器码跳转指令的实现。方法内部的跳转控制主要由条件判断语
旬和循环语句实现。跳转能力使程序能够处理复杂逻辑， 具备像人一样的判断能力和
记忆回溯能力。条件判断主要由i f、switch 、三目运算符组成。循环严格意义上也是
一种跳转， 主要由for , w h i l e 、do-w hile 组成。
控制语句是最容易出现B u g 的地方， 所以特别需要代码风格的约束， 而不是天
马行空地乱跳。控制语句必须遵循如下约定：
I I i I二else for 、while 、do－川11lc 手，，，：：；可白，〉份’~＇ } t.~ 即使只有一行代码，
也需要加上大括号。
106
仅供才l0P:li业用途或交流学习使用
仅供叶商业用途或交流学习使用
第3 章代码风格
( 2 、~ ~ '" + l↓．、
叮~ 1.r-, "' 有些控制语旬的表达式逻辑相当复杂，与、或、取反混合运算甚至穿插了
赋值操作，理解成本非常高，甚至会产生误解。要解决这个问题， 有一个非常简单的
办法·将复杂的逻辑运算赋值给一个具有业务含义的布尔变量。例如。
／／旧车’·＇ 1）听中｛；~I于l 复杂拘步扩·101) i均． 不易于1型仰
if ( (file.open(fileName , ” w" ) 1 = null ) & & ( • •• ) I I ! ( ... ) ) {
/ 问＜； ＇，句立. " i主J A 古扩f、·ij f'' .，叫节尔变＇＂ . }j !:J! '1 i. ＇.·件· ,iL
final boolean existed= (file.open(fileName , ” w” ) ! = null )
&&( . .. )||!( . . . ),
if (ex 工sted) {
3 ‘五r 、“了~＇－~ ~.，. J I'." 多层嵌套在哪里都不受欢迎，是因为条件判断和
分支逻辑数量呈指数关系。如果非得使用多层嵌套，请使用状态设计模式。对于超过
3 层的if-e lse 的逻辑判断代码，可以使用卫语句、策略模式、状态模式等来实现， 其
中卫语旬示例如下
public void today() {
if (isBusy()) {
System . out.println (” change t 工me . ” );
return;
if （工sFree ()) {
System.out . println ( ” go to travel . ” );
return ;
System . out . println( " s .ay at home to learn Easy Coding . ” ) ;
return;
（ 斗、：巳勺π 呵？口＂＂＇ t ＂＇、、；＇＂＂＇ 取反逻辑不利于快速理解， 并且取反逻辑写法
必然存在对应的正向逻辑写法。比如使用i f (x < 628） 表达X 小于628 ，而不是使用i f (!(x
>= 628））。
107
仅供｜｜商业用途或交流学习使用
码出高效· Java 开发手册
3.3 代码注释
3.3.1 注释三要素
注释是一个看起来简单，容易被忽视，但是作用又不容小觑的话题。好的注释能
起到指路明灯、拨云见日、警示等作用，具体包括。能够准确反映设计思想和代码逻
辑；能够描述业务含义使其他工程师能迅速了解背景知识。与代码不同，注释没有
语法的限制，完全取决于编写者的能力和发挥，但这并不意昧着注释可以天马行空。
书写注释要满足优雅注释三要素。
I. Nothing is strange
完全没有注释的大段代码对于阅读者来说形同天书。注释是给自己看的，即使离
写完代码很长时间，也能清晰地理解当时的思路，注释也是给维护者看的，使其能够
快速理解代码逻辑。
相信大多数人阅读JDK 源码时都十分吃力，比如并发控制、集合算法等，这些
天才级的程序基本上没有任何注释。JDK 的代码稳定、高效压倒切，不会朝编夕改。
但是业务代码需要被不断地维护更新，没有注释的代码给人一种陌生感。世界上最遥
远的距离是，我和要修改的代码间缺少一段注释。因此，我们提倡要写注释，然后才
是把注释写得精筒。
2. Less is more
从代码可读性及维护成本方面来讲， 代码中的注释定是精华中的精华。
首先， 真正好的代码是自解释的，准确的变量命名加上合理的代码逻辑，无须过
多的文字说明就足以让其他工程师理解代码的功能。如果代码需要大量的注释来说明
解释，那么工程师应该思考是否可以优化代码表现力。
其次，泛滥的注释不但不能帮助工程师理解代码，而且会影响代码的可读性，甚
至会增加程序的维护成本。如下示例代码是滥用注释的样例，方法名put ， 加上两个
有意义的变量名e lephant 和fridge ，已经明确表达了代码功能，完全不需要额外的注释。
在遇到修改代码逻辑时，注释泛滥会带来灾难性的负担。
II put elephant into fr-1.dge
put(elephant, fridge);
｜ 才08
仅供＃商业用途或交流学习使用
第3 章代码风格
3. I飞d飞ance with the time目
与时俱进的重要性对于开发工程师来说是不言而喻的。就像道路状况与导航软件
一样，如果导航软件严重滞后，就失去了导航的意义。同样，针对一段有注释的代码，
如果程序员修改了代码逻辑，但是没有修改注释，就会导致注释无法跟随代码前进的
脚步，误导后续开发者。因此，任何对代码的修改，都应该同时修改注释。
3.3.2 注释格式
注释格式主要分为两种一种是Javadoc 规范，另一种是简单注释。
I Javadoc -1』／
类、类属性和类方法的注释必须遵循Javadoc 规范，使用文档注释（／＊＊＊／）的格式。
按Javadoc 规范编写的注释，可以生成规范的JavaAPI 文档，为外部用户提供非常有
效的文档支持。而且在使用IDE 工具编码时， IDE 会自动提示所用到的类、方法等注
释，提高了编码的效率。
这里要特别强调对枚举的注释是必需的。有人觉得枚举通常带了String name 属
性，已经简要地说明了这个枚举属性值的意思，此时注释是多余的。其实不然，因为a
I l ,x 样仨仑木叮计、J ’， t l:l'J ，（.九d视力J 捷足如果它的定义和使用出现错误，
通常影响较大。
( 2 ) / j~ ] 1T :t-· f 户1、←何军F 句， a 值'tJ ,1- 义，边’ ＇ j ＂＜－ τ 、立←项II 会？在
如果在原有枚举类上新增或修改一个属性值，还需要加上创建和修改时间，让使用者
零成本地知道这个枚举类的所有意图。
( 3 ）枚举二字：1nJJ1I 静、式者＂＂＂ c炙手吕存护f民共拘F ~： 不可直接删除过时属性，需要
标注为过时，同时注释说明过时的逻辑考虑和业务背景。
2. 1奇！（－ i二丐
包括单行注释和多行注释。特别强调此类注释不允许写在代码后方，必须写在代
码上万， 这是为了避免注释的参差不齐，导致代码版式混乱。双画线注释往往使用在
方法内部， 此时的注释是提供给程序开发者、维护者和关注方法细节的调用者查看的。
因此，注释的作用更应该是画龙点睛的，通常添加在非常必要的地方，例如复杂算法
或需要警示的特殊业务场景等。
才09
仅供二｜｜二商业用途或交流学习使用
第4 章寇进JVM
云开方见日，潮尽炉峰出。揭开只叩的神秘面纱，探寻底层的实现原理。
.
第4 章走进JVM
Java 源代码是怎么被机器识别并执行的呢？答案是Java 虚拟机，即Java Vi1tual
Machi肘，简称口币4。NM 提供商包括Sun 、BEA 、IBM 等。1999 年， Sun 公司发
布了由CIC＋＋ 实现的HotSpot Java 虚拟机。2006 年，在JavaOne 大会上开源了其相
关核心技术， 启动OpenJDK 项目，逐步形成了活跃的OpenJDK 社区。2010 年， Sun
公司被Oracle 公司收购。Oracle 的HotSpot NM 实现， 是目前OpenJDK 使用的主流
NM ， 它采用解释与编译混合执行的模式， 其JIT 技术采用分层编译， 极大地提升了
Java 的执行速度； BEA 的JRockit 在2008 年被并入HotSpot; IBM 的19 也在2017 年
开源，形成了现在的OpenJ9 社区。
随着互联网的蓬勃发展及AI 时代的到来， Java 在这些计算领域占据着越来越重
要的地位。目前越来越多的高科技公司， 比如阿里、谷歌、亚马逊等， 都有独立的
NM 团队基于OpenJDK 开发自己的定制版本。阿里拥有丰富的Java 应用场景， 覆盖
云计算、金融、物流、电商等众多领域， 需要解决高并发、高可用、分布式的复合问
题。AlibabaJDK ， 简称AJDK ， 作为阿里Java 体系的基石， 支撑了阿里经济体内所有
的Java 业务。AJDK 力求在复杂的技术环境下， 满足阿里经济体快速发展的业务需求，
并历经了多次双十一的考验。AJDK 突破了多个技术难点，比如多租户JVM 、Wisp
协程技术、大数据场景的Ze nGC 等。
本章从字节码说起5 分析类力日载的过程，并结合内存布局，讲解对象创建与垃圾
回收等各个知识点。
4. 丁字节码
第l 章己介绍0 与l 是计算机仅能识别的信号， 经过0 与l 的不同组合产生了数
字之上的操作。另外， 通过不同的组合亦产生了各种字符。同样， 可以通过不同的组
合产生不同的机器指令。在不同的时代， 不同的厂商， 机器指令组成的集合是不同的。
但毕竟CPU 是底层基础硬件， 指令集通常以扩展兼窑的方式向前不断演进。而机器
码是离CPU 指令集最近的编码， 是CPU 可以直接解读的指令， 因此机器码肯定是与
底层硬件系统辑合的。
如果某个程序因为不同的硬件平台需要编写多套代码， 这是十分令人崩溃的。
Java 的使命就是一次编写、到处执行。在不同操作系统、不同硬件平台上， 均可以
不用修改代码即可顺畅地执行， 如f可实现跨平台？有一个声音在天空中回响。计算机
？什
码出高效Java 开发手册
工程领域的任何问题都可以通过增加个中间层来解决。因此，中间码应运而生，即
“字节码” ( Bytecode ）。Java 所有的指令有200 个左右，一个字节（ 8 位）可以存
储256 种不同的指令信息，一个这样的字节称为字节码（ Bytecode ）。在代码的执行
过程中， NM 将字节码解释执行，屏蔽对底层操作系统的依赖l NM 也可以将字节
码编译执行，如果是热点代码，会通过刀T 动态地编译为机器码，提高执行效率。如
图4-1 所示，十六进制表示的二进制流通常是一个操作指令。起始的4 个字节非常特殊，
即绿色框的cafe babe 是Gosling 定义的个魔法数，意思是Coffee Baby ，其十进制
值为3405691582。它的作用是标志该文件是一个Java 类文件，如果没有识别到该
标志，说明该文件不是Java 类文件或者文件已受损，无法进行加载。而红色框代表
当前版本号， Ox37 的十进制为55 ，是JDKI l 的内部版本号。
|
0010 00ll 0800 120a 0013 0014 0700 1507 I
0016 0100 063c 696e 6974 3e01 0003 2829 I
5601 0004 436f 6465 0100 0f4c 696e 654e I
756d 6265 7254 6162 6c65 0100 046d 6169 I
6e01 0016 285b 4c6a 6176 612f 6c61 6e67 I
2f53 7472 696e 673b 2956 0100 0a53 6f75 I
7263 6546 696c 6501 0014 4865 6c6c 6f57 I
6f72 6c64 4a64 6b31 312e 6a61 7661 0c00 I
5）也阳图
4-1
类
的
二
进
制
字
节
码
纯数字的字节码阅读起来像天书一样难，当初汇编语言为了改进机器语言，使
用助记符来替代对应的数字指令。口叫在字节码上也设计了一套操作码助记符，使
用特殊单词来标记这些数字。如ICONST O 代表0000001 1 ，即十六进制数为Ox03,
ALO AD O 代表00101010 ，即Ox2a; POP 代表01010111 ，即Ox57 。ICONST 和
ALO AD 的首字母表示具体的数据类型，如A 代表引用类型变量， I 代表int 类型相关
操作，其他类型均是其类型的首字母，例如FLOAD 0 、LLOAD 0 、FCONST O 等。
字节码主要指令如下。
I. 加载或存储指令
在某个枝帧中，通过指令操作数据在虚拟机枪的局部变量表与操作楼之间来回传
输，常见指令如下。
( I ）将局部主｛＇~加载圣！｜伊作检中。如ILOAD （将int 类型的局部变量压入桔）
和ALOAD （将对象引用的局部变量压入校）等。
( 2 ）从操作枝顶存储副局副交e表。如ISTO阻、ASTO阳等。
1 才2
第4 章走进JVM
( 3 ）将常？力日苦和j 操作砖顶，这是极为高频使用的指令。如ICONST,
BIPUSH 、SIPUSH 、LDC 等。
•ICONST 加载的是1 ～ 5 的数（！CONST 与BIPUSH 的加载界限）。
• BIPUSH ，即Byte Immediate PUSH ，加载128 ～ 127 之间的数。
• SIPUSH ，即Short Immediate PUSH ，加载32768 ～ 32767 之间的数。
•LDC ，即Load Constant ，在一2147483648 ～ 2147483647 或者是字符串时，
只币4 采用LDC 指令压入枝中。
> nt a = －~.
111t b = I.
int e = '.!0000
int f 二」0000.
int t = 4UUUll
2. 运聋捐令
‘二S
Birt•SH 2 / 在1 至3 之列的主立斗斗士用日！ Pl'SH 指令加我
J ［•＼吁： 1 !, J'I接使用ICO\ST IJ!l 泣的最小值
l< f 气、r l
、H ~rn on
I. k 』oar
对两个操作枝帧上的值进行运算，并把结果写入操作楼顶，如IADD 、IMUL 等。
3. 类型转换捐圣
显式转换两种不同的数值类型。如I2L 、D2F 等。
4. 'I. .. 象仓I建与T 【口1 ’斗令
根据类进行对象的创建、初始化、方法调用相关指令，常见指令如下
( I ｝创建对象fft 令。如NEW 、NEWARRAY 等。
( 2 ｝的｜司属性指令如GETF!ELD 、PUTFIELD 、GETSTATIC 等。
( 3 ｝检查实例类别指令。如INSTANCEOF, CHECKCAST 等。
5. 蝶结格管理沪’令
NM 提供了直接控制操作桔的指令，常见指令如下·
( I ）出桂操作。如POP 即个元素， POP2 即两个元素。
( 2 ｝复制技顶兀系并压八峰， 如DUP 。
113
码出高效· Ja v a 开发手册
6. 鸟、俨可用－ z 「」喝令
常见指令如下
( I ) INVOKEYIRTUAL 指令调用对象的实例方法。
( 2) INVOKESPECIAL ’,; A 调用实例初始化方法、私有方法、父类方法等。
( 3 ) 11\IVOKEST八TIC L『f 调用类静态方法。
( 4 ) RETURN lB 令返回VOID 类型。
7. r. 4 ±~令
NM 使用方法结构中的ACC SYN C HRONIZ E D 标志同步方法， 指令集中有
MONITORENTER 和MONJTOREXIT 支持synchronize d 语义。
除字节码指令外， 还包含一些额外信息。例如， LINEN UMBER 存储了字
节码与源码行号的对应关系， 方便调试的时候正确地定位到代码的所在行i
LOCAL VARIABLE 存储当前方法中使用到的局部变量表。
我们编写好的.java 文件是源代码文件，并不能交给机器直接执行， 需要将其编
译成为字节码甚至是机器码文件。那么静态编译器如何把源码转化成字节码呢？如图
4-2 所示。
＠蒂固t o k en ）庇圆圆圆＠·
赋值语句
百t x = (y+ 7)*z;
变量x = 表达式
表达式女
变量： y + 整数： 7
图4-2 源码转化成字节码的过程
词法解析是通过空格分隔出单词、操作符、控制符等信息， 将其形成token 信息流，
传递给语法解析器，在语法解析时，把词法解析得到的token 信息流按照Java 语法规
则组装成一棵语法树， 如图4-2 虚线框所示；在语义分析阶段， 需要检查关键字的使
才才4
仅供叶商业用途或交流学习使用
第4 章走进J VM
用是否合理、类型是否匹配、作用域是否正确等；当语义分析完成之后，即可生成字
节码。
字节码必须通过类加载过程加载到JVM 环境后，才可以执行。执行有三种模式
第一，解释执行，第二， JIT 编译执行第三， JIT 编译与解释混合执行（主流JVM
默认执行模式）。混合执行模式的优势在于解释器在启动时先解释执行，省去编译时间。
随着时间推进， JVM 通过热点代码统计分析， 识另l j 高频的方法调用、循环体、公共
模块等，基于强大的JlT 动态编译技术，将热点代码转换成机器码，直接交给CPU
执行。JIT 的作用是将Java 字节码动态地编译成可以直接发送给处理器指令执行的机
器码。简要流程如图4-3 所示。
↓方法调用
方法调用计数器加1
方法返回
罔4-3 即时编译流程
注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承
受的负载要大于冷机状态（同lj 启动时），如果以热机状态时的流量进行切流， 可能使
处于冷机状态的服务器因无法承载流量而假死。在生产环境发布过程中，以分批的方
式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的
1 /8 。曾经有这样的故障案例某程序员在发布平台进行分批发布，在输入发布总批
数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强
承载流量， 但由于刚启动的JVM 均是解释执行， 还没有进行热点代码统计和JIT 动
态编译，导致机器启动之后， 当前l/2 发布成功的服务器马上全部看机，此故障说明
了JIT 的存在。
115
仅供＃商业用途或交流学习使用
码出高效Java 开发手册
4.2 类加载过程
在冯. i若依曼定义的计算机模型中，任何程序都需要加载到内存才能与CPU 进
行交流。字节码. class 文件同样需要加载到内存中，才可以实例化类。“兵马未动，
粮草先行。” C lassLoad巳r 正是准备粮草的先行军，它的使命就是提前加载.class 类文
件到内存中。在加载类时，使用的是Parents Delegation Model ，译为双亲委派模型，
这个译名有些不妥。如果意译的话， 则译作“ 溯源委派加载模型”更加贴切。
Java 的类加载器是一个运行时核心基础设施模块，如图4-4 所示，主要是在启动
之初进行类的Load 、L ink 和Init ， 即加载、链接、初始化。
第一步， Load 阶段读取类文件产生二进制流，并转化为特定的数据结构，初步
校验cafe babe 魔法数、常量池、文件长度、是否有父类等，然后创建对应类的java.
Jang.Class 实例。
第二步， Link 阶段包括验证、准备、解析三个步骤。验证是更详细的校验，比
如fi nal 是否合规、类型是否正确、静态变量是否合理等i 准备阶段是为静态变量分
配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存
结构布局。
第三步， Init 阶段执行类构造器＜clinit> 方法，如果赋值运算是通过其他类的静
态方法来完成的，那么会马上解析另外个类，在虚拟机枪中执行完毕后通过返回值
进行赋值。
1116
-
－噩噩噩．
E噩噩噩画E ~
-
-
－固
图4-4 Java 类加载过程
仅供－II＇商业flli主或交流学习使用
第4 章走进JVM
类加载是一个将. class 字节码文件实例化成Class 对象并进行相关初始化的过程。
在这个过程中， JVM 会初始化继承树上还没有被初始化过的所有父类，并且会执行
这个链路上所有未执行过的静态代码块、静态变量赋值语旬等。某些类在使用时，也
可以按需由类加载器进行加载。
全小写的class 是关键字，用来定义类，而首字母大写的Class ，它是所有c lass 的类。
这旬话理解起来有难度，是因为类已经是现实世界中某种事物的抽象，为什么这个抽
象还是另外个类C lass 的对象？示例代码如下
public class ClassTest {
／／我rP 委型有－ 1、气、I P 性： length ·K. 作取欲绵长度
private static int [) array= new int ( 3 ) ;
private static int length = array . length;
／／任何小写class ，主义的专， 仇有i l制，沙．喝性： class. :r; JPi'Z.1吃完的大巧Class '(Jr'\'
private static Class<One> one = O 口e . class ;
private static Class<Another> another = Another. class ;
public static void main(String[) args) throws Exception {
／／拖过new In.st ar.ce 廿丢人＇I 巧One 和Anotheγt ~ ;{ ~－－ （第1 处）
One oneObject = o 口e .n ewinstance ();
one Ob ] ect.call();
Another anotherObject = another . newinstance();
anotherObject . speak() ;
／／通过one ；~个人与均Class 对象， 我取材、有成r;l ＇.＇.闪，：.j ~：、巳院ld （第2 处）
Field privateFieldinOne = one . getDeclaredF工eld （ ” L 口ner " );
I I ＆－＂＂－私有什句’到『、~ ~ 1"1 , 叶（第3 处）
privateFieldinOne . setAccessible( true);
privateFieldI 口One.set(oneObject ， ”： world changed . ” );
／／成功修改飞的私11 K'f， 性inner 变］I; f庄子j world 噜hanged .
System .out. println(oneObject .getinner());
class One {
private String inner = ” time flies .”;
public v oid call() {
System . out.println ( ” hello world . ” );
1 才7 1
仅供＃商业用途或交流学习使用
码出高效： Java 开发手册
public String getlnner() {
return inner;
class Another {
public void speak() {
System.out.print ln ( ” f asy cod 工ng. ” ）；
执行结果如下，
hello wor l d .
easy coding.
world change d .
1 才8
·第l 处说明Class 类下的newInstance（） 在JDK9 中已经置为过时，使用
getD巳claredConstructor().newlnstance（）的方式。这里着重说明一下new 与
new Instance 的区另lj 。new 是强类型校验， 可以调用任何构造方法， 在使用
new 操作的时候，这个类可以没有被加载过。而C lass 类下的newInstance
是弱类型，只能调用无参数构造方法，如果没有默认构造方法，就抛
出InstantiationException 异常，如果此构造方法没有权限访问，贝lj 抛出
IllegalAccessException 异常。Java 通过类加载器把类的实现与类的定义进行
解辑，所以是实现面向接口编程、依赖倒置的必然选择。
· 第2 处说明I 可以使用类似的方式获取其他声明， 如注解、方法等，如图4-5
所示。
Search for: 肘tOectared ‘ 因远~
Inherit回memb盯｛吓3) 阳回叮moos Classes !XI) Lambdas （提L)
。但~nnotation(Cla阳A>): A ↑ Ann。tatedElement
⑦ ~nnotations(): Annotation[] ~灿oo : at'Jd[I•卉。盯
~ ~弘nnotationsByType(Class<A> ): A［］ 个f气旧1。飞c.:•;dE•ι画，，、5 『
。巴~lasses(): Class ＜？＞口
。自~。nstructor(Class<?> ... ): Constructor<T>
。自~onstructors(): C。nstructor<?>(]
0 ~ield(String): Field
。陀~ields(): Field(]
。陀mmm:卧.iet「、由d(SI忖ir守
。陀~et「、。ds(): Meth。d[]
图4-5 类的反射信息
仅供自商业用诠或交流学习使用
第4 章走进JVM
· 第3 处说明： private 成员在类外是否可以修改？通过setAccessible(true） 操作，
即可使用大写C l ass 类的set 方法修改其值。如果没有这一步，贝iJ 抛出如下异常
Exception in thread ” main" lllegalAccessException: class ClassTest cannot access a
member of class com.alibaba.easy.coding.classloader.One with modifiers "private” at base/
jdlιinternal . reflect.Reflection. new I I lega IA ccessException( Reflection .java: 3 52)
通过以上示例，对于C l ass 这个“类中之王”，不会有恐惧心理了吧？那么回到
类加载中，类加载器是如何定位到具体的类文件并读取的呢？
类力口载器类似于原始部落结构， 存在权力等级制度。最高的层是家族中威望最
高的Bootstrap ， 它是在NM 启动时创建的， 通常由与操作系统相关的本地代码实现，
是最根基的类加载器，负责装载最核心的Java 类， 比如0均ect 、System 、String 等；
第二层是在JDK9 版本中，称为Platform ClassLoader ，即平台类加载器， 用以加载一
些扩展的系统类，比如XML ，加密、压缩相关的功能类等，而K9 之前的加载器是
Extension ClassLoader ：，第三层是App li cation ClassLoader 的应用类加载器，主要是加
载用户定义的CLASS PATH 路径下的类。第二、三层类加载器为Java 语言实现，用
户也可以自定义类加载器。查看本地类加载器的方式如下。
~
ClassLoader c = Te stWho Load . class . getClassLoader() ;
’/
ClassLoader c l= c.getParent( );
ClassLoader c2 = cl . getParent() ;
代， 码上方的注释内容为JD Kl l 的执行结果。在JDK8 环境中，执行结果如下·
sun .m 1sc .Launcher\$Ap pCla ssLoader@ l 4dad5dc
sun.mi sc. La uncher\$ExtClass Loader@6eO be85 8
null
AppClassLoader 的Parent 为Bootstrap ， 它是通过CIC ＋＋ 实现的，并不存在于
NM 体系内，所以输出为null ， 类加载器具有等级制度， 但是并非继承关系， 以组合
的方式来复用父加载器的功能，这也符合组合优先原则，详细的双亲委派模型如图4- 6
所示。
才19
仅供－11， 商业用途或交流学习使用
nYi 出高效Java 开发手册
IENH
一一一一一’
回圃噩噩
- 每一’
m噩噩噩噩噩噩盟盟E －噩噩圈圈
．噩噩噩噩－
图4-6 双亲委派模型
低层次的当前类加载器，不能覆盖更高层次类加载器已经加载的类。如果低层次
的类加载器想加载一个未知类，要非常礼貌地向上逐级询问：“ 请问，这个类已经加
载了吗？ ” 被询问的高层次类加载器会自问两个问题，第一，我是否已加载过此类？
第二，如果没有，是否可以加载此类？只有当所有高层次类加载器在两个问题上的答
案均为“否”时，才可以让当前类加载器加载这个未知类。如图4 -6 所示，左侧绿色
箭头向上逐级询问是否已加载此类，直至Bootstrap ClassLoader ，然后向下逐级尝试
是否能够加载此类，如果都加载不了，贝lj 通知发起加载请求的当前类加载器， ；住予力口
载。在右侧的三个小标签里，歹lj 举了此层类加载器主要加载的代表性类库， 事实上不
止于此。通过如下代码可以查看Bootstrap 所有已经加载的类库：
URL [] urLs = sun. misc . Launcher. getBootstrapClassPath () . getURLs () ;
for (java. 口et . URL url : urLs) {
System . out . println(url.toExternalForm()) ;
执行结果如下
才20
仅供＃商业用途或交流学习使用
第4 章走进JVM
fi le:/Li brarγ11 avail a va Vi rl ua!Machines/jrlk 11/Conle nts/Home/jre/lib/rt.jar
file:/Library/J ava/Ja va Vi rlualM achines/j rlk 11/Conle nts/Home/jre/lih/ resources.jar·
fi le:/Library/Java/Java Vi rtuaJMachi nes/jrlk 11 /Contents/Home/j re/Ii h/sunrsasign.ja.i
file:/L ihra.i·y/Java/J a va Vi rl ual Mac hi nes/jdkl l /Co nle n ts/H o me/j r代/l i b/j sse .j a.i·
fi le:/Librar·y/Java/J ava Vi rl.ua!Mach ines/jrlk 1 1/Co nte n ts/H o me/jre/l 川、／j ce .j a r
「ii e:/Library/J ava/J ava Virtual Machi nes/jdk 11/Contents/Home/j re/li h/c harsel s.jar
fi le:/Li brary/J ava/J ava Virt ual Machi nes/jdk 11 /Contents/Home/j re/Ii b/j fr.jar
fi le:/Library/J ava/J ava Virl ua !Mach ines/jrl k 11/Conte nts/Home/jre/c lasses
Bootstrap 加载的路径可以追加， 不建议修改或删除原有加载路径。在川岛4 中增
加如下启动参数， 则能通过Class.forName 正常读取到指定类， 说明此参数可以增加
Bootstrap 的类加载路径
- Xbootclasspath/a : /Users/yangguanbao/book/easyCoding/byJdkl l/ src
如果想在启动时观察加载了哪个j缸包中的哪个类， 可以增加Jα：＋Tra臼ClassLoading
参数， 此参数在解决类冲突时非常实用， 毕竟不同的JVM 环境对于加载类的顺序并
非是一致的。有时想观察特定类的加载上下文， 由于加载的类数量众多，调试时很难
捕捉到指定类的加载过程， 这时可以使用条件断点功能。比如， 想查看HashMap 的
加载过程， 在loadClass 处打个断点， 并且在condition 框内输入如图4”7 所示条件。
图4-7 条件断点的设置
在学习了类加载器的实现机制后， 知道双亲委派模型并非强制模型， 用户可以自
定义类加载器， 在什么情况下需要自定义类加载器呢？
( I ）「离切草二是。在某些框架内进行中间件与应用的模块隔离， 把类加载到不
同的环境。比如， 阿里内某容器框架通过自定义类加载器确保应用中依赖的jar 包不
会影响到中间件运行时使用的jar 包。
( 2 ) tt.a.立夹旧式千戈。类的加载模型并非强制， 除Bootstrap 外， 其他的加载并
非定要引入， 或者根据实际情况在某个时间点进行按需进行动态加载。
才21
仅供＃商业用途或交流学习使用
码出高效： Java 开发手册
( 3 ）扩展加载源。比如从数据库、网络，甚至是电视机机顶盒进行加载。
( 4 ）防止源码泄露。Java 代码容易被编译和篡改，可以进行编译加密。那么类
加载器也需要自定义，还原力口密的字节码。
实现自定义类加载器的步骤继承C l assLoader ，重写findClass（）方法，调用
defineC lass（） 方法。一个简单的类加载器实现的示例代码如下
public class CustomClassLoader extends ClassLoader {
自Ov erride
protected Class<?> findClass(String name) throws
ClassNotFoundExce ptio n {
try {
byte (] result = getClas sFromCustomPath(name);
if (result == null) {
thr。w new FileNotFoundException();
) else {
return def 工neClass(nam e , result , 0 , result.length) ;
) catch (Exception e) {
e . printSta ckTrace();
throw new ClassNotFoundException( name);
private byte (] getClassFromCustomPath(String name) {
／／从r1 定义踪往中如我指定类
public static void main(String[] args) {
CustomClassLoader customClassLoader = new CustomClassLoader();
try {
Class <?> clazz = C lass.forName （ ”、＞ r ＇＂” ， true , customClas sLoader);
Object obj = clazz . newinstance() ;
System . out. println (obj . getClas s () . getClassLoader () ) ;
) catch (Exception e) {
e . printStackTrace ();
执行结果如下
classloader . CustomClassLoader@Se481248
I 122
仅供＃商业用途或交流学习使用
仅供＃商业用途或交流学习使用
第4 章走进J VM
由于中间件一般都有自己的依赖jar 包，在同个工程内引用多个框架时， 往往
被迫进行类的仲裁。按某种规则jar 包的版本被统←指定，导致某些类存在包路径、
类名相同的情况， 就会引起类冲突，导致应用程序出现异常。主流的容器类框架都会
自定义类加载器，实现不同中间件之间的类隔离， 有效避免了类冲突。
4.3 内存布局
内存是非常重要的系统资源， 是硬盘和CPU 的中间仓库及桥梁， 承载着操作系统和
应用程序的实时运行。NM 内存布局规定了Java 在运行过程中内存申请、分配、管理的
策略，保证了只币4 的高效稳定运行。不同的NM 对于内存的划分方式和管理机制存在
着部分差异。结合只叫虚拟机规范， 来探讨一下经典的NM 内存布局， 如图4-8 所示。
-
CJu
-
-
Lun
-
-
CE
-
aE
j
一刊揣一
-
OUJJE
－h 方－
一何地一
一州本－
-
e
-
d
i-
－ vi 、－
-J<J
d
-
－ M川－
I p 「og 「am Counter Registe 「
l （程序计数器） :
Eden SO S1
Young区（新生代）
Old区
（老年代）
图4-8 经典的JVM 内存布局
l. Heap （堆区）
Heap 是OOM 故障最主要的发源地， 它存储着几乎所有的实例对象， 堆由垃圾
收集器自动回收， 堆区由各子线程共享使用。通常情况下， 它占用的空间是所有内存
区域中最大的，但如果无节制地创建大量对象，也窑易消耗完所有的空间。堆的内存
空间既可以固定大小， 也可以在运行时动态地调整，通过如下参数设定初始值和最大
值，比如－Xms256M -Xmxl024M ，其中－X 表示它是JVM 运行参数， ms 是memory
start 的简称， mx 是memory max 的简称，分别代表最小堆窑量和最大堆窑量。但是
在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的
系统压力， 所以在线上生产环境中， JVM 的Xms 和Xmx 设置成样大小，避免在
GC 后调整堆大小时带来的额外压力。
才23
仅供＃商业用途或交流学习使用
仅供非商业用途或交流学习使用
码出高效· J ava 开发手册
堆分成两大块新生代和老年代。对象产生之初在新生代， 步入暮年时进入老年
代， 但是老年代也接纳在新生代无法容纳的超大对象。新生代＝ 1 个Eden 区＋ 2 个
Survivor 区。绝大部分对象在Eden 区生成， 当Eden 区装填满的时候， 会触发Young
Garbage Collection ， 即YGC。垃圾回收的时候， 在Eden 区实现清除策略， 没有被引
用的对象则直接回收。依然存活的对象会被移送到Survivor 区， 这个区真是名副其
实的存在。Survivor 区分为so 和Sl 两块内存空间， 送到哪块空间呢？每次YGC 的
时候， 它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完
全清除， 交换两块空间的使用状态。如果YGC 要移送的对象大于Survivor 区容量的
上限，贝lj 直接移交给老年代。假如一些没有进取心的对象以为可以一直在新生代的
Survivor 区交换来交换去，那就错了。每个对象都有一个计数器，每次YGC 都会加
l 。－XX:MaxTenuringThreshold 参数能配置计数器的值到达某个阐值的时候， 对象从
新生代晋升至老年代。如果该参数配置为I ，那么从新生代的Eden 区直接移至老年代。
默认值是15 ， 可以在Survivor 区交换14 次之后， 晋升至老年代。与图4- 8 匹配的对
象晋升流程图如图4-9 所示。
吁P
否
:
在巨
〈互〉
图4-9 对象分配与简要GC 流程图
才24
仅供非商业用途或交流学习使用
仅供」I＇商业用途或交流学习使用
第4 章走进J V M
图的中，如果Survivor 区无法放下，或者超大对象的闹值超过上限，贝lj 尝试
在老年代中进行分配； 如果老年代也无法放下，贝lj 会触发Full Garbage Collection ， 即
FGC 。如果依然无法放下， 则抛出OOM 。堆内存出现OOM 的概率是所有内存耗尽
异常中最高的。出错时的堆内信息对解决问题非常有帮助， 所以给NM 设置运行参
数－XX:+HeapDumpOnOutOfMemoryError ，让口瓜4 遇到OOM 异常时能输出堆内信息，
特别是对相隔数月才出现的OOM 异常尤为重要。
在不同的NM 实现及不同的回收机制中， 堆内存的划分方式是不一样的。
2. Metaspace （元空｝苟）
本书源码解析和示例代码基本采用JDKll 版本， NM 则为Hotspot 。早在JDK8
版本中，无空间的前身Perm 区已经被淘汰。在JDK7 及之前的版本中，只有Hots pot
才有Perm 区，译为永久代， 它在启动时固定大小，很难进行调优，并且FGC 时会移
动类无信息。在某些场景下，如果动态加载类过多，容易产生Pe rm 区的OOM 。比
如某个实际We b 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多
的类，经常出现致命错误。
“ εxception in thread 'dubbo client x.x connector ' java.lang.OutO 阳emoryE口or : PennGen
space
为了解决该问题， 需要设定运行参数－XX: MaxPermSize= 1280m ，如果部署到
新机器上，往往会因为NM 参数没有修改导致故障再现。不熟悉此应用的人排查
问题时往往苦不堪言，除此之外，永久代在垃圾回收过程中还存在诸多问题。所
以， JDK8 使用元空间替换永久代。在JDK8 及以上版本中，设定MaxPermSize 参
数， NM 在启动时并不会报锚，但是会提示： Java HotSpot 64Bit Server VM warning:
ignoring option MaxPem1Size=2560m; support was removed i11 8.0 。
区别于永久代， 元空间在本地内存中分配。在JDK8 里， Pe rm 区中的所有内容
中字符串常量移至堆内存，其他内容包括类元信息、字段、静态属性、方法、常量等
都移动至无空间内，比如图4-10 中的0均ect 类元信息、静态属性System.out 、整型
常量10000000 等。图4-10 中显示在常量池中的S trir毡， 其实际对象是被保存在堆内
存中的。
才25
仅供ll0 i商业用途或交流学习使用
码出高效： Java 开发手册
图4-10 常量池
3. JVM Stack ( h生m， 斗几件）
枝（ Stack ）是－个先进后出的数据结构， 就像子弹的弹夹， 最后压入的子弹先发射，
压在底部的子弹最后发射， 撞针只能访问位于顶部的那一颗子弹。
相对于基于寄存器的运行环境来说，口币4 是基于枝结构的运行环境。枝结构移
植性更好， 可控性更强。口叫中的虚拟机枪是描述Java 方法执行的内存区域，它是
线程私有的。楼中的元素用于支持虚拟机进行方法调用， 每个方法从开始调用到执行
完成的过程， 就是枝帧从入枝到出柱的过程。在活动线程中， 只有位于枝顶的帧才是
有效的， 称为当前枝帧。正在执行的方法称为当前方法， 校帧是方法运行的基本结构。
在执行引擎运行时， 所有指令都只能针对当前枝帧进行操作。而StackOverflowError
表示请求的枝溢出， 导致内存耗尽， 通常出现在递归方法中。NM 能够横扫干军，
虚拟机枪就是它的心腹大将， 当前方法的枝帧， 都是正在战斗的战场， 其中的操作枝
是参与战斗的士兵。操作校的压枝与出枝如图4-11 所示。
压钱出钱
局部变量表操作核动态连接方法返回地址
图4-1 l 操作战的压找与出战
I 126
仅供非商业用途或交流学习使用
第4 章走进JVM
虚拟机枪通过压枝和出桔的方式，对每个方法对应的活动枝帧进行运算处理，方
法正常执行结束，肯定会跳转到另一个桔帧上。在执行的过程中，如果出现异常，会
进行异常回溯，返回地址通过异常处理表确定。桔帧在整个JVM 体系中的地位颇高，
包括局部变量表、操作枝、动态连接、方法返回地址等。
I 自一以
局部变量表是存放方法参数和局部变量的区域。相对于类属性变量的准备阶段和
初始化阶段来说，局部变量没有准备阶段，必须显式初始化。如果是非静态方法，贝lj
在index [O］ 位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量。
字节码指令中的STORE 指令就是将操作枝申计算完成的局部变量写回局部变量表的
存储空间内。
( 2 ）去作非
操作枝是一个初始状态为空的桶式结构枝。在方法执行过程中，会有各种指令往
枝中写人和提取信息。JVM 的执行引擎是基于桔的执行51 擎，其中的枝指的就是操
作枝。字节码指令集的定义都是基于桔类型的，桔的深度在方法元信息的stack 属性中，
下面用一段简单的代码说明操作桔与局部变量表的交互：
public i nt simpleMethod() {
int x = 13 ;
int y = 14 ;
int z = x + y ;
return z;
详细的字节码操作顺序如下·
public simpleMethod() ;
descriptor : () I
flags : ACC PUBLIC
Code :
stack ＝ ι ， locals= , args_Size= //
BI PUSH 牛可
ISTORE 1 , －＇ τ ＇·｛ ’；~ \ .• i b iυt
BIPUSH l 位
ISTORE 2
/
/
., I >t; fd
牛r t L
（ 第1 处）
ILOAD 1 ／／护4 ，叩'J ~＇ 口111;].(irr>l 陀人粟作性
仅供＇II＇商业用途或交流学习佼用
~ l
才27
码出高效： Ja va 开发手册
ILOAD 2
工ADD
ISTORE 3
ILOA D 3
I RETURN 11 V·王： J t\'. :{ 7'".
v ）压入.； t各
札－ r－ . 玲，王u ；；.＇于校的马－
，..，.飞
第l 处说明局部变量表就像－个中药柜， 里面有很多抽屉， 依次编号为0, 1 , 2,
3, , n ， 字节码指令ISTORE l 就是打开I 号抽屉， 把枝顶中的数1 3 存进去。枝
是一个很深的竖桶， 任何时候只能对桶口元素进行操作， 所以数据只能在楼顶进行存
取。某些指令可以直接在抽屉里进行， 比如i i n c 指令， 直接对抽屉里的数值进行＋ l
操作。程序员面试过程中， 常见的i ＋＋和＋＋ i 的区别， 可以从字节码上对比出来， 如
表4-1 所示。
表4-1 i ＋ ＋ 和＋刊的区别
a=1++ a=++1
0 : il oad I 0: iinc I . I
l. 1111c I, I 3: iload I
4 : 1store 2 4: 1store 2
在表4-1 左列中， il oad l 从局部变量表的第l 号抽屉里取出一个数，压入枝I页，
下一步直接在抽屉里实现＋ l 的操作， 而这个操作对枝顶元素的值没有影响。所以
istore 2 只是把枝顶元素赋值给a ，表格右列， 先在第l 号；由屉里执行＋ l 操作， 然
后通过il oa d l 把第1 号抽屉里的数压人枝顶， 所以i sto re 2 存人的是＋ 1 之后的值。
这里延伸一个信息， i ＋＋并非原子操作。即使通过vo l ati l e 关键字进行修饰， 多
个线程同时写的话， 也会产生数据互相覆盖的问题。
( 3 ）动态连接
每个枝帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的
动态连接。
4 ）方r云返B 地址
方法执行时有两种退出情况第， 正常退出，即正常执行到任何方法的返回字
节码指令， 如阻TURN 、I RETURN 、ARETURN 等，第二， 异常退出。无论何种退
出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前枝帧，
128
仅供｜非商业用途或交流学习使用
退出可能有三种方式
·返回值压入上层调用枝帧。
·异常信息抛给能够处理的枪帧。
•PC 计数器指向方法调用后的下一条指令。
4. Native Method Stacks （本地方法枝）
第4 章走进JVM
本地方法桔（ Native Method Stack ）在JVM 内存布局中， 也是结程对象私有的，
但是虚拟机桔“主内”， 而本地方法枝“主外”。这个“内外”是针对JVM 来说的，
本地方法枝为Native 方法服务。线程开始调用本地方法时，会进入一个不再受JVM
约束的世界。本地方法可以通过JNI ( Java Native Int巳rface ）来访问虚拟机运行时的
数据区，甚至可以调用寄存器，具有和JVM 相同的能力和权限。当大量本地方法出
现时， 势必会削弱口币4 对系统的控制力，因为它的出错信息都比较黑盒。对于内存
不足的情况， 本地方法枝还是会抛出native heap OutOfMemory 。
重点说一下JNI 类本地方法， 最著名的本地方法应该是System.
currentTimeMillis() , JNI 使Java 深度使用操作系统的特性功能，复用非Java 代码。
但是在项目过程中， 如果大量使用其他语言来实现JNI ， 就会丧失跨平台特性， 威胁
到程序运行的稳定性。假如需要与本地代码交互，就可以用中间标准框架进行解辑，
这样即使本地方法崩溃也不至于影响到只鸣4 的稳定。当然， 如果要求极高的执行效率、
偏底层的跨进程操作等，可以考虑设计为JNI 调用方式。
5. Program Counter Register （王军I芋计数寄存器）
在程序计数寄存器（ Program Counter Register, PC ）中， Register 的命名源于
CPU 的寄存器， CPU 只有把数据装载到寄存器才能够运行。寄存器存储指令相关的
现场信息，由于CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的
时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生
自己的程序计数器和枝帧，程序计数器用来存放执行指令的偏移量和行号指示器等，
线程执行或恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域
也不会发生内存溢出异常。
最后， 从线程共享的角度来看，堆和元空间是所有线程共享的，而虚拟机枝、本
地方法枝、程序计数器是线程内部私有的，从这个角度看下Java 内存结构，如图4-12
所示。
129
仅供二｜｜二商业用途或交流学习使用
码出高效， Java 开发手册
….... ...…
圄固
~回国噩噩’
－固噩噩噩－ E噩噩~
图4-12 Java 的线程与内存
4.4 对象实例化
Java 是面向对象的静态强类型语言，声明并创建对象的代码很常见，根据某个类
声明一个引用变量指向被创建的对象，并使用此引用变量操作该对象。在实例化对象
的过程中， JVM 中发生了什么化学反应呢？
( I ）卜面从最简单的Object rer = new Object（）； 代码进行分析， 利用javap
-ve「hose -p 命令查石肘绞创建阶牢士刊刊［下．
stack ＝ 二， locals= , args_size=
NEW java/lang/Obj ect
DUP
130
INVOKESPECIAL ] ava/lang/Object . <init> () V
ASTORE 1
LocalVariableTable :
Start Length Slot Name Signature
8 1 0 ref Ljava/lang/Obj ect ;
•NEW 如果找不到Cl ass 对象， 则进行类加载。加载成功后， 则在堆中分配内存，
从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后， 进
行零值初始化。在分配过程中，注意引用是占据存储空间的， 它是一个变量，
占用4 个字节。这个指令完毕后，将指向实例对象的号｜用变量压入虚拟机楼顶。
第4 章走进JVM
• DUP 。在枝顶复制该引用变量，这时的枝顶有两个指向堆内实例对象的引用
变量。如果＜init> 方法有参数，还需要把参数压人操作枝中。两个引用变量
的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一
个枝顶的引用变量作为旬柄调用相关方法。
• INVOKESPECIAL ：调用对象实例方法，通过楼顶的引用变量调用＜ in it> 方法。
< clinit> 是类初始化时执行的方法， 而＜ init> 是对象初始化时执行的方法。
( 2 ）前面fir 述是从←口U& q 角度君恃对象的G'J 红川，在J , ,.ji 手E 从执行步骤的角k
未分析
· 确认类无信息是否存在。当阿M 接收到new 指令时，首先在metaspace 内检
查需要创建的类元信息是否存在。若不存在，那么在双亲委派模式下， 使用
当前类加载器以C lassLoader＋包名＋类名为Key 进行查找对应的.class 文件。
如果没有找到文件，则抛出C lassNotFoundException 异常，如果找到，则进
行类加载，并生成对应的C lass 类对象。
· 分配对象内存。首先计算对象占用空间大小，如果实例成员变量是引用变
量，仅分配引用变量空间即可，即4 个字节大小，接着在堆中划分一块内存
给新对象。在分配内存空间时，需要进行同步操作，比如果用CA S ( Compare
And Swap ）失败重试、区域加锁等方式保证分配操作的原子性。
· 设定默认值。成员变量值都需要设定为默认值，即各种不同形式的零值。
· 设置对象头。设置新对象的晗希码、GC 信息、锁信息、对象所属的类元信息等。
这个过程的具体设置方式取决于口币4 实现。
· 执行in it 方法。初始化成员变量，执行实例化代码块，调用类的构造方法，
并把堆内对象的首地址赋值给亏｜用变量。
4.5 垃坝回收
Java 会对内存进行自动分配与回收管理，使上层业务更加安全，方便地使用内存
实现程序逻辑。在不同的口爪4 实现及不同的回收机制中，堆内存的划分方式是不一
样的。这里简要介绍垃圾回收（ Garbage Collection, GC ）。垃圾回收的主要目的是
清除不再使用的对象，自动释放内存。
GC 是如何判断对象是否可以被回收的呢？为了判断对象是否存活， JVM 引人了
才31
码出高效· Java 开发手册
GC Roots 。如果个对象与GC Roots 之间没有直接或间接的引用关系，比如某个失
去任何引用的对象，或者两个互相环岛状循环引用的对象等，判决这些对象“死缓”，
是可以被回收的。什么对象可以作为GC Roots 呢？比如类静态属性中引用的对象、
常量引用的对象、虚拟机枝中寻｜ 用的对象、本地方法桔申可｜用的对象等。
有了葬！J 断对象是否存活的标〉佳后，再了解下垃圾固收的丰目关算法。最基础的为
“标记－）青除算法
最后将没有被标记的对象清除。但是这种算法会带来大量的空间碎片’导致需要分配
－个较大连续空间时容易触发F G C 。为了解决这个问题，又提出了“标记一整理算
法＂ ＇该算法类似计算机的碰盘整理，首先会从GC Roots 出发标记存活的对象，然
后将存活对象整理到内存空间的一端，形成连续的已使用空间， 最后把已使用空间之
外的部分全部清理掉， 这样就不会产生空间碎片的问题。
能够并行地标记和整理将空间分为两块，每次只激活其中一块， 垃圾回收时只需把存
活的对象复制到另块未激活空间上，将未激活空间标记为己激活，将己激活空间标
记为未激活，然后清除原空间中的原对象。堆内存空间分为较大的E den 和两块较小
的Survivor ，每次只使用E den 和Surv ivor 区的块。这种情形下的“ Ma rk”Copy ” 减
少了内存空间的浪费。
垃圾回收器（ Garbage Collector ）是实现垃圾回收算法并应用在NM 环境中的内
存管理模块。当前实现的垃圾回收器有数十种，本节只介绍Ser ial 、CMS 、G l 三种。
Serial 回收器是一个主要应用于YGC 的垃圾回收器，采用串行单线程的方式完
成GC 任务，其中“ Stop The World ”简称STW ，即垃圾回收的某个阶段会暂停整个
应用程序的执行。FGC 的时间相对较长，频繁FGC 会严重影响应用程序的性能。主
要流程如图4 -13 所示。
罔4- 1 3 Servial 回收流程
CMS 回收器（ Concurrent Mark Sweep Collector ）是回收停顿时间比较短、目前
比较常用的垃圾回收器。它通过初始标记（ Initial Mark ）、并发标记（ Concurrent
132
第4 章走进J VM
Mark ） 、重新标记（ Remark ） 、并发清除（ Concurrent Sweep ） 四个步骤完成垃圾回
收工作。第1 、3 步的初始标记和重新标记阶段依然会引发STW ，而第二4 步的并
发标记和并发清除两个阶段可以和应用程序并发执行，也是比较耗时的操作， 但并不
影响应用程序的正常执行。由于CMS 采用的是“标记一清除算法” ，因此产生大量
的空间碎片。为了解决这个问题， CMS 可以通过配置－XX :+UseCMSCompactAtFul!Co
llection 参数，强制JVM 在FGC 完成后对老年代进行压缩， 执行一次空间碎片整理，
但是空间碎片整理阶段也会引发STW。为了减少STW 次数， CMS 还可以通过配置一
XX : +CMSFul!GCsBeforeCompaction=n 参数，在执行了n 次FGC 后， JVM 再在老年
代执行空间碎片整理。
Hotspot 在JDK7 中推出了新代G 1 ( Garbage-First Garbage Collector ） 垃圾回收，
通过去X:+UseGIG C 参数启用。和CMS 相比， G I 具备压缩功能， 能避免碎片问题，
GI 的暂停时间更加可控。性能总体还是非常不错的，简要结构如图4-14 所示。
E s E
E 。E
H s 。
Eden
E E s Survivor
。s 。Old
。H Humongous
图4-1 4 G I 回收模型内存布局
GI 将Java 堆空间分割成了若干相同大小的区域，即region ，包括Eden 、
Survivor、Old 、Humongous 四种类型。其中， Humongous 是特殊的Old 类型，专门
放置大型对象。这样的划分方式意昧着不需要一个连续的内存空间管理对象。G I 将
空间分为多个区域，优先回收垃圾最多的区域。GI 采用的是
好的空间整合能力’不会产生大量的空间碎片。G I 的一大优势在于可预测的停顿时间，
能够尽可能快地在指定时间内完成垃圾回收任务。在JDKl l 中，已经将G I 设为默认
垃圾回收器， 通过jstat 命令可以查看垃圾回收情况，如图4- 15 所示，在YGC 时SO/
SI 并不会交换。
才33 1
码出高效Java 开发手册
口马司ei-u马丽aQ@yacggua 币二丽丽豆豆。王再再5元~ 气；； －： gel.: i l h们的30面
I S~ S 1 [ Ci "' C 仁s y巳f YGCT rec FGCT c 巳〔CCCT CCT I
｜ 日．仰自1白可Cc ~.4 白9门巳1 9:;. 10 汀4 口84 C.163 3 C.200 ：巳E 0.122 c. cc2 I
I l. cc 1 日3.C3 r;.25 号扫. i 巳9:0. 79 年1 .. 1] 86 白. 167 日日．白白白: 72 白. 191 白58 I
I 0.30 10 日.co 0.36 Sl.iJ 92./g J4.4J 87 0.16[! 0 0.000 174 日. 193 阳. 1ii1 I
｜ 白白白100. 白白白.41 99.64 93.79 94.43 日自白.169 日自由自由176 日. 194 日361 I
图4-1 5 G I 内存回收情况
SO /SI 的功能由GI 中的S urvivor region 来承载。通过GC 日志可以观察到完整
的垃圾回收过程如下，其中就有S urvivor regions 的区域从0 个歪lj l 个。
[0 .530s][info ][ gc,st缸t J GC(O) Pause Initial Mark (GI Humongous Allocation)
[0.530s][info ][gc, task J GC(O) Using 4 workers of 4 for evacua tion
[0.535 s][info ][gc, heap J GC(O) EdPn n• gion ι 2一＞0(152)
[0.5 35s][info ][gc, heap J GC(O ） 只川、l 飞川r Pg i o n 约： 0 >1(2)
[0 .535 s][info ][gc, heap J GC(O) Olcl n•g ion s: 0->0
[0.535 s][info ][gc, heap ] GC(O) I li1mo11 gn 11剖rPgion s : 115->39
[0 .53 5s][info ][ gc, metaspace J GC(O) Metaspace: 6001K - >6 00LK (J056768K)
红色标识的为GI 中的四种region ， 都处于Heap 中。GI 执行时使用4 个worker
并发执行，在初始标记时，还是会触发S TW ， 如第一步所示的Pause 。
134
第5 章异常与日志
“欲j度黄河冰塞） 11 ，将登太行雪满山。”系统运行，风云不测，睹始知终，
秋去冬来，一叶落而知秋。
码出高效· J ava 开发手册
人类在日常活动中常常会遇到各种各样不可预料的问题，比如为了保证准时乘坐
某一航班，早早赶到了机场，却因忘带身份证件而导致无法登机，或者由于突降大雨
而使航班延迟起飞等都会使得我们的活动受阻。系统工程亦是如此，无论保护措施如
何完善，事前预案如何周密，异常现象或多或少、或早或迟地都会发生。系统发生异
常后，往往需要人工介入处理，否则将会扩大异常影响面，或者引发新的异常。在计
算机世界中， 在运行程序时，发生了意料之外的事件，阻止了程序的正常执行，这种
情况被称为程序异常。处理程序异常，需要解决以下3 个问题
（ ！ ）哪军发斗异常？
( 2 ）谁来处理异’ii~＇？
( 3 ）如何协坪异常勺
这三个问题就像把大象装进冰箱的三个步骤一样，听来轻松，但实际上很难准确
操控，即使是有经验的程序员，处理起来也会难以应付。下面就围绕这三个问题来探
讨如何才能建立一套完善的异常处理机制。
首先， 需要明确在哪里发生异常。在代码中通过try-catch 来发现异常，但是有些
程序员往往将大段代码定义在一个町，catch 块内， 这样非常不利于定位问题，是一种
不负责任的做法。捕获异常时需要分清稳定代码和非稳定代码， 稳定代码指的是无论
如何都不会出锚的代码，例如int a= 0。异常捕获是针对非稳定代码的，捕获时要区
分异常类型并做相应的处理。比如，当用户输入了错误的用户名，提示用户账号错误，
正确的用户名下，错误的密码请重试；重试次数超过限制，则封锁账户等。
其次，判断谁来处理异常，在回答这个问题之前，需要明确两个关键字throw 和
throws 的区别，如下是数据访问层生成订单Id 的示例代码
public Long generateOrderid(Long userid) throws DAOException {
try {
return orderidSequence . nextValue() * 1000 + (userid 女1000 )
+ (userid I 1000) ;
} catch (Exception e) {
throw new DAOException （ ” 、equencρe.c r ,r, 1 r I =” + userid , e);
在与数据库交互时可能会发生网络连接不通、数据库锁超时、插入数据失败等异
常，向上归一化为DAOException 异常。这里的throw 是方法内部抛出具体异常类对
象的关键字， 而throws 贝IJ 用在方法si gnature 上，表示方法调用者可以通过此方法声
1136
第5 章异常与日志
明向上抛出异常对象。
了解了throw 和throws 的作用后，我们再来判断当前被捕获的异常是否需要自
己处理。如果异常在当前方法的处理能力范围之内且没有必要对外透出，那么就直接
捕获异常并做相应处理；否则向上抛出， 由上层方法或者框架来处理。
最后，无论采用哪种方式处理异常， 都严禁捕获异常后什么都不做或打印行日
志了事。如果在方法内部处理异常， 需要根据不同的业务场景进行定制处理， 如重试、
回滚等操作。如果向上抛出异常，如上例所示， 需要在异常对象中添加上下文参数、
局部变量、运行环境等信息，这样有利于排查问题。
5.1 异常分类
JDK 中定义了套完整的异常机制， 所有异常都是Throwable 的子类，分
为Error （ 致命异常）和Exception （非致命异常）。Error 是一种非常特殊的异
常类型，它的出现标识着系统发生了不可控的错误， 例如StackOverflowE rror、
OutO岛1emoryEηor。针对此类错误，程序无法处理，只能人工介入。Exception 又分
为checked 异常（ 受检异常）和unchecked 异常（非受检异常）。
checked 异常是需要在代码中显式处理的异常， 否则会编译出错。如果能自行处
理则可以在当前方法中捕获异常，如果无法处理，贝lj 继续向调用方抛出异常对象。
常见的checked 异常包括JDK 中定义的SQLException 、C lassNotF oundException 等。
checked 异常可以进一步细分为两类，
·无能为力、引起注意型。针对此类异常，程序无法处理， 如字段超长等导致
的SQLEx ception ， 即使做再多的重试对解决异常也没有任何帮助， 一般处理
此类异常的做法是完整地保存异常现场，供开发工程师介入解决。
· 力所能及、坦然处置型。如发生未授权异常（ UnAuthorizedException ） ， 程
序可跳转至权限申请页面。
在Exception 中， unchecked 异常是运行时异常，它们都继承自RuntimeException ,
不需要程序进行显式的捕捉和处理， unchecked 异常可以进一步细分为3 类
· 可预测异常（ Predicted Exception ) 常见的可预测异常包括
IndexOutOtBoundsException 、NullPointerException 等， 基于对代码的性能和
稳定性要求， 此类异常不应该被产生或者抛出， 而应该提前做好边界检查、
137
码出高效： Java 开发手册
空指针判断等处理。显式的声明或者捕获此类异常会对程序的可读性和运行
效率产生很大影响。
·需捕捉异常（ Caution Exception ），例如在使用Dubbo 框架进行RPC 调用时
产生的远程服务超时异常DubboTimeoutException ，此类异常是客户端必须显
式处理的异常，不能因服务端的异常导致客户端不可用，此时处理方案可以
是重试或者降级处理等。
·可透出异常（Ignored Exception），主要是指框架或系统产生的且会自行处理
的异常，而程序无须关心。例如针对Spring 框架中抛出的NoSuchRequestHa
ndlingMethodException 异常， Spring 框架会自己完成异常的处理，默认将自
身抛出的异常自动映射到合适的状态码，比如启动防护机制跳转到404 页面。
综上所述，异常分类结构如图5 1 所示。
图5 - 1 异常分类结构
为了加深理解，下面我们结合出国旅行的例子说明一下异常分类。
第，机场地震，属于不可抗力，对应异常分类中的E盯or。在制订出行计划时，
根本不需要把这个部分的异常考虑进去。
第二，堵车属于checked 异常，应对这种异常，我们可以提前出发，或者改签机票。
而飞机延误异常，虽然也需要check ， 但我们无能为力，只能持续关注航班动态。
第二，没有带护照，明显属于可提前预测的异常，只要出发前检查即可避免。去
机场路上车子抛锚，这个异常是突发的，虽然难以预料，但是必须处理，属于需要捕
捉的异常，可以通过更换交通工具应对。检票机器故障贝lj 属于可透出异常，交由航空
公司处理，我们无须关心。
I 138
第5 章异常与日志
全面了解了异常分类之后， 当遇到需要处理异常的场景时，要明确该异常属
于哪种类型，是需要调用方关注并处理的checked 异常， 还是由更高层次框架处
理的unchecked 异常。不论是哪一类异常。如果需要向上抛出， 推荐的做法是根
据当前场景自定义具有业务含义的异常， 为了避免异常泛滥，可以优先使用业界
或者团队已定义过的异常。例如， 远程服务调用中发生服务超时会抛出自定义的
DubboTimeoutException ， 而不是直接抛出RuntimeException ， 更不是抛出Exception
或Throwable 。
5.2 try 代码块
try-catch-finally 是处理程序异常的三部曲。当存在try 时，可以只有catch 代码块，
也可以只有finally 代码块， 就是不能单独只有try 这个光杆司令。下面分别说一下各
个代码块的作用。
( I ) try 代码块监视代码执行过程， 旦发现异常则直接跳转至catch ，如果
没有catch ，贝lj直接跳转至finally 。
( 2 ) catch 代码块可选执行的代码块，如果没有任何异常发生则不会执行，如
果发现异常则进行处理或向上抛出。这一切都在catch 代码块中执行。
( 3 ) finally 代码块必选执行的代码块，不管是否有异常产生，即使发生
OutOfMemoryError 也会执行， 通常用于处理善后清理工作。如果finally 代码块没有
执行，那么有三种可能·
· 没有进入try 代码块。
· 进入仕y 代码块， 但是代码运行中出现了死循环或死锁状态。
· 进入try 代码块， 但是执行了System. exit（） 操作。
注意， finally 是在return 表达式运行后执行的， 此时将要return 的结果已经被暂
存起来， 待finally 代码块执行结束后再将之前暂存的结果返回，示例代码如下，
pub工ic static int finallyNotWork () {
int temp = 10000 ;
try {
throw new Excepti on ();
} catch (Exception e ) {
return ++temp ;
才39 1
码出高效. J ava 开发手册
GJQ JQ JQ JQ J. ,
{
一－
l y
p
τ－ m
a
e
n
t
} -a- l.
此方法最终的返回值是10001 ，而不是99999 ，字节码忠实地给出了答案
1 I ' ;; t. ' :rnp "l. l·.
IINC 0 1
ILOAD 0
II r ’ .lr ri 在1f~ ｝；. 的H 挥作自； ｛i 仍在..， i...i t /. r
ISTORE 2
I 1 .t 1ally rd百99'l99 公ιc t ·) 1
LDC 99999
ISTORE 0
'I 注！刑的aJ i哩， 世；在书取为此：； 1 nt > Ir, 勺， 即10001
ILOAD 2
I RETURN
我们分析finally 的脾气秉性，是为了避免用错，而不是深入地分析为什么口币4
不支持这样的赋值方式。fi nally 代码块的职责不在于对变量进行赋值等操作，而是清
理资源、释放连接、关闭管道流等操作，此时如果有异常也要做try-catch 。
相对在finally 代码块中赋值，更加危险的做法是在finally 块中使用return 操作，
这样的代码会使返回值变得非常不可控，警示代码如下
public class TryCatchFinally {
static int x = 1 ;
static int y = 10 ;
static int z = 100;
public static void main (String [] args) {
int value = finallyReturn ();
System.out.println （ ” V弓lu 芭＝ ” ＋ value);
System.out.printlη （ ” x ＝ ” ＋ x) ;
System . out . println ( ” y=” + y) ;
System.out.println ( ” z=” + z) ;
public static int finallyReturn () {
try {
//
1140
仅供＇II二商业用途或交流学习使用
第5 章异常与日志
return ++x;
} catch (Exception e) {
++V+.+4, .Z ,
{
uzlnvudZn
＋』τ··伽L
zenare
} .,. -1
执行结果如下ι
value=lOl
x=2
y=lO
z=lOl
以上执行结果说明
（ ！ ）最后return 的功件是由finally 代码块巾的return ++z 完成的，所以为法返
回的纯果是IOI 。
( 2 ）语旬return ++ x 中的＋＋ x 被成功执行，所以运行结果足足斗。
( 3 ） 如果有异＃抛出，男F 乡lid亏结果将舍是r 门，而x-lo
finally 代码块中使用return 语旬，使返回值的判断变得复杂，所以避免返回值不
可控，我们不要在finally 代码块中使用return 语句。
最后分析try 代码块与锁的关系， lock 方法可能会抛出unchecked 异常，如果放
在try 代码块中，必然触发finally 中的unlock 方法执行。对未加锁的对象解锁会抛
出unchecked 异常，如Illega!MonitorStateException ， 虽然是因为加锁失败而造成程
序中断的，但是真正加锁失败的原因可能会被后者覆盖。所以在町代码块之前调用
lock（） 方法，避免由于加锁失败导致finally 调用unlock（） 抛出异常。警示代码中的红
色代码应该移到t可代码块的上方，如下所示。
Lock lock= new XxxLock();
preDo ();
try {
／／无论加倘若舌成功. unlock 占11 乡执行
lock.lock();
doSomething();
} finally {
lock .unlock();
才4才
仅供＇Ii二商业用途或交流学习使用
码出高效Java 开发手册
Lock 、ThreadLocal 、InputStream 等这些需要进行强制释放和清除的对象都得在
finally 代码块中进行显式的清理， 避免产生内存泄漏，或者资源消耗。
5.3 异常的抛与接
在谍战剧里的行动信息传递中， 信息的传递方与接收方是需要严格匹配的，比如
窗口放置一盆花， 表示有紧急异常情况， 行动取消，窗帘拉开， 表示情况正常，可以
行动。旦传递方信息传递错误， 或者接收方理解错误，都会有严重的后果。同样，
异常的抛与接，也一样需要严格的对等传递异常信息机制。我们要使捕获的异常与被
抛出的异常是完全匹配的，或者捕获的异常是被抛出异常的父类。
传递异常信息的方式是通过抛出异常对象， 还是把异常信息转成信号量封装在特
定对象中， 这需要方法提供者和方法调用者之间达成契约，只有大家都照章办事，才
不会产出误解。推荐对外提供的开放接口使用错误码， 公司内部跨应用远程服务调用
优先考虑使用Result 对象来封装错误码、错误描述信息；而应用内部则推荐直接抛出
异常对象。
为什么在远程服务调用中推荐使用Result 对象封装异常信息？如果使用抛异常
的返回方式，－＿§＿调用方没有捕获，就会产生运行时错误， 导致程序中断。此外，如
果抛出的异常中不添加枝信息，只是new 自定义异常并加入自定义的错误信息， 对于
调用端解决问题的帮助不会太大。如果加了枝信息，在频繁调用出锚的情况下，信息
序列化和传输的性能损耗也是问题。
我们都知道空指针异常（ NPE ）是程序世界里最常见的异常之一， 为了避免出现
NPE ， 应该是提供方需要明确可以返回null 值，调用方进行非空判断， 还是服务方保
证返回类似于Optional、空对象或者空集合？这个争论直到某次断网演练时才有了定
论。服务A 与服务B 在同一机房， 是超级稳定的服务依赖，服务可用率接近100% ,
因为服务B 已经明确不会返回null ，所以约定调用方A 中不需要做空值判断。但是
断网演练开始后， 无法调用到服务B ， 此时连空集合都无法返回， 所以在演练时间内
服务A 频繁抛出NPE。自此之后， 契约式编程理念就完全处于防御式编程理念的下风，
所以我们推荐方法的返回值可以为null ，不强制返回空集合或者空对象等，但是必须
添加注释充分说明什么情况下会返回null 值。防止NPE 定是调用方的责任， 需要
调用方进行事先判断。
｜ 才42
仅供＇Ii二商业用i主或交流学习使用
第5 章异常与曰志
5.4 日志
“曰志”这个词最早见于航海领域，是记录航行主要情况的载体文件，内容包括
操作指令、气象、潮流、航向、航速、旅客、货物等， 是处理海事纠纷或者海难的原
始依据之。尔后延伸到航空领域， 黑匣子就是一个重要的航空曰志载体，调查空难
原因时第一反应是找到黑匣子，并通过解析其中的日志信息来还原空难的事实真相。
同理， 记录应用系统曰志主要有三个原因记录操作轨迹、监控系统运行状况、
回溯系统故障。
记录操作行为及操作轨迹数据，可以数据化地分析用户偏好，有助于优化业务逻
辑， 为用户提供个性化的服务。例如，通过access.log 记录用户的操作频度和跳转链接，
有助于分析用户的后续行为。
全面有效的日志系统有助于建立完善的应用监控体系，由此工程师可以实时监控
系统运行状况，及时预警，避免故障发生。监控系统运行状况，是指对服务器使用状
态，如内存、CPU 等使用情况，应用运行情况， 如响应时间， QPS 等交互状态；应
用错误信息，如空指针、SQL 异常等的监控。例如，在CPU 使用率大于60% ， 四核
服务器中load 大于4 时发出报警，提醒工程师及时处理，避免发生故障。
当系统发生线上问题时， 完整的现场日志有助于工程师快速定位问题。例如当系
统内存溢出时，如果日志系统记录了问题发生现场的堆信息$就可以通过这个曰志分
析是什么对象在大量产生并且没有释放内存，回溯系统故障，从而定位问题。
5.4.1 日志规范
为了统一认知， 降低沟通和学习成本， 应用中的扩展日志命名方式应该有统－
的约定，通过命名能直观明了地表明当前日志文件是什么功能，如监控、访问日志
等。推荐的日志文件命名方式为appName_logType logName.log。其中， logType 为
日志类型，推荐分类有stats 、monitor 、v isit 等， logName 为日志描述。这种命名的
好处是通过文件名就可以知道曰志文件属于什么应用，什么类型，什么目的，也有利
于归类查找。例如， mppserver 应用中单独监控时区转换异常的日志文件名定义为
mppserver _monitor_ timeZoneConvert.log 。
以上对日志名称进行了约定，将工程师从纷繁复杂的曰志命名中解放出来，而困
扰工程师的另一个问题是日志文件需要保存多久呢？由于存储空间有限，日志不可能
永久地存储在碰盘中，文件的生命周期应该如何定义呢？如果日志存储周期较短，如
143 I
仅供＇Ii二商业用途或交流学习使用
码出高效· Java 开发手册
7 天，那么针对有些具备以“周”为频次发生的异常就无法被发现，相反，若曰志保
存周期过长，又会对碰盘存储空间造成较大压力，产生不必要的资源消耗。因此综合
两个方面考虑，代码规约推荐曰志文件至少保存1 5 天，可以根据日志文件的重要程度、
文件大小及磁盘空间再自行延长保存时间。
日志是有级别的。针对不同的场景，日志被分为五种不同的级别， 按照重要程度
由低到高排序
• DEBUG 级别曰志记录对调试程序有帮助的信息。
• INFO 级别日志用来记录程序运行现场，虽然此处并未发生错误，但是对排
查其他错误具有指导意义。
• WARN 级别日志也可以用来记录程序运行现场，但是更偏向于表明此处有出
现潜在错误的可能。
• ERROR 级别日志表明当前程序运行发生了错误，需要被关注。但是当前发
生的错误，没有影响系统的继续运行。
• FATAL 级别曰志表明当前程序运行出现了严重的错误事件，并且将会导致应
用程序中断。
可以看出3 以上不同级别的日志优先级和重要性不同，因此在打印日志时针对不
同的日志级别要有不同的处理方式。
I. 预先判断曰志级另lj
对DEBUG 、剧FO 级别的日志，必须使用条件输出或者使用占位待的方式打印。
该约定综合考虑了程序的运行效率和日志打印需求。例如， 在某个配置了打印日志
级别为W础N 的应用中，如果针对DEBUG 级别的日志，仅仅在程序中写出logger.
debug(”Processing trade with id:” + id + ” and symbol ： ” ＋ symbol）； ， 那么该日志不会被
打印， 但是会执行字符串拼接操作1 如果symbol 是对象， 还会执行to String（） 方法，
白白浪费了系统资源。如下示例代码为正确的打印日志方式ω
／／使明条件吁所形式
if (logger.isDebugEnabled()) {
logger.debug (” E nc:ess_nJ t ade wi>_h id:” + id
+ ” and syml: ol : " + symbol) ;
／／使用占｛古符形式
logger .debug (” Processing trade with iJ: {} and 叩nbol : ｛｝ ” ， 划， s严nbol) ;
才44
仅供非商业用途或交流学习使用
第5 章异常与日志
2. 避免无效日志打印
生产环境禁止输出DEBUG 曰志旦有选择地输出n、、
使用肘FO 、WARN 级别来记录业务行为信息时，－定要控制日志输出量，以免
磁盘空间不足。同时要为曰志文件设置合理的生命周期， 及时清理过期的日志。
避免重复打印，务必在日志配置文件中设置additiv ity=fa l se ，示例如下
<loggerηame= " 'm.ι 王ot·a h 』、un.munber . co1 fig " additivity=” false" >
3 . 区别对待错误日志
W础N 、ERROR 都是与错误有关的日志级别，但不要一发生错误就笼统地输出
ERROR 级别日志。些业务异常是可以通过引导重试就能恢复正常的， 例如用户输
入参数错误。在这种情况下，记录日志是为了在用户咨询时可以还原现场， 如果输出
为ERROR 级别就表示－g 出现就需要人为介入， 这显然不合理。所以， ERROR 级
另lj只记录系统逻辑错误、异常或者违反重要的业务规则， 其他错误都可以归为WARN
级别。
4 . 保证e 丧内容由整
曰志记录的内容包括现场上下文信息与异常堆枝信息， 所以打印时需要注意以下
两点a
（ ｜ ）记录异常时定要输出异常堆枝， 例如logger.error（” xxx ”＋e . gctMessage（）‘ e ） 。
( 2 ） 曰志中如果输出对象实例，要确保实例芳：首写了toString }J 洼， ~~IJ 只会
输出对争的hashCode 值， 没苟实际需义。
综上所述， 日志是一个系统必不可少的组成部分， 但日志打印并非多多益善， 过
多的日志会降低系统性能， 也不利于快速定位问题，所以记录曰志时定请思考三个
问题①日志是否有人看1 ②看到这条日志能做什么1 ③能不能提升问题排查效率。
5.4.2 日志框架
说到日志工具， 日常工作或学习中肯定昕过这些名词log句、logback 、jdklogging
、sl臼j 、common s-logg ing 等， 它们之间有什么关系， 在整个日志体系中又扮
演什么角色呢？日志框架分为三大部分，包括日志门面、曰志适配器、日志库。利用
门面设计模式， 即Facade 来进行解稠，使日志使用变得更加简单， 如图5-2 所示。
才4 5
仅供＇Ii二商业用i主或交流学习使用
码出高效： J ava 开发手册
jul-to-sl伺j
com 阿10ns →ogg1ng
log4j 叮ver-sl叫
jcl-over-slf4j slf4j- jcl s lf4 j- log4j1 2
log4j lo g back log寸id k 真他日志库
图5-2 日志结构框架
I. 日志勺面
门面设计模式是面向对象设计模式中的一种， 日志框架采用的就是这种模式， 类
似JDB C 的设计理念。它只提供一套接口规范， 自身不负责日志功能的实现， 目的是
让使用者不需要关注底层具体是哪个日志库来负责日志打印及具体的使用细节等。目
前用得最为广泛的曰志门面有两种s l 伺j 和c o mmon s -lo gg in g 。
2 . 曰志库
它具体实现了日志的相关功能， 主流的日志库有三个， 分别是log4j 、l og-jdk 、
l ogback 。最早Java 要想记录曰志只能通过Syst em . out 或Syste m.e rr 来完成， 非常不方便。
l og4j 就是为了解决这一问题而提出的， 它是最早诞生的曰志库。接着JDK 也在1 .4 版
本引入了一个日志库j ava. uti l.l oggi ng . Logger.， 简称l o剖dk 。这样市面上就出现两种日志
功能的实现， 开发者在使用时需要关注所使用的日志库的具体细节。l ogback 是最晚出
现的， 它与l og4j 出自同一个作者， 是l o g句的升级版且本身就实现了s l问的接口。
3. 曰志适配器
曰志适配器分两种场景
( I ）日志、丁面适配器， 日4J s 汗~j 规范是后来提出的‘ 1f 此之前的日志库是没有
实现s旧j 的接口的， 例如log4j ；所以3 在工程里要想使用sl f4j + log4j 的模式， 就额
外需要个适配器（ sit可J-log4j 12 ）莱斯决接口不兼容的可思。
( 2 ） 日志库适配器， 在阴老的工程里，一开始为了开发简单而直接使用了日
146
仅供Ii 'i商业用途或交流学习使用
第5 童异常与日志
志库AP ！ 来完成曰志打印，随着时「日的推移想将原来直接调用日志库的模式改为业界
标准的门面模式（例如slf马j + logback 组合） ， 但老工秤代码里打印曰志酌地方太多，
难以改动，所以需要个运队器来完成从旧日志库的API 到slf4j 的路由， 这样在不
改动原有代码的情况l、也能使用sl 叫来统一管理曰志，而日后续自由替换具体日志
库也不成可题。
我们了解了日志家族里的成员及其作用， 接下来将以Mave n 工程为例介绍如何
在工程里进行曰志集成。
如果是新工程，则推荐使用s lf<句+log back 模式。因为l ogback 自身实现了s l 问的
接口，无须额外引人适配器，另外log back 是lo g4j 的升级版，具备比log句更多的优点，
可通过如下配置进行集成·
<dependency>
<groupid>org.slf4 ]</ groupid>
<artifactid>slf4j-api</artifactid>
<version>${slf4j-ap 工. vers 工on}</vers 工on>
</dependency>
<dependency>
<groupid>ch . qos . logback</groupid>
<art if act 工d>logback-classic</artifactid>
<version ＞♀｛ logback-class 工c.version}</version>
</dependency>
<dependency>
<groupid>ch . qos . logback</groupid>
<artifactid>logback - core</artifact 工d>
<version>${logback-core.version)</version>
</dependency>
如果是老工程，则需要根据所使用的日志库来确定门面适配器，通常情况下老工
程使用的都是log4j ， 因此以log4j 日志库为例，可通过如下配置进行集成，
<dependency>
<groupid>org . slf4j</groupid>
<artifactid>slf4j 『api</artifactid>
<version>${slf4j-api.version}</version>
</dependency>
<dependency>
<groupid>org.slf4j </groupid>
<artifactid>slf4j-log4j12</art 工fact id>
<version ＞♀｛ slf4j-log4j12 . version}</version >
</dependency>
仅供，11,rrli 才v.mi主或交流学习使用
147
码出高效Java 开发手册
<dependency>
<groupid>log4j</groupid>
<artifactid>log4j</artifactid>
<version>${log4j . vers 工on}</version>
</dependency>
如果老代码中直接使用了log句日志库提供的接口来打印曰志，则还需要引人曰
志库适配器，配置实例如下所示
<dependency>
<groupid>org . slf4j</groupid>
<artifactid>log4j-over- slf4j</artifactid>
<version ＞丰｛ log4 〕－ over - slf4j . version}</version>
</dependency>
至此我们的工程就完成了日志框架的集成，再加上一个日志配置文件（如
logback.xml 、log4j.xml 等），并在工程启动时加载，然后就可以进行曰志打印了，示
例代码如下·
private static final Logger logger= LoggerFactory.getLogger(Abc . class );
注意， logger 被定义为static 变量，是因为这个logger 与当前类绑定， 避免每次
都new 一个新对象，造成资源浪费，甚至引发OutOfMernoryError 问题。
另外，在使用slf<句＋日志库模式肘，要防止日志库冲突，一旦发生则可能会出现
日志打印功能失效的问题。例如，某个业务的网站页面出现了500 错误， 但开发工程
师翻遍整个系统的日志文件都没有发现任何异常曰志。线下模拟调试发现错误发生
时有异常对象抛出并被框架捕获，然后执行了曰志打印的相关代码，但实际没有输出
到日志文件。经开发工程师深入排查， 当前工程代码中配置的曰志库为log4j ， 但工
程依赖的个jar 包间接地引入了logback 日志库，导致打印日志的Logger 引用实际
指向ch.qos.logback.classic . Logger 对象，二者的冲突引发了日志打印失效的问题。
φ 咱
仅供｜｜… 商业用途或交流学习使用
@
第6 章数据结构与集合
廊腰缠回，檐牙高睐。纵使相同一砖一瓦，不同雕琢设计，亦生错落
有致的廊拥美景。数据结构的魅力也缘于此中道理。
纬度、
码出高效Java 开发手册
在代码世界中，集合是对℃o llection ” 词的翻译，事实上这么翻译仍不够准确。
在数学世界中，集合是指具有某种特定性质的事物汇成的集体，对应英文是Set ， 它
具有确定性、无序性、互异性等特点。而Java 中的集合表达的是数据结构的载体，
并未对应于数学概念上的集合， Java 中的集合元素可以是有序的，也可以是重复的，
与数学中的要求不一样。本书中其他地方出现的集合概念，都指的是Co llection ， 用
来保存各种各样的对象。我们经常说，
构的载体， 可对元素进行加工和输出，以定的算法实现最基本的增删改查功能，因
此集合是所有编程语言的基础。
在进入高并发编程时代后，由集合引发的相关故障占比越来越高。比如，多线程
共享集合时出现的脏数据问题，某些集合在数据扩窑时出现节点之间的死链问题；写
多读少的场景误用某些集合导致性能下降问题等。本章将从数组讲起，引申到集合框
架，再到重点集合源码分析， 最后介绍高并发集合框架，目的是对集合的了解成竹在
胸、运用得心应手。
6.1 数据结构
| 数据结构定义
数据结构是什么？网络上的一些定义十分抽象且各不相同，学习完之后，反而对
数据结构的概念更加模糊、更有敬畏之心。数据结构是指逻辑意义上的数据组织方式
及其相应的处理方式。
( I ）什么是理一如音义？ 数据结构的抽象表达非常丰富，而实际物理存储的方式
相对单一。比如，二叉树在说盘中的存储真的是树形排列吗？并非如此。树的存储可
能是基于物理上的顺序存储方式，可以理解为一个格子一个格子连续地放， 设想有7
个节点的二叉树，第一个格子放根节点，第二个恪子放左子树根节点，并且根据引用
知道左叶子在后续的哪个格子里，第三个格子放右子树根节点1 依此类推。此外，树
的存储也可能是基于物理上的链式存储方式，这里不再详细展开。
( 2 ） 什么是＇！｝），： J.5 组织方式？ 逻辑意义上的组织方式有很多，比如树、图、队列、
晗希等。树可以是二叉树、三叉树、B＋ 树等，图可以是有向图或无向图，队歹lj是先
进先出的线性结构；晗希是根据某种算法直接定位的数据组织方式。
( 3 ) .｛ 么是江L居处理7 式？ 在既定的数据组织方式上，以某种特定的算法实现
数据的增加、删除、修改、查找和遍历。不同的数据处理方式往往存在着非常大的性
®1150
仅供非商业用途或交流学习使用
第6 章数据结构与集合
能差异。
2. 敖据~i构分供
数据结构是算法实现的基石， 它是－种体现基础逻辑思维的内功心法，也是计算
机从业人员能力图谱中的重要一项。如果完全不懂数据结构，很难写出优秀的代码。
有缺陷的底层数据结构容易导致系统风险高、可扩展性差，所以需要认真地对数据结
构进行设计和评审。从直接前继和直接后继个数的维度来看，大体可以将数据结构分
为以下四类。
( I ）线↑生结构0 至l 个直接前继和直接后继。当线性结构非空时，有唯－的
首元素和尾元素，除两者外， 所有的元素都有唯一的直接前继和直接后继。线性结
构包括顺序表、链表、枝、队列等，其中枝和队列是访问受限的结构。枝是后进先
出，即Last-In, First-Out ，简称LIFO ；队列是先进先出，即First-In, First-Out ，简称
FIFO 。
( 2 ）树＃均0 至1 个直接前继和0 至n 个直接后继（ n 大于或等于2 ）。树是
一种非常重要的有层次的非线性数据结构，像自然界的树一样。由于树结构比较稳定
和均衡，在计算机领域中得到广泛应用。
( 3 ）可言给啕0 至n 个直接前继和直接后继（ n 大于或等于2 ）。图结构包括简
单图、多重图、有向图和无向图等。
( 4 ）晗养均构没有直接前继和直接后继。晗希结构通过某种特定的晗希函数
将索51 与存储的值关联起来， 它是一种查找效率非常高的数据结构。
不同的数据组织方式和处理方式带来了一个新的问题·如何衡量数据处理的性
能。数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储设备越来越便宜的
情况下，时间复杂度成为重点考量的因素。算法时间复杂度是种衡量计算性能的指
标， 反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能够反映出算
法性能的优劣与否。而这个量级通常用大写的0 和一个函数描述， 如O(n 3） 表示程序
执行时间随输入规模呈现三次方倍的增长， 这是比较差的算法实现。从最好到最坏的
常用算法复杂度排序如下：常数级0(1 ）、对数级O(logn ）、线性级0伊）、线性对数级
。（nlogn ） 、平方级。但2）、立方级O(n 3）、指数级0(2＂） 等。有人觉得在实际编程中没
有必要去纠结算法复杂度，因为现实中的数据量有限，执行时间相差无几。但是，数
据规模并非静止不变，优秀的程序实现不会因为数据规模的急剧上升导致程序性能的
急剧下降。e 151
仅供11：商业用i主或交流学习使用
码出高效· J ava 开发手册
最后以“ 猜数字” 为例进一步理解时间复杂度， 主持人从1 ～ 100 的范围内任选
一个数字， 玩家随机猜一个数， 如果没有猜中， 主持人会提示猜大了还是猜小了， 继
续这样的循环，直到猜对为止。显而易见， 如果要猜测， 最多要猜100 次，最少只用
猜l 次。经验表明， 玩家总会往中间砍一段，平均猜测次数总在七八次左右。通过模
拟程序运行l 亿次， 完全随机的情况下，平均猜测的次数是7.47 次， 近似二分法猜
测的是5 . 8 次， 时间复杂度为O(logn ） 。
6.2 集合框架图
Java 中的集合是用于存储对象的工具类容器， 它实现了常用的数据结构， 提供了
一系列公开的方法用于增加、删除、修改、查找和遍历数据，降低了日常开发成本。
集合的种类非常多， 形成了一个比较经典的继承关系树， 称为Java 集合框架图， 如图6-1
所示。框架图中主要分为两类。第一类是按照单个元素存储的Co llection ， 在继承树
中Set 和List 都实现了C ollection 接口，第二类是按照Key- Value 存储的Map 。以上
两类集合体系， 无论数据存取还是遍历， 都存在非常大的差异。.
Concurre…
q linkedBI。ckingQueue
!I A ” ayB ii 川w剧川g口… ! ! OelayQueue
nv a M h“ s a H t n e v 『u c n
。
c
图6 -1 J ava 集合框架图
φ ｜ 才52
仅供非商业用途或交流学习使用
第6 童数据结向与集合
在集合框架图中，红色代表接口， 蓝色代表抽象类， 绿色代表并发包中的类，灰
色代表早期线程安全的类（基本已经弃用）。可以看到，与Collection 相关的4 条线
分别是List 、Q ueue 、Set 、Map ，它们的子类会映射到数据结构中的表、树、晗希等。
对集合框架图的深刻理解，有利于对集合的宏观把控，并写出更高质量的程序。此图
相当于纲举目张的“纲
的思、路理解其他集合。下面一起学习这4 个常用集合类型。
6.2.1 List 集合
List 集合是线性数据结构的主要实现，集合元素通常存在明确的上一个和下一个
元素，也存在明确的第一个元素和最后一个元素。List 集合的遍历结果是稳定的。该
体系最常用的是ArrayList 和LinkedList 两个集合类。
Array List 是窑量可以改变的非线程安全集合。内部实现使用数组进行存储，集
合扩容时会创建更大的数组空间，把原有数据复制到新数组中。ArrayList 支持对元素
的快速随机访问，但是插入与删除时速度通常很慢，因为这个过程很有可能需要移动
其他元素。
LinkedList 的本质是双向链表。与ArrayList 相比， LinkedList 的插入和删除速度
更快，但是随机访问速度贝lj很慢。测试表明，对于IO 万条的数据，与ArrayList 相比，
随机提取元素时存在数百倍的差距。除继承AbstractList 抽象类外， LinkedList 还实现
了另一个接口Deque ，即doub le耐1ded queue。这个接口同时具有队列和枝的性质。
LinkedList 包含3 个重要的成员size 、日r挝、last。size 是双向链表中节点的个数。
自rst 和last 分别指向第一个和最后一个节点的引用。LinkedList 的优点在于可以将零
散的内存单元通过附加引用的方式关联起来，形成按链路）｜｜页序查找的线性结构，内存
利用率较高。
6.2.2 Queue 集合
Queue （队列）是一种先进先出的数据结构，队列是一种特殊的线性表，它只允
许在表的端进行获取操作，在表的另端进行插入操作。当队列中没有元素时，称
为空队列。自从BlockingQueue （阻塞队歹lj ）问世以来，队列的地位得到极大的提升，
在各种高并发编程场景中，由于其本身FIFO 的特性和阻塞操作的特点，经常被作为
Buffer （数据缓冲区）使用。
e 153 I
仅供＃商业用途或交流学习使用
码出高效： Java 开发手册
6.2.3 Map 集合
Map 集合是以Key-Value 键值对作为存储元素实现的晗希结构， Key 按某种晗希
函数计算后是唯一的， Value 则是可以重复的。Map 类提供三种Co llection 视图，在
集合框架图中， Map 指向Co llection 的箭头仅表示两个类之间的依赖关系。可以使用
keySet（）查看所有的K町，使用values（）查看所有的Value ，使用ent可Set（）查看所有
的键值对。最早用于存储键值对的Hashtable 因为性能瓶颈已经被淘汰，而如今广泛
使用的HashMap ， 线程是不安全的。ConcurrentHashMap 是线程安全的，在JDK8 中
进行了锁的大幅度优化，体现出不错的性能。在多线程并发场景中，优先推荐使用
ConcurrentHashMap ，而不是HashMap 。TreeMap 是Key 有序的Map 类集合。
6.2.4 Set 集合
Set 是不允许出现重复元素的集合类型。Set 体系最常用的是HashSet 、TreeSet
和L inkedHashSet 三个集合类。HashSet 从源码分析是使用HashMap 来实现的，只是
Value 固定为一个静态对象，使用Key 保证集合元素的唯性，但它不保证集合元素
的顺序。TreeSet 也是如此，从源码分析是使用TreeMap 来实现的，底层为树结构，
在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集
合仍然是有序的。LinkedHashSet 继承自Hash Set ， 具有Hash Set 的优点，内部使用链
表维护了元素插入顺序。
6.3 集合初始化
集合初始化通常进行分配容量、设置特定参数等相关工作。我们以使用频率较高
的ArrayList 和HashMap 为例，简要说明初始化的相关工作，并解释为什么在任何情
况下，都需要显式地设定集合容量的初始大小。ArrayList 是存储单个元素的顺序表结
构， HashMap 是存储KV 键值对的晗希式结构。分析两者的初始化相关源码，洞悉它
们的窑量分配、参数设定等相关逻辑，有助于更好地了解集合特性，提升代码质量。
下面先从ArrayList 源码说起：
public class ArrayL 工st < E> extends AbstractList<E>
implements List<E>, RandomAccess, Cloneable ,
java.io.Serializable {
private static final int DEFAULT CAPACITY = 10;
,,
private static final Object [ l EMPTY ELEMENTDATA = {} ;
号｜ 才54
仅供非商业用途或交流学习使用
第6 章数据结构与集合
transient Ob] ect[) elementData;
private int size;
public ArrayList(int initialCapacity) {
if (in 工tialCapacity > 0 ) {
／气ι 开户H • ＇川k·：＇·占λJ )-' '"
, ,
this .elementData = new Object[initialCapacity);
} else if （工口工tialCapacity == 0 ) {
this .elementData = EMPTY ELEMENTDATA;
II,, f'·;ad0h·;,,i！~Ji'1IL/1 句L 巳厅i-t:
private void add(E e, Object[) elementData, int s) {
// ］耳；如勿，， f "i' f产Z 再＇ 1 o:ry ' '' • I勺，；干• r,;1 ” 「J QI , ，，； 且，：·；
if (s == elementData.length)
elementData =grow();
elementData[s) = e;
S 工ze = s + l ;
private Ob] ect [ J grow () {
return grow(size + 1 );
／／书容的：；，－ 小要！．必须容纳，中！ r 的JL 幸. i '6k ＋丁． . D8wC'apac· 1 t y ()
／／万占1 才是书卢布叶d 庐！
private Ob] ect [) grow (int minCapaci ty) {
return elementData = Arrays.copyOf(elementData,
newCapacity(minCapacity));
private int newCapac 工ty( int minCapacity) {
／／！苟止才’容1. 5 j古2 氏， Jill t i llt 的非4 泣，！－J （第1 处）
int o l dCapacity = elementData .length;
11 JDI<6 之拍打容50 i支50 斗，但1F ,J'! cρi l 啕rlii 夕r,, (1~ 加！、J以floor （第2 处）
int newCapacity = oldCapacity + (oldCapacity > 1 ) ;
if (newCapacity - minCapac 工ty <= 0 ) {
if (elementData == DEFAULTCAPACITY EMPTY ELEMENTDATA)
／／手参必构功方）L 生在此r.btrnt 斗J 均10 '1'1 手’电
return Math.max(DEFAULT CAPACITY, minCapacity);
if (minCapacity < 0 )
throw new OutOfMemoryError();
return minCapacity; e 155
仅供＃商业用途或交流学习使用
码出高效Java 开发手册
return (newCapac 工ty - MAX_ARRAY_SIZE <= 0 )
? newCapacity
hugeCapacity (minCapacity) ;
第l 处说明正数带符号右移的值肯定是正值，所以oldCapacity+(oldCapacity>> 1)
的结果可能超过int 可以表示的最大值， 反而有可能比参数的m inCapacity 更小， 贝lj 返
回值为（size＋ ！） 的minCapacity。
第2 处说明如果原始容量是13 ， 当新添加个元素时， 依据程序中的计算方法，
得出13 的二进制数为1101 ，随后右移l 位操作后得到二进制数110 ，即十进制数6。
最终扩窑的大小计算结果为oldCapacitiy + ( oldCapacity» 1) = 13 + 6 = 19。使用位运
算主要是基于计算效率的考虑。在JDK7 之前的公式， 扩窑计算方式和结果为oldCap
acitiy × 3÷2+1 = 13 × 3÷2 + I = 20 。
当ArrayList 使用无参构造时，默认大小为10 ，也就是说在第次add 的时候，
分配为10 的容量，后续的每次扩容都会调用Array. copyOf 方法，创建新数组再复
制。可以想象， 假如需要将1000 个元素放置在ArrayList 中，采用默认构造方法，
则需要被动扩窑13 次才可以完成存储。反之，如果在初始化时便指定了容量new
ArrayList(l 000）， 那么在初始化ArrayLi st 对象的时候就直接分配1000 个存储空间，
从而避免被动扩容和数组复制的额外开销。最后，进一步设想，如果这个值达到更大
量级， 却没有注意初始的窑量分配问题， 那么无形中造成的性能损耗是非常大的， 甚
至导致OOM 的风险。
再来看一下HashMap ， 如果它需要放置1000 个元素， 同样没有设置初始窑量大小，
随着元素的不断增加， 贝lj需要被动扩容7 次才可以完成存储。扩窑时需要重建hash 表，
非常影响性能。在HashMap 中有两个比较重要的参数； Capacity 和Load Factor ，其
中Capacity 决定了存储容量的大小，默认为1 6 ，而Load Factor 决定了填充比例，
一般使用默认的0. 7 5 。基于这两个参数的乘积， HashMap 内部用threshold 变量表示
HashMap 中能放入的元素个数。HashMap 容量并不会在new 的时候分配，而是在第
一次put 的时候完成创建的，源码如下
public V put (K key , V value) {
if (table == EMPTY TABLE) {
inflateTable(threshold) ;
I ...白雷在代～
® 156
仅供非商业用途或交流学习使用
第6 章数据结构与集合
／／事一生put lit. 诏帮如下-tf 法句叼γ幸免tab.ie
private void inflateTable(int toS 工ze ) {
／／茨瓦大子参，生豆豆豪言主运2 护主王佳‘安切希／、参幸竟是27 . J:j 返@l 32
int capacity= roundUpToPowerOf2(toSize) ;
II threshold 在不超过1{ 制最＊：＿ 笼约苦笑下等于capacic.y 去loadFactor
threshold= (int) Math.min(capacity * l oadFactor, MAXIMUM CAPACITY+ l );
table= new Entry[capacity] ;
initHashSeedAsNeeded(capacity) ;
为了提高运算速度，设定HashMap 容量大小为7 ，这样的方式使计算落槽位置
更快。如果初始化HashMap 的时候通过构造器指定了initialCapacity ，贝IJ会先计算出
比initialCapacity 大的2 的幕存入threshold ，在第次put 时会按照这个2 的幕初始化
数组大小，此后每次扩窑都是增加2 倍。如果没有指定初始值， log2 1000 = 9.96，结
合源码分析可知，如果想要容纳1000 个元素，必须经过7 次扩窑。HashMap 的扩容
还是有不小的成本的，如果提前能够预估出HashMap 内要放置的元素数量，就可以
在初始化时合理设置窑量大小，避免不断扩容带来的性能损耗。
综上所述， 集合初始化时，指定集合初始值大小。如果暂时无法确定集合大小，
那么指定相应的默认值，这也要求我们记得各种集合的默认值大小， ArrayList 大小为
IO ， 而HashMap 默认值为16。牢记每种数据结构的默认值和初始化逻辑， 也是开发
工程师基本素质的体现。
6.4 数组与集合
数组是一种顺序表，在各种高级语言中，它是组织和处理数据的一种常见方式，
我们可以使用索引下标进行快速定位并获取指定位置的元素。数组的下标从0 开始，
但这并不符合生活常识，这源于BCPL 语言， 它将指针设置在0 的位置，用数组下标
作为直接偏移量进行计算。为什么下标不从l 开始呢？如果是这样，计算偏移量就要
使用当前下标；咸1 的操作。加减法运算对CPU 来说是种双数运算，在数组下标使
用频率极富的场景下，这种运算是十分耗时的。在Java 体系中，数组用以存储同一
类型的对象，－＿§＿分配内存后贝iJ 无法扩窑。提倡类型与中括号紧挨斗目连来定义数组， e 157
仅供＃商业用途或交流学习使用
码出高效： Java 开发手册
因为在Java 的世界里，万物皆为对象。String［］用来指代String 数组对象，示例代码
如下：
String[] args = { ” a ” , " b ” };
I , ，纠Z
Object obj = args;
／／如i 'T 块’，， ringr, 'L 得有＇）： .也（＇，. ！缸功~也． t审s I OJ d',f[• ！扣d 萨为Obj F 护
((String[]) obj) [ OJ ＝ ” ot. 飞ect " ;
声明数组和赋值的方式示例代码如下：
/ ' '"
String [] args3 = ｛ ” a 啊， ” b " };
String[] args4 = new String[ 2];
args4[ 0] = ’ a ;
args4 [ l ] ” ,.
上述源码中的args3 是静态初始化，而args4 是动态初始化。无论静态初始化还
是动态初始化，数组是固定容量大小的。注意在数组动态初始化时，出现了new ，这
意昧着需要在new String H 的方括号内填写一个整数。如果写的是负数，并不会编译
出错，但运行时会抛出异常： NegativeArrayS izeException。对于动态大小的数组，集
合提供了Vector 和ArrayList 两个类，前者是线程安全，性能较差，基本弃用，而后
者是线程不安全，它是使用频率最高的集合之一。
数组的遍历优先推荐JDK5 引进的foreach 方式，即for（元素：数组名）的方式，
可以在不使用下标的情况下遍历数组。如果需要使用数组下标，则使用for (int i = O;
i < array.length; i ＋＋）的方式，注意length 是数组对象的一个属性，而不是方法（注－
String 类是使用length（）方法来获取字符串长度的）。也可以使用JDK8 的函数式接
口进行遍历：
Arrays. asList (args3) . stream() . forEach (x -> System. out. println (x)) ;
Arrays.asList(args3) .stream() . forEach (System.out::println);
Arrays 是针对数组对象进行操作的工具类，包括数组的排序、查找、对比、拷贝
等操作。尤其是排序，在多个JDK 版本中在不断地进化，比如原来的归并排序改成
Timsort ，明显地改善了集合的排序性能。另外，通过这个工具类也可以把数组转成集合。
数组与集合都是用来存储对象的容器，前者性质单一，方便易用i 后者类型
安全，功能强大，且两者之间必然有互相转换的方式。毕竟它们的性格迥异，在
转换过程中，如果不注意转换背后的实现方式，很容易产生意料之外的问题。转
® I 才58
仅供＃商业用途或交流学习使用
仅供~ 11 ： 商业!Iii垂或交流学习使用
第6 章数据结构与集合
换分成两种情况数组转集合和集合转数姐。在数组转集合的过程中，注意是否
使用了视图方式直接返回数组中的数据。我们以Arrays.asList （） 为例，它把数组转
换成集合时，不能使用其修改集合相关的方法， 它的add/r e move / clear 方法会抛出
Uns upportedOperationException 异常。示例源码如下：
public class ArraysAsList {
public static void main(String[] args) {
String[] stringArray = new String[ 3 ] ;
stringArray[ O] =
stringArray[ l ] =
stringArray[ 2 ] = ’•"' ' ;
List<String> stringList = Arrays.asList(stringArray) ;
·i;,
stringList.set( O, neL 牛比1 );
' .kf I ',..;.. I . • iι＇ ' ,.
System.out . println(stringArray[ 'J ]) ;
亏I、丁’户r 1］川叫者i’；；护！江主勺才，F 喝了
stringList . add ( ·’ ) ;
stringList . rem 。ve( 2 ) ;
stringList . clear() ;
事实证明，可以通过set （）方法修改元素的值，原有数组相应位置的值
同时也会被修改，但是不能进行修改元素个数的任何操作，否则均会抛出
Unsupporte dOperatio nException 异常。Arrays . asList 体现的是适配器模式，后台的数据
仍是原有数组， set （） 方法即闯接对数组进行值的修改操作。asL ist 的返回对象是一个
Arrays 的内部类，它并没有实现集合个数的相关修改方法，这也正是抛出异常的原因。
Arrays . asList 的源码如下
public static <T> List<T> asList(T . .. a) {
return new ArrayList<>(a);
返回的明明是ArrayList 对象，怎么就不可以随心所欲地对此集合进行修改呢？
注意此Array List 非彼Array List ，虽然Arrays 与Array Li st 同属于一个包，但是在
Arrays 类中还定义了一个Array List 的内部类（或许命名为InnerArray List 更容易识别），
根据作用域就近原则，此处的ArrayList 是李鬼，即这是个内部类。此李鬼十分简单，
才59
仅供ll'i商业用途或交流学习使用
仅供非商业用途或交流学习使用
码出高效J ava 开发手册
只提供了个另lj方法的实现，如下所示
pr主vate static class ArrayList<E> extends Abstr actList<E>
implements RandomAccess , java . i 。. Serializable {
f~· ， -L 、毛坠_.: （第1 处）
private final E[] a ;
II 主八f'7.~~ <11 'f' ：：干恒’J a . 丐vbjec~s ;_ J;)r’？导l 入的王共包
I reqi.;ιreN、.1>.J~ l 二且Z ； ~t. J;'.: 杏专n口ll
ArrayLis t (E[] array) {
a= Ob jects . r equireNonNu l l(array);
／实钊四且从方辑协「卡l' 、~ 自习
pub工ic E set(int index , E element) {
E oldValue = a[index] ;
a ［工ndex ] = element ;
5冉穴~·. 是‘＼.＼ι 主L F句iζ 这
return oldValue ;
第l 处的final 引用，用于存储集合的数组可｜用始终被强制指向原有
数姐。这个内部类并没有实现任何修改集合元素个数的相关方法， 那这个
UnsupportedOperati onException 异常是从哪里抛出来的呢？是李鬼的父类
AbstractList ·
public abstract class AbstractList<E> extends AbstractCollecti o n<E>
implements List<E> {
160
public void add(int index , E element ) {
throw new UnsupportedOperatio 口Except i on ();
public E remove(int index) {
thr。w new UnsupportedOperationException( );
c ec.: • 且节（专事，咱
』、d ·~ ‘
public v。id clear() {
removeRange (0 , size ());
"' ,,
如果李鬼Arrays .ArrayList 内部类覆写这些方法不抛出异常，避免使用者踩进这
仅供非商业用途TIJI.交流学习使用
仅供＃商业用途或交流学习使用
第6 童数据结构与集合
个坑会不会更好。数组具有不为五斗米折腰的气节，传递的信息是“要么直接用我，
要么小心异常｜ ”数组转集合引发的故障还是十分常见的。比如，某业务调用某接口时，
对方以这样的方式返回个List 类型的集合对象， 本方获取集合数据时， 99.9% 是只
读操作，但在小概率情况下需要增加个元素，从而引发故障。在使用数组转集合时，
需要使用李造java. util.ArrayList 直接创建一个新集合，参数就是Arrays .asList 返回的
不可变集合，源码如下i
List<Object> objectList = new java .u til.ArrayL 工st<Object>
( Arrays . asL工st （ 数组） ）；
相对于数组转集合来说， 集合转数组更加可控，毕竟是从相对自由的集合容器转
为更加苛刻的数组。什么情况下集合需要转成数组呢？适配到人的数组接口，或者进
行局部方法计算等。先看一个源码，猜猜执行结果
public class ListToArray {
public static void main(String [] args) {
List<String> list = new ArrayL 工st<String > ( 3 );
list.add （ ” 。口e ” ） ;
list.add （ ” tw 。” ）；
list.add (” three ” );
怕，、飞、气主H S 二ng ］主！k: ' .. ·y. ' －~t: 】、
Object[] arrayl = list.toArray();
':· ＿；：；·＂也、＇ ~ J 、（ 第2 处）
String[] array2 = new String[ 2 ] ;
list.toArray(array2);
System . out.println(Arrays.asLi st(array2)) ;
I a ' y:i 、k 豆｝守； I'< I' ；~ （ 第3 处）
String[] array3 = new String[ 3 ];
l 工st.toArray(array3 );
System.out . println(Arrays.asList(array3));
执行结果如下ι
[null , null ]
[one , two , three]
第l 处比较容易理解，不要用toArray（）无参方法把集合转换成数组，这样会导
16才
仅供＃商业用途或交流学习使用
码出高效： Java 开发手册
致泛型丢失，在第2 处执行成功后， 输出却为null ；第3 处正常执行， 成功地把集合
数据复制到array3 数组申。第2 处与第3 处的区别在于即将复制进去的数组容量是否
足够。如果窑量不够，则弃用此数组，另起炉灶，关于此方法的源码如下
// 王J 八参理＼ ·' ' .1.t'"1qLh 飞才、；，且中之飞. -iJ.口采t d 于1 我吉叮几小
／／才iι 于中的弘， i\ t.. ι 仁人'i))t ’; .ψ 飞:il r' ;,:ii T ’~.
W 千r - '! ' B • 『4 阵、·fi 飞1 ？、哥的；.）－ H ',
public <t> T [] toArray (T [] a ) (
if (a . length < size ) {
I . ＇＇·，、气’！ : s 工ze. 气、，，. ＇： 主. J T 、r~ 川rn （第1 处）
return (T []) Arrays . copyOf (elementData, size , a . getClass ()) ;
美（第2 处）
System . arraycopy(elementData , 0 , a , 0 , size);
if (a.length > size) {
a[size] = null ;
"¥1t. 蒋口j.f-!i' .;,'c 才U tj-.兄下．才’吃｝j 专八九t~
return a ;
在第1 处和第2 处均复制j ava. util. ArrayLi st 的elementData ~IJ 数组中，这
个elementData 是ArrayList 集合对象中真正用于存储数据的数组，它的定义为
transient Object[ ] elementData ； 。
这个存储ArrayList 真正数据的数组由transient 修饰，表示此字段在类的序列化
时将被忽略。因为集合序列化时系统会调用writeObject 写入流中，在网络客户端反
序列化的readObject 时，会重新赋值到新对象的e l ementData 中。为什么多此举？
因为elementData 容量经常会大于实际存储元素的数量，所以只需发送真正有实际值
的数组元素即可。回到刚才的场景，当入参数组容量小于集合大小时， 使用Arrays .
copyOf（）方法，它的源码如下
public static <t> T[] copyOf (U[] original , int newLength , Class<? extends
T [] > newType) {
／／新创建← 1、勃付1 cc,py
T[] copy= ((Object)newType == (Object) Object[] .class)
? (T[]) new Object[newLength]
(T[]) Array . newinstance(newType.getComponentType() , newLength) ;
System.arrayc 。py （。riginal , 0 , copy ， 。，
162
仅供＃商业用途或交流学习使用
第6 章数据结构与集合
Math . min(or 工ginal.length , newLength)) ;
return copy ;
我们用示例代码模拟可能出现的三种情况， 分别为入参数组窑量不够时、入参数
组容量刚好时，以及入参数组容量超过集合大小时，并记录其执行时间，
public class ToArraySpeedTest {
private static final int COUNT= 100 * 100 * 100 ;
public static void main(String[] args) {
L 工st<Double> list= new ArrayList<>(COUNT) ;
for (int i = C ; i < COUNT ; i++) {
list . add(i * 1.0 );
工。ng start = System . nanoTime () ;
Double[] notEnoughArray = new Double[COUNT- l ];
list . toArray(notEnoughArray) ;
long middle!= System . nanoTime ();
Double[] equalArray = new Double[COUNT] ;
list.toArray(equalArray);
long middle2 = System . nanoTime () ;
Double[) doubleArray = new Double[COUNT * );
list . toArray(doubleArray) ;
long end = System . nanoTime ();
long notEnoughArrayTime = middle! - start ;
long equ alArrayTime = middle2 - middl e! ;
long doubleArrayTime = e nd - middle2 ;
System . out.println （ ” ~ r 俨t l I 主y 俨~m
+ notEnoughArrayTime I ( 1000 . C * 1000 . ) + n ” ) ;
System. out . println ( ·’ r m .”
+ equalArrayTime I ( 1000 . 0 * 1000 . 0 ) + ” T\.l " );
System . out .println(
+ doubleArrayTime I ( 1000 . 0 女l 000 . 0 ) + ” m ” );
仅供｜｜商业用途或交流学习使用
才63
码出高效： J ava 开发手册
执行结果如下：
数组长度小于集合大小： n otEno ug hA rray T i m e : 12 . 317 152 ms
数组长度等于集合大小： equalArrayTime : 9 . 327377 ms
数组长度是集合的两倍： doubleArrayTime : 13 . 547622 ms
具体的执行时间， 由于CPU 资源占用的随机性， 会有一定差异。多次运行结果
显示， 当数组容量等于集合大小时， 运行总是最快的，空间消耗也是最少的。由此
证明，如果数组初始大小设置不当，不仅会降低性能，还会浪费空间。使用集合的
toArray(T[] array） 方法，转换为数组时， 注意需要传人类型完全样的数组， 并且它
的容量大小为list.siz巳（）。
6.5 集合与泛型
泛型与集合的联合使用， 可以把泛型的功能发挥到极致， 很多程序员不清楚
List 、List<Obj ect> 、List＜？＞ 三者的区别，更加不能区分＜？ extends T＞ 与＜？ s uper T>
的使用场景。List 完全没有类型限制和赋值限定，如果天马行空地乱用，迟早会遭遇
类型转换失败的异常。很多程序员觉得List<O均ect> 的用法完全等同于List ， 但在接
受其他泛型赋值时会编译出错。List＜？＞是一个泛型， 在没有赋值之前， 表示它可以
接受任何类型的集合赋值，赋值之后就不能随便往里添加元素了。下方的例子很好地
说明了三者的区别，以List 为原型展开说明
public class ListNoGeneric {
164
public static void main(String [] args ) {
I I ~＼ 段· 泛型tll 判之前的fl 公豆豆义方式
List al= new ArrayList() ;
al . add(new Object()) ;
al. add (new Integer ( 111 )) ;
al.add (new Stri ng( "hello ala l ” ) ) ;
’／币工J＼！： ： 把a ·'I （引吭i~· J击a2 . 注意a2 与al 约［｛ )jlj 1i1；增切了泛引限制＜ Object>
List<Object> a2 = al ;
a2.add(new Object ( ) );
a2 . add (new Integer( 222 ) );
a2 . add(new String ( ” hello a2a2 " ) ) ;
/ 第二jQ: ： 把al 引，司吨1盖全a3 . i主t~： a3 与al 的区别是i哲加了：4 守J <.InteqE>r>
List<Integer> a3 = al ;
仅供·11二商业用途或交流学习使用
第6 章数据结构与集合
a3 . add( new Iηteger ( 333 ));
下τ 可斗住气J ~－ . 气二浮宫＋， _j~ Integer ；二恕进入与二告
a3 . add (new Object()) ;
a3 . add(new String ( ” hel_o a3a3 ” )) ;
第：； ：（ ： 飞a 二，￥crtf F去a4 . al 与a ＂的J 号4 足!J';i.; ~u: f于
List<?> a4 = al ;
汇1主士句号召、.， ＇亲手、
al . remove ( 0 ) ;
a4 . clear () ;
／／综译JJ f苦f 允许『吁吁p 任何元素
a4 . add (new Ob j ect());
第一段说明在定义List 之后，毫不犹豫地往集合里装入三种不同的对象
Object、Integer 和S tring ，遍历没有问题，但是贸然以为里边的元素都是Integer ， 使
用强制转化，则抛出C lassCastException 异常。
第二段说明ι 把a l 赋值给a2, a2 是List<Object> 类型的，也可以再往里装入三
种不同的对象。很多程序员认为L ist 和L ist<Object> 是完全相同的，至少从目前这两
段来看是这样的。
第三段说明，由于泛型在JDK5 之后才出现， 考虑到向前兼窑，因此历史代码有
时需要赋值给新泛型代码， 从编译器角度是允许的。这种代码似乎有点反人类，在实
际故障案例中经常出现，来看一段问题代码。
JSONOb] ect jsonObject = JSONObject . fromObject ( ” {\ ” l ~vel ＼ ”： ［＼ ” 3 ＼ ” ］｝ ” ）；
List<Integer> intList = new ArrayList<Integer>( lO ) ;
if (jsonObject != null ) {
intList. addAll (] sonObject . getJSONArray ( ” level ” ));
int amount = O;
for (Integer t ： 工ntList ) {
／／抛出ClassCastException 异常： String cannot be cas t to Integer
if (condit 工on) {
amount = amount + t ;
addAII 的定义如下
public boolean addAll(Collection<? extends E> c) { . .. }
165 I
仅供非商业用途或交流学习使用
码出高效· Java 开发手册
进行了泛型限制，示例中addAll 的实际参数是getJSONArray 返回的JSON Array
对象，它并非是List ， 更加不是Integer 集合的子类，为何编译不报错？查看
JSONArray 的定义
public final class JSONArray extends AbstractJSON impl四1ents JSON , List {}
JSONArray 实现了List ，是非泛型集合，可以赋值给任何泛型限制的集合。编译
可以通过，但在运行时报错，这是一个隐藏得比较深的Bug ，最终导致发生线上故障。
在JDKS 之后，应尽量使用泛型定义，以及使用类、集合、参数等。
如果把a l 的定义从L ist al 修改为List<Object> al ，那么第二段就会编译出错。
List<Object> 赋值给List<Integer＞是不允许的，若是反过来赋值
List<Integer> intList =new ArrayList<Integer>( 3};
intList . add( lll );
L工st<Object> objectList = intList ;
事实上，依然会编译出错，提示如下ι
E1ror:(IO, 26) java: incompatible types: java.util.List<java.lang.lnteger> cannot be converted to
Java. uti I. List勺ava.lang.Object>
注意，数组可以这样赋值，因为它是协变的，而集合不是。
第四段说明问号在正则表达式中可以匹配任何字符， List＜？＞称为通配符集合。
它可以接受任何类型的集合引用赋值，不能添加任何元素， 但可以remove 和clear,
并非immutable 集合。L ist＜？＞一般作为参数来接收外部的集合，或者返回一个不知道
具体元素类型的集合。
List<T> 最大的问题是只能放置一种类型， 如果随意转换类型的话，就是“破窗
理论
JDK 的开发者顺应了民意， 实现了＜？ extends T＞与＜？ super T＞两种语法， 但是两者
的区别非常微妙。简单来说，＜？ extends T＞是Get First ， 适用于， 消费集合元素为主
的场景；＜？ super T> 是Put First ，适用于，生产集合元素为主的场景。
<? extends T＞可以赋值给任何T 及T 子类的集合， 上界为T ， 取出来的类型带有
泛型限制， 向上强制转型为T。null 可以表示任何类型，所以除null 外，任何元素都
不得添加进＜？ extends T> 集合内。
<? super P 可以赋值给任何T 及T 的父类集合，下界为T。在生活中，投票选
举类似于＜？ super p 的操作。选举代表时，你只能往里投选票，取数据时，根本不
I 166
仅供非商业用途或交流学习使用
第6 章数据结构与集合
知道是谁的票，相当于泛型丢失。有人说，这只是一种生活场景，在系统设计中， 很
难有这样的情形。再举例说明一下，我们在填写对主管的年度评价时，提交后若想再
次访问之前的链接修改评价’ 就会被告之
与。” extends 的场景是put 功能受限， 而s uper 的场景是get 功能受限。
下例中，以加菲猫、猫、动物为例，说明ex tends 和s uper 的详细语法差异
// 叫：， d Kt 7 二，UP'i:'t J 的’‘ I
public class AnimalCatCarf工eld {
public static void main(String[] args) {
// i: ))y "'-1.
List<Animal> animal= new ArrayList<Animal>() ;
L 工st<Cat> cat = new ArrayList<Cat> ();
L 工st<Garfield> garfield = new ArrayList<Garfield>() ;
animal . add(new Animal()) ;
cat. add (new Cat()) ;
gar field. add (new Garfield()) ;
I 1 ’:; 2 柑－：
List<? extends Cat> extendsCatFromAn 工mal = animal ;
List<? super Cat> superCatFromAnimal = animal;
List<? extends Cat> extendsCatFromCat = cat;
List<? super Cat> superCatFromCat = cat ;
List<? extends Cat> extendsCatFromGarf ield = garf ield;
List<? super Cat> superCatFromGarfield = garfield;
I , ＜俨·
,, ,
extendsCatFromCat . add( new Animal()) ;
extendsCatFromCat.add(new Cat());
extendsCatFromCat.add(new Garfield());
superCatFromCat . add( new Animal());
superCatFromCat.add( new Cat());
superCatFromCat.add( new Garfield()) ;
r > . .＇ 哑Bt''
167
码出高效· Java 开发手册
／／常4 P.: ,,;i:A'.qet 矿生
／／户，最J T：句SUpf'r 楼外}1~. ＂气如归τ 黑. ff/ 芫，： r~ c.. 生． λ 斗t·'f 、fl'] Obj E'Ct :<f 象：
I I '' 1 ’u nds t.i;, ·I ;: " ＇＇~Pl /I，寿
Object catExtends2 = extendsCatFromCat.get( O);
Cat catExtendsl = extendsCatFromCat.get( O);
II 1 乡，，，＿.吁：吕唱片Ca' 台· l) Carr ~ld fr 明才. l•-1 'f’~＇J 护除后． 是不知吨的
Garfield garfieldl = extendsCatFromGarfield . get( O);
第l 段，声明三个泛型集合，可以理解为三个不同的笼子， List<Animal＞住的是
动物（反正就是动物世界里的动物） , List<Cat> 住的是猫（反正就是猫科动物），
List<Garfield＞住的是加菲猫（又懒又可爱的种猫）。Garfield 继承于Cat ，而Cat
继承自Animal。
第2 段，以Cat 类为核心，因为它有父类也有子类。定义类型限定集合，分别
为List<? extends Cat> 和List<? super Cat>。在理解这两个概念时，暂时不要引人上
界和下界，专注于代码本身就好。把List<Cat> 对象赋值给两者都是可以的。但是把
List<Animal＞赋值给List<Cat> 时会编译出错。因为能赋值给＜？ extends Cat> 的类型，
只有Cat 自己和它的子类。尽管它是类型安全的，但依然有泛型信息，因而从笼子里
取出来的必然是只猫，而List<Animal＞里边有可能住着毒蛇、鲤鱼、蝙蝠等其他动物。
把List<Garfield＞赋值给List<? super Cat＞时，也会编译报错。因为能赋值给
<? super Cat> 的类型，只有Cat 自己和它的父类。
第3 段，所有的List<? extends T> 都会编译出锚，无法进行add 操作，这是因为
除null 外，任何元素都不能被添加进〈？巳xtends T＞集合内。List<? super Cat> 可以往
里增加元素，但只能添加Cat 自身及子类对象，假如放人块石头，贝lj 明显违背了
Animal 大类的性质。
第4 段，所有List<? super T＞集合可以执行get 操作，虽然能够返回元素，但是
类型丢失，即只能返回Object 对象。List<? extends Cat> 可以返回带类型的元素，但
只能返回Cat 自身及其父类对象，因为子类类型被擦除了。
对于个笼子，如果只是不断地向外取动物而不向里放的话，则属于Get First,
应采用＜？ extends T＞，相反，如果经常向里放动物的话，则应采用＜？ super T> ，属于
Put First。
168
第6 章数据结构与集合
6.6 元素的比较
6.6.1 Comparable 和Comparator
Java 中两个对象相比较的方法通常用在元素排序中， 常用的两个接口分别是
Comparab l e 和Comparator ，前者是自己和自己比，可以看作是自营性质的比较器；后
者是第三方比较器， 可以看作是平台性质的比较器。从词根上分析， Co mp ara bl e 以－ able
结尾， 表示它有自身具备某种能力的性质， 表明Comp arabl e 对象本身是可以与同类
型进行比较的， 它的比较方法是compar eTo ，而Co mparator 以－ or 结尾3 表示自身是
比较器的实践者， 它的比较方法是co m pa r e。
我们经常说的自然排序其实是以人类对常识认知的升序排序， 比如数字的1 、1
3 ， 字母的a 、b 、c 等。我们熟知的Integ巳r 和String 实现的就是Compara bl e 的自然排序。
而我们在使用某个自定义对象时，可能需要按照自己定义的方式排序， 比如在搜索列
表对象SearchResult 中进行大小比较时， 先根据相关度排序， 然后再根据浏览数排序，
实现这样的自定义Comparab l e 的示例代码如下。
public class SearchResult implements Com p arable<SearchResu lt> {
int relati veRatio ;
long count;
int recen tOr d e r s ;
public Sea r chResult (int re l ati veRat i o , 1 。ng count ) {
this . re l ativeRatio = relativeRatio ;
this . count = count ;
@Override
public int compareTo (Search Resul t o ) {
//
if ( this .re l at i veRatio ! = o . r e l ati veRatio ) {
return this .relati veRat i o > o . relativeRatio ? 1 : - 1 ;
／／产J• 向
if ( this . count ! = o.cou nt ) {
return this .count > o . co u nt ? 1 : - 1 ;
return O ;
才69
码出高效· J ava 开发手册
public void setRecentOrders (int recentOrders ) {
this . recentOrders = recentOrders ;
实现Comparable 时， 可以加上泛型限定，在编译阶段即可发现传入的参数非
SearchResult 对象， 不需要在运行期进行类型检查和强制转换。如果这个排序的规则
不符合业务方的要求， 那么就需要修改这个类的比较方法compareTo ， 然而我们都知
道开闭原则， 即最好不要对自己已经交付的类进行修改。另外， 如果另一个业务方也
在使用这个比较方法呢？甚至再极端一点， 这个SearchResult 是他人提供的类，我们
可能连源码都没有。所以， 我们其实需要在外部定义比较器，即Comparator。
正因为Comparator 的出现， 业务方可以根据需要修改排序规则。如在上面的示
例代码中， 如果业务方需要在搜索时将最近订单数（ recentOrders ）的权重调整到相关
度与浏览数之间， 贝IJ 使用Comparator 实现的比较器如下所示
public class SearchResultComparator implements Comparator<SearchResult> {
@Overri de
｜ 丁70
pub工ic int compare(SearchResul t ol, SearchResult o2 ) {
吧牛毛度运币－， 于i号呀、． Z 「骂哥、？ （避免if - else 嵌套过多使用卫语句来实现）
if (ol.relati veRatio != o2 . relativeRatio) {
return ol.relativeRatio > o2 . relativeRatio ? 1 : - 1;
飞口号二电关建一样． .,,, { ""'- ~ J 牛二、” ft~ ＇~；
if (ol . recentOrders != o2 . recent0rders) {
return ol . recentOrders > o2 . recent0rders ? 1 : - 1 ;
/ 扣导E ts 艾！吏龟朵二i丁二i'- ~＼ 前一：津、内j 、~1 i毛主t 乍看排前
if (ol . count != o2 . count) {
return ol . count > o2 . count ? 1 : - 1 ;
return O;
在JDK 中， Comparator 最典型的应用是在Arrays . sort 中作为比较器参数进行排序，
public static <t> void sort( T( ] a , Comparator<? super T> c ) {
if (c == null ) {
sort (a ) ;
} else {
第6 章数据结构与集合
if (LegacyMergeSort.userRequested)
l egacyMergeSort(a , c) ;
else
TimSort . sort(a, O, a . length, c , nu工1 , 0 ' 0 ); （第1 处）
红色的＜？ s uper T＞语法为下限通配，也就是将泛型类型参数限制为T 或T 的某
个父类，直到Object。该语法只能用在形参中来限定实参调用。如果本例中不加限定，
假定sort 对象是Integer ， 那么传人String 时就会编译报错，就是充分利用了多态的向
下转型的功能。
约定俗成，不管是Comparable 还是Comparator ， 小于的情况返回一l ， 等于的情
况返回0 ，大于的情况返回l 。当然，很多代码里只是判断是否大于或小于0 ，如在
集合中使用比较器进行排序时，直接使用正负来判断比较的结果
result = comparator.compare(key, t . key);
if (result < OJ
t = t.left ;
else if (result > 0 )
t = t.right;
else
return t;
我们再回到之前s。此（）方法中的TimSort 算法， 是归并排序（ Merge Sort ）与插入
排序（ Insertion Sort ）优化后的排序算法。
首先回顾一下归并排序的原理。长度为l 的数组是排序好的，有n 个元素的集合
可以看成是n 个长度为l 的有序子集合I 对有序子集合进行两两归并，并保证结果子
集合有序，最后得到n /2 个长度为2 的有序子集合，重复上一步骤直到所有元素归并
成一个长度为n 的有序集合。在此排序过程中，主要工作都在归并处理中，如何使归
并过程更快，或者如何减少归并次数，成为优化归并排序的重点。
再回顾插入排序工作的工作原理长度为l 的数组是有序的，当有了k 个己排
序的元素， 将第k+ l 个元素插入己有的k 个元素中合适的位置，就会得到一个长度
为k+l 己排序的数组。假设有n 个元素且已经升序排列的数组，并且在数组尾端有第
n+ l 个元素的位置，此时如果想要添加一一个新的元素并保持数组有序，根据插入排序1
可以将新元素放到第n + l 个位置上，然后从后向前两两比较，如果新值较小则交换位
置，直到新元素到达正确的位置。
171
码出高效· Java 开发手册
2002 年Tim Peters 结合归并排序和插人排序的优点，实现了Tim Sort 排序算
法。该算法避免了归并排序和插入排序的缺点， 相对传统归并排序， 减少了归并次
数， 相对插入排序， 引入了二分排序概念， 提升了排序效率。Tim Sort 算法对于已经
部分排序的数组， 时间复杂度最优可达O(n ） ；对于随机排序的数组， 时间复杂度为
O(nlogn ） ， 平均时间复杂度为O(nlogn ）。因此Java 在JDK7 中使用Tim Sort 算法取代
了原来的归并排序。它有两个主要优化
(I ）归并排序的分段不再从单个元素开始， 而是每次先查找当前最大的排序好
的数组片段run ， 然后对run 进行扩展并利用二分排序， 之后将该run 与其他已经排
序好的run 进行归并，产生排序好的大run 。
( 2 ）引人二分排序， 即b i n arySort。二分排序是对插入排序的优化， 在插入排序
中不再是从后向前逐个元素对比， 而是寻｜入了二分查找的思想， 将一次查找新元素合
适位置的时间复杂度由O(n ） 降低到O(logn ） 。
6.6.2 hashCode 和equals
hash Code 和equals 用来标识对象， 两个方法协同工作可用来判断两个对象是否
相等。众所周知， 根据生成的晗希将数据离散开来， 可以使存取元素更快。对象通过
调用Object.hashCode（） 生成晗希值，由于不可避免地会存在晗希值冲突的情况， 因此
当hashCode 相同时， 还需要再调用equals 进行次值的比较，但是， 若hashCode 不
同， 将直接判定Objects 不同， 跳过equals ， 这加快了冲突处理效率。0均ect 类定义
中对hashCode 和equals 要求如下
( 1 ）如提问咛介J 象的equa ls 的结果是耳目等的． 贝l两个对象的hashCode 的返回约
问饥必须是伯同的。
( 2 ）忏何时侣ITT 写equals ， 郁必须同时覆写hashCode o
在Map 和Set 类集合中， 用到这两个方法时， 首先判断hashCode 的值， 如果
hash 相等， 贝lj再判断equals 的结果， HashMap 的get 判断代码如下·
if (e .hash ==hash && ( (k = e . key) == key 11 (key !=null
&& key . equals(k)) ))
return (e = getNode( hash (key ), key )) ==null? null : e .value ;
1f 条件表达式中的e.hash==hash 是先决条件， 只有相等才会执行阴影部分。如
果不相等， 贝lj 阴影部分后边的equals 根本不会被执行。equals 不相等时并不强制要求
hash Code 也不相等， 但是个优秀的晗希算法应尽可能地让元素均匀分布， 降低冲
1172
第6 章数据结构与集合
突概率，即在e quals 不相等时尽量使hash Cod巳也不相等，这样＆＆或｜｜短路操作一
旦生效，会极大地提高程序的执行效率。如果自定义对象作为Map 的键，那么必须
覆写hash Code 和equals 。此外，因为Set 存储的是不重复的对象，依据hash Code 和
equals 进行判断，所以Set 存储的自定义对象也必须覆写这两个方法。此时如果覆写
了equals ， 而没有覆写has hCode ， 具体会有什么影响，让我们通过如下示例代码深入
体会：
p由lie class EqualsObject {
private int id ;
private String name;
public EqualsObject(int id , Str 工ng name) {
this .id ＝主d;
this . name =name;
@Override
public boolean equals(Object obj) {
／／如果为nu! 1. 或者吁非l目J' . 则直接吃回fa Lor （第1 处）
if （。bj == null I I this . getClass () ! = obj . getClass () ) {
return false ;
／／如果＇－ I 用而向同1 ＇才鼠， !I) 返回true
if ( this == obj) {
return true ;
／／好要.. ~ "· E 午－叶~S'J七〕ect ，打‘
EqualsObject temp = (EqualsOb] ect)obj;
／／本7f; 例子I) 怀4住u 牙i 件而111 等． 逻辑」ι 业号功与f 平y 'fri 不同
if (temp . getid() ==this.id && name.equals(temp.getName())) {
return true ;
return fa工se ;
II getter and setter ...
第l 处说明首先判断两个对象的类型是否相同，如果不匹配，贝lj 直接返回
false 。此处使用getClass 的方式，就是严格限制了只有EqualsObject 对象本身才可以
执行equals 操作。
173
码出高效. Java 开发手册
这里并没有覆写hash Code ，那么把这个对象放置到Set 集合中去：
Set<EqualsObject> hashSet = new HashSet<> ();
EqualsObject a= new EqualsObject( l , ” ) ;
EqualsObject b = new EqualsObject( l , ” ! ” ) ;
EqualsObject c = new EqualsObject( l , ” J ” );
hashSet.add(a);
hashSet.add(b) ;
hashSet.add(c) ;
System . out . println(hashSet . size()) ;
输出的结果是3 。虽然这些对象显而易见是相同的，但在Has h Set 操作中，应该
只剩下一个，为什么结果是3 呢？因为如果不覆写hash Code （），即使equals （）相等也
毫无意义，。同ect.hashCode（） 的实现是默认为每一个对象生成不同的int 数值，它本
身是native 方法，一般与对象内存地址有关。下面查看C ＋＋的源码实现．
VM_ENTRY(jint, JVM_IHashCode （♂HEnv* env, j object handle) )
JVMWrapper ( ” ., ) ’ ’
return handle == NULL ? 0 : ObjectSynchronizer : : FastHashCode
(THREAD, JNIHandles : : resolve non null(handle)) ;
VM END
ObjectSynchronizer 的核心代码如下，从代码分析角度也印证了hashCode 就是根
据对象的地址进行相关计算得到int 类型数值的，
mark = moni tor- >header () ;
assert(mark- >is neutral(), '….1 • r , u ” ) ;
hash= mark- >hash() ;
工ntptr t hash() const {
return mask bits(value ()> hash shift , hash mask);
因为EqualsObject 没有覆写hash Code ，所以得到的是一个与对象地址相关
的唯一值，回到刚才的Has h Set 集合上，如果想存储不重复的元素，那么需要在
EqualsObject 类中覆写hashCode():
@Override
public int hashCode() {
return id+ name.hashCode() ;
174
第6 章数据结构与集合
EqualsObject 的name 属性是String 类型， String 覆写了hash Code （），所以可以直
接调用。e quals （） 的实现方式与类的具体处理逻辑有关，但又各不相同，因而应尽量
分析源码来确定其判断结果，比如下列代码，
public class ListEquals {
public static v。id main(Str 工ng[] args) {
LinkedList<Integer> linkedList = new LinkedList<Integer> ();
linkedList.add( l );
ArrayList<Integer> arrayList = new ArrayList<Integer> ();
arrayList.add( l );
if (arrayList.equals(linkedList)) {
System . out.println （ ” 1 、. ) ;
} else {
System . out.println( L f il0t' ” );
两个不同的集合类，输出的结果是equals is true。因为ArrayList 的equals （）只进
行了是否为L ist 子类的判断，接着调用了equalsRange （） 方法·
bo。lean equalsRange(List<?> other , int from, int to) {
final Object[] es = elementData ;
var oit = other.iterator();
for (; from < to; from++) {
（第1 处）
（句： 2 在I:)
if (!oit.hasNext() 11 !Objects.equals(es[from], oit.next())) {
return false;
F 产f: ·.' f
return !o 工t . hasNext();
第1 处说明：局部变量类型推断（ Local Variable Type Inference ）是JDKlO 引人
的变量命名机制，一改Java 是强类型语言的传统形象，这是Java 致力于未来体积更小、
面向生产效率的新语言特性，减少累赘的语法规则，当然这仅仅是一个语法糖， Java
才75
码出高效· Java 开发手册
仍然是一种静态语言。在初始化阶段，在处理var 变量的时候， 编译器会检测右侧代
码的返回类型， 并将其类型用于左侧， 如下所示
var a = ” string” ;
／／输出： class java . lang . String
System. out.printl n (a . getClass ( ) ) ;
var b = Integer . value0f( 7 ) ;
/ 输出： class java . lanq . Irteger
System.out . pr 工ntln(b . getClass() );
／／编译出错虽然是var , fl目是依然存在类型限'.ii::
b = 3 . 0 ;
b 在第一次赋值时，类型推断为Integer ，所以在第二次赋值为double 时编译出错。
如果一个方法内频繁地使用var ，则会大大降低可读性，这是一个权衡， 建议当用var
定义变量时， 尽量不要超过两个。
第2 处说明， 尽量避免通过实例对象引用来调用equals 方法， 否则容易抛出空
指针异常。推荐使用JDK7 引人的Objects 的equals 方法， 源、码如下， 可以有效地防
止在equals 调用时产生NPE 问题·
public static boolean equals(Ob] ect a , Ob] ect b ) {
return (a == b) I I (a ! = null && a . equals (b ));
6. 7 fail-fast 机制
fail-fast 机制是集合世界中比较常见的错误检测机制， 通常出现在遍历集合元素
的过程中。下面通过校园生活中的一个例子来体会fail-fast 机制。
上课前， 班长开始点名。刚点到半， 这时从教室外三三两两进来若干同学， 同
学们起哄．点错了！班长重新开始点名， 点到中途，又出去几位同学， 同学们又起哄说
点错了，班长又需要重新遍历， 这就是fail -fast 机制。它是一种对集合（ 班级） 遍历
操作时的错误检测机制， 在遍历中途出现意料之外的修改时， 通过unchecked 异常暴
力地反馈出来。这种机制经常出现在多线程环境下， 当前线程会维护一个计数比较
器， 即expectedModCount ， 记录已经修改的次数。在进入遍历前， 会把实时修改次数
modCount 赋值给expectedModCount ，如果这两个数据不相等， 贝lj 抛出异常。java.util
下的所有集合类都是fail-fast ， 而concurrent 包中的集合类都是fail-safe 。与fail -fast 不同，
fail-safe 对于刚才点名被频繁打断的情形， 相当于班长直接拿出手机快速照相， 然后
｜ 才76
仅供非商业用途或交流学习使用
第6 章数据结构与集合
根据照片点名，不再关心同学们的进进出出。
人的大脑习惯用单线程方式处理日常逻辑，思维在某个时间段或某个深度上具
有方向性。多线程的运行逻辑并非自然思维。我们通过ArrayList.subList（） 方法进
步阐述fail-fast 这种机制。在某种情况下，需要从个主列表master 中获取子列表
branch , master 集合元素个数的增加或删除，均会导致子列表的遍历、增加、删除，
进而产生fail- fast 异常。f为代码分析如下
public class SubListFailFast {
public static void main (String[] args) {
List masterList = new ArrayList();
masterList . add ( ” e ” ) ;'
masterList . add ( ” L T。” ）；
masterList . add ( ” three " );
masterList . add ( ” cour " ) ;
masterList . add ( ” t ive " ) ;
List branchList = masterList.subList( 0 , 3 ) ;
／／于11 fT 代码. 1;ri 呆不平ff j中. Vl1J 会~i' 纹branchList 操作出现异常（第1 处）
masterList . remove( O);
masterList . add ( ” ten ” );
masterList.clear() ;
11 f iii'Yi'r 全部也l哝.if 吻j九1-1
branchList.clear() ;
branchList . add ( ” six " );
branchList . add ( ” seven” );
branchList.remove( O);
I I if 咛：1; !fJ 结＇＂ . ; r 一卡JC ., : seven
for (Object t : branchList) {
System . out . println(t );
// f 川｜农1 改字型生1 4 习毛也Uf f专:J1 . 输出： :seven , four , five]
System . out.pr 工ntln(masterList );
仅供－11二商业用途或交流学习使用
才77
码出高效· Java 开发手册
第l 处说明，如果不注释掉， masterLi st 的任何关于元素个数的修改操作都会导
致branchList 的“增删改查”抛出ConcurrentModi fi ca ti onExcepti on 异常。在实际调研中，
大部分程序员知道subList 子列表无法序列化， 也知道它的修改会导致主列表的修改，
但是并不知道主列表元素个数的改动会让子歹lj表如此敏感，频频抛出异常。在实际代
码中，这样的故障案例属于常见的类型。subList 方法返回的是内部类SubLi st 的对象，
SubLi st 类是ArrayL ist 的内部类， SubList 的定义如下， 并没有实现序列化接口， 无法
网络传输·
private static class SubList<E> extends AbstractList<E> implements
RandomAccess { .. . }
在foreach 遍历元素时， 使用删除方式测试fail-fast 机制， 查看如下代码·
public class ArrayListFai lFast {
public static v。id main (String [] args ) {
L i st<Str 工ng> l 工st = new ArrayList<Str 工ng> () ;
list.add( "o11e ” ) ;
list.add (” t•'c. ” ) ;
l 工st.add (” thrr>e” ) ;
for (String s : list ) {
if （ ” t ；，.；。” . equa l s (s)) {
list.remove(s) ;
System . out . printl 口（ 1 工st) ;
编译正确， 执行成功！输出［one， 也回］。说好的ConcurrentModificationException 异
常呢？这只是一个巧合而已。在集合遍历时维护一个初始值为0 的游标cursor ， 从
头到尾地进行扫描，在cursor二size 时，退出遍历。如图6-2 所示， 执行remove 这
个元素后， 所有元素往前拷贝， size=size- 1 即为2 ，这时cursor 也等于2。在执行
hasNextO 时， 结果为false ，退出循环体，并没有机会执行到nextO 的第一行代码
checkForComodificationO ， 此方法用来判断expectedModCount 和modCount 是否相等，
如果不相等，贝IJ抛出ConcurrentModificationExcepti on 异常。
178
仅供二｜｜二商业用途或交流学习使用
第6 章数据结构与集合
cursor=2
e lementData[ size=2] =null ;
[OJ [ l ) [ 2 )
1. ha sNext() {cursor !=size )
2 . 口e xt ()
3 . · remove{)
4 . System . arraycopy ()
one tlm~e
11 1 1 - 1
图6 2 集合的cursor 与s i ze
这个案例应引起对删除元素时的fail -fast 的警觉。我们可以使用Iterator 机制进行
遍历时的删除， 如果是多线程并发， 还需要在Iterator 遍历时加锁，如下源码：
Iterator<Str 工ng> i t erator= l i st . iterator() ;
while (iterator . hasNext ()) {
syn ch r onized （ 对象）｛
String item= iterator . next () ;
if （删除元素的条件） {
iterator . remove() ;
或者使用并发容器CopyO nWriteArrayL i st 代替ArrayL i st ， 该容器内部会对
Iterator 进行加锁操作。顺便简单介绍一个cow （ 奶牛）家族， 即Copy-On-Write 。
它是并发的种新思路，实行读写分离， 如果是写操作， 贝lj 复制一个新集合， 在新集
合内添加或删除元素。待一切修改完成之后， 再将原集合的可｜用指向新的集合。这样
做的好处是可以高并发地对cow 进行读和遍历操作， 而不需要加锁， 因为当前集合
不会添加任何元素。使用cow 时应注意两点，第一，尽量设置合理的窑量初始值，
它扩容的代价比较大，第二， 使用批量添加或删除方法， 如addA ll 或removeA ll 操作，
在高并发请求下， 可以攒一下要添加或者删除的元素， 避免增加一个元素复制整个集
合。如果集合数据是IOOMB ， 再写入50MB ， 那么某个时间段内占用的内存就达到
( I OOMB x 2 ) +50MB=250MB ，内存的大量占用会导致GC 的频繁发生， 从而降低
服务器的性能， 我们观察如下代码。
public static void main (String [ ] args ) {
Li st<Long> copy= new CopyOnWriteArrayLis t <Long> ();
long start= System . nanoTi me () ;
for (int i =O; i <20 *10000 ; i ++ ) {
copy . add(System . nanoTime( ) ) ;
才79
仅供二｜｜二商业用途或交流学习使用
码出高效： Java 开发手册
循环20 万次，不断地进行数据插入，这对cow 类型的集合来说简直是灾难性
的操作，本示例执行时间为97.8 秒， 如果换成ArrayList ，贝lj 只需39 毫秒，差距巨
大！要初始化这样的cow 集合，建议先将数据填充到ArrayList 集合中去， 然后把
Array List 集合当成cow 的参数，这就是使用批量添加的另种方式。这种个接一
个往里增加元素的场景，简直就是cow 的阿喀琉斯之踵。所以明显cow 适用于读
多写极少的场景。
cow 是fail-safe 机制的，在并发包的集合申都是由这种机制实现的， fai l-safe 是
在安全的副本（或者没有修改操作的正本） 上进行遍历，集合修改与副本的遍历是没
有任何关系的，但是缺点也很明显，就是读取不到最新的数据。这也是CAP 理论中
C ( Consistency ）与A ( Availability ）的矛盾，即一致性与可用性的矛盾。
6.8 Map 类集合
在数据元素的存储、查找、修改和遍历中， Java 中的Map 类集合都与Co llection
类集合存在很大不同。它是与Co llection 类平级的一个接口， 在集合框架图上， 它有
条微弱的依赖线与Collection 类产生关联，那是因为部分方法返回Collection 视图，
比如values（）方法返回的所有Value 的列表。Map 类集合中的存储单位是KV 键值对，
Map 类就是使用一定的晗希算法形成一组比较均匀的晗希值作为Key, Value 值挂在
Key 上。Map 类的特点如下
• Map 类取代了旧的抽象类Dictionary ，拥有更好的性能。
·没有重复的Key ，可以有多个重复的Value 。
•Value 可以是List 、Map 、Set 类对象。
•KV 是否允许为null ，以实现类约束为准。
Map 接口除提供传统的增删改查方式外，还有三个Map 类特有的方法，即返回
所有的K町，返回所有的Value ， 返回所有的KV 键值对。源码加注释如下
／／返回Map ~. <-i, 中的Key il'J Set 移到
Set<K> keySet();
／／毛；＂J Map 芝对巧！句｛句所有Value 气；di~ Collect i ?n
, f电于•'J 夜’ ' ＂：， 守Jalues ext nds Abstra户Fo hctio 叮＜ v/
Collection<V> values() ;
180
仅供＃商业用途或交流学习使用
第6 章数据结构与集合
, I ＇＇~. 1?1 明ap 主－，，［ '" ·1 Yey -Va ue ,. 乌Set t吃喝
Set<Map . E口try<K , V> entrySet( );
通常这些返回的视图是支持清除操作的， 但是修改和增加元素会抛出异常， 因为
AbstractCollection 没有实现add 操作， 但是实现了remove 、c l ear 等相关操作。所以
在使用这些视图返回集合时，注意不要操作此类相关方法。是否将KV 设置为null,
以实现类约束为准，这是一个十分难以记忆的知识点， 如表6-1 所示。
表6-1 主要的Map 类集合
Map 集合类Key Value Supe 「JDK 说明
Hash table 不允许为null 不允许只l 111111 Dictionary 1.0 线程安全（过时）
Conc11rrentHashMap 不允许为111111 不允许· ）'111 1111 AbstractMap 1.5 锁分段技术或CAS
( JDK8 及以上）
Tree Map 不允许为null 允许为null AbstractMap 1.2 线程不安全（有序）
HashMap 允许为nu ll 允许为null AbstractMap 1.2 线程不安全（ res i ze
死链问题）
从1.0 → 1.2 → 1.5 ，这几个重点的KV 集合类见证了Java 语言成为工业级语言
的成长历程。从线程安全到线程不安全，再到线程安全， 经历了否定之否定的过程，
不断走向成熟。在大多数情况下， 直接使用ConcurrentHashMap 替代HashMap 没有
任何问题， 在性能上区别并不大， 而且更加安全。抽样调查发现， 近八成的程序员认
为ConcurrentHashMap 可以置人nu ll 值，毕竟它与HashMap 是近亲，而HashMap 的
KV 都可以为nu ll。比如， 在某次配置xml 肘，如果只是把Key 复制过来，没有做相
关的null 判断就置人ConcurrentHashMap ， 就会导致NPE 异常，但是子线程的异常并
不会抛给主线程，所以排查颇费用于斤。在任何Map 类集合申，都要尽量避免KV 设
置为null 值。
6.8.1 红黑树
l 树（ Tree)
树是一种常用的数据结构， 它是一个由有限节点（本书统称为节点，而不是结点）
组成的个具有层次关系的集合， 数据就存在树的这些节点中。最顶层只有一个节点，
称为根节点， 类似于图6-3 中在悬崖边上倒着生长的树， root 是根节点。在分支处有
才81
仅供二｜｜二商业用途或交流学习使用
码出高效Java 开发手册
一个节点，指向多个方向，如果某节点下方没有任何分叉的话，就是叶子节点。从某
节点出发，到叶子节点为止，最长简单路径上边的条数，称为该节点的高度，从根节
点出发，到某节点边的条数，称为该节点的深度。如图6- 3 所示的树，根节点root 的
高度是5 ，深度是O ；而节点2 的高度是4 ，深度是I 。树结构的特点如下
( I ）一个可点，即只有根可点，也可以是一棵亿元。
( 2 ）其中任何一个丐点与卜面所有节点构成的树林冗子明。
( 3 ）根节点没有父巧点，而肘子可点没有子节点。
( 4 ）除根币点外＇＂±何节点有巨仅有个父可点。
( 5 ）任何节点可以有0 ～ n 个子节点。
图6-3 树的来源
至多有两个子节点的树称为二叉树，图6-3 所示的恰好是二叉树。二分法是经典
的问题拆解算法，二叉树是近似于二分法的一种数据结构实现，二叉树是高效算法实
现的载体，在整个数据结构领域具有举足轻重的地位。在二叉树的世界中，最为重要
的概念是平衡二叉树、二叉查找树、红黑树。
? 一. ..，，，－：； 如才
如果把图6-3 中的左侧枝叶全部砍掉的话，那么剩余的部分还是树吗？是的，但
只是以“树”之名，行“链表”之实，如图6-4 (a ）所示。如果以树的复杂结构来实
现简单的链表功能，贝lj 完全埋没了树的特点。看来对于树的使用，需要进行某种条件
才82
仅供｜非商业用途或交流学习使用
第6 章数据结构与集合
的约束，如图6-4 ( b ）所示，让链表一样的树变得更有层次结构，平衡二叉树就呼之
欲出了。图6-4( b ） 的高度差为5 ，而右侧树由9 与8 组成的递归右子树的，高度差为1 ,
高度差是一棵树是否为平衡二叉树的决定条件。
飞
9
8
8
(a)
( ED)
图6-4 “链表树”与平衡树
平衡二叉树的性质如下
( 1 ）树的左右高度差不能超过l 。
( 2 ）任何往下递归的左子树与右子树，必须符合第一条性质。
( 3 ）没有任何节点的空树或只有根节点的树也是平衡二叉树。
图6-4 (a ）明显不符合第条标准，因此它不是平衡二叉树，而图6-4 ( b ） 为
平衡二叉树。
3. 一叉士找树
二叉查找树又称二叉搜索树，即B inary Search Tree ，其中Search 也可以替换为
Sort ，所以也称为二叉排序树。Java 中集合的最终目的就是加工数据，二叉查找树也
是如此。树如其名，二叉查找树非常擅长数据查找。二叉查找树额外增加了如下要求·
对于任意节点来说，它的左子树上所有节点的值都小于它，而它的右子树上所有节点
的值都大于它。查找过程从树的根节点开始，沿着简单的判断向下走，小于节点值的
往左边走，大于节点值的往右边走，直到找到目标数据或者到达叶子节点还未找到。
遍历所有节点的常用方式有三种前序遍历、中序遍历、后序遍历。它们三者的
规律如下，
( 1 ）在任何递归子树中，左节点一定在右节点之前先遍历。e 才83
仅供＂Ii＇商业用途或交流学习使用
码出高效。Java 开发手册
( 2 ） 前序、中序、后序，仅指根节点在遍历时的位置顺序。
前序遍历的顺序是根节点、左节点、右节点，中序遍历的顺序是左节点、根节点、
右节点；而后序遍历的顺序贝lj 是左节点、右节点、根节点。
如图6 -5 所示， 按中序遍历图申二叉查找树， 坐标轴的顺序就是中序遍历。
7
I - 1 、
,
1 1 2 1 4 1 71 8 1 9
图6-5 二叉查找树的中序遍历
根据二叉查找树的性质要求， 下面来“ 美化”一下本节最开始的那两棵树， 使它
们成长为二叉查找树。
图6-6( a ） 的红色节点8 与节点9 进行互换，节点9 成为节点8 的右子树，形成图6-6
( b ） ；图6-6 ( c ） 的红色节点8 移动到左子树上，把紫色的节点2 与节点4 互换一下，
形成图6-6 ( d ）。经过调整后，再查看任何递归子树，都是符合二叉查找树的要求，
所以两棵新树都为二叉查找树。但明显右下方这棵新树要优于右上方那棵，因为更加
平衡，查找效率更高。可以看出，二叉查找树窑易构造，但是如果缺少约束条件，很
可能往一个方向野蛮生长，成为查找复杂度为O(n） 的树。所以二叉查找树需要引入一
种检测机制， 随着新值的插入动态地调整树结构。那如何调整呢？下文中的红黑树就
是来回答这个疑问的。
／卢飞＼ 才84 / _/ ＇－ 、, ___ ,
I • 111 I
、、J I
仅供非商业用途或交流学习使用
第6 章数据结构与集合
飞飞
4 4
7 7
8
9
( a )
) ln (
、
1
’
’
c (
( <l )
罔6-6 转化成二叉查找树
二叉查找树由于随着数据不断地增加或删除容易失衡， 为了保持二叉树重要的平
衡性， 有很多算法的实现， 如AVL 树、红黑树、SBT( S ize Balanced Tree ）、Treap( 树堆）等。
考虑到在Java 底层框架很多算法实现以红黑树为基础， 所以先简单介绍一下A叽树，
然后重点介绍红黑树。
4 . AVL 树
AVL 树算法是以苏联数学家Ade l so n-Velsky 和Landis 名字命名的平衡二叉树算
法， 可以使二叉树的使用效率最大化。AVL 树是一种平衡二叉查找树， 增加和删除节
点后通过树形旋转重新达到平衡。右旋是以某个节点为中心， 将它沉入当前右子节点
的位置， 而让当前的左子节点作为新树的根节点1 也称为顺时针旋转；同理， 左旋是
以某个节点为中心， 将它沉入当前左子节点的位置， 而让当前右子节点作为新树的根
节点， 也称为逆时针旋转。
AVL 树就是通过不断旋转来达到树平衡的， 下方的左旋和右旋只是旋转操作层e 185
码出高效Java 开发手册
面的简单示意图， 我们应体会如何通过旋转达到一种新的平衡状态，不再基于插入和
删除进行展开，右旋示意图如图6 - 7 所示。
右旋
图6-7 右旋示意图
图6-7 所示左侧是非平衡状态，需要进行平衡化处理，根节点的左子树与右子树
高度差超过l ，向右旋转。在旋转过程中，节点15 成为新的根节点， 而节点16 移动
到节点17 的左节点上。而左旋转则反之， 如图6- 8 所示。
①
①
＠ ①
θ
①
①
θ~＇①
① 22 23- 25
格均到22 的右节点
5 . 红黑材
图6-8 左旋示意图
红黑树是于19 72 年发明的，当时称为对称二叉B 树， 197 8 年得到优化，正式命
名为红黑树。它的主要特征是在每个节点上增加一个属性来表示节点的颜色，可以是
红色，也可以是黑色。
红黑树和AVL 树类似，都是在进行插入和删除元素时，通过特定的旋转来保持
自身平衡的， 从而获得较高的查找性能。与AVL 树相比，红黑树并不追求所有递归
® 186
仅供非商业用途或交流学习使用
第6 章数据结构与集合
子树的高度差不超过l ， 而是保证从根节点到叶子节点的最长路径不超过最短路径的
2 倍，所以它的最坏运行时间也是O(logn）。红黑树通过重新着色和左右旋转，更加
高效地完成了插入和删除操作后的自平衡调整。当然， 红黑树在本质上还是二叉查找
树， 它额外寻｜入了5 个约束条件，
( I ）节点只能是红色或黑色。
( 2 ） 根节点必须是黑色。
( 3 ）所有NIL 节点都是黑色的。NIL ，即叶子节点下挂的两个虚节点。
( 4 ）一条路径上不能出现榈邻的两个红色节点。
( 5 ）在任何递归子树内， 根节点到叶子节点的所有路径L包含相同数目的黑色
可±占,, J 飞内。
总结一下，即“有红必有黑，红红不相连”，上述5 个约束条件保证了红黑树的新增、
删除、查找的最坏时间复杂度均为O(logn ）。如果一个树的左子节点或右子节点不存在，
则均认定为黑色。红黑树的任何旋转在3 次之内均可完成， 红黑树的演进示意图在分
析完TreeMap 的核心源码后，会呈现给大家，耐心往下看。
6. 红黑树与AVL 树的比较
先从复杂度分析说起，任意节点的黑深度（ Black Depth ） 是指当前节点歪IJ NIL （ 树
尾端）途径的黑色节点个数。根据约束条件的第（ 4 ） 、( 5 ） 条，可以推出对于任意
高度的节点，它的黑深度都满足Black Depth 二E height I 2。也就是说，对于任意包
含n 个节点的红黑树而言，它的根节点高度h 运2log2( n + l ） 。常规BST 操作比如查找、
插入、删除等，时间复杂度为O(h ） ，即取决于树的高度h。当树失衡时，时间复杂度
将有可能恶化到O(n ） ， 即h =n 。所以， 当我们能保证树的高度始终保持在O(logn ） 时，
便能保证所有操作的时间复杂度都能保持在O(logn ） 以内。
红黑树的平衡性并不如AVL 树，它维持的只是种大致上的平衡， 并不严格保
证左右子树的高度差不超过l 。这导致在相同节点数的情况下，红黑树的高度可能
更高，也就是说， 平均查找次数会高于相同情况下的AVL 树。在插入时，红黑树和
AVL 树都能在至多两次旋转内恢复平衡。在删除时，由于红黑树只追求大致上的平
衡， 因此红黑树能在至多三次旋转内恢复平衡，而追求绝对平衡的AVL 树，则至多
需要O(logn ） 次旋转。AVL 树在插入与删除肘，将向上回溯确定是否需要旋转，这
个回溯的时间成本最差可能为O(logn），而红黑树每次向上回溯的步长为2 ， 回溯成
本降低。因此，面对频繁的插入和删除，红黑树更为合适『面对低频修改、大量查询e 才87 1
仅供非商业用途或交流学习使用
码出高效· J ava 开发手册
时， AVL 树将更为合适。为了更形象地理解红黑树的“ 大致平衡” ， 我们对红黑树
与AVL 树同时进行以下操作， 按顺序依次插入36 、34 、37 、33 、35 、32。此时， 红
黑树与AVL 树结构的区别如图6θ 所示。
/\\
φ
图6-9 红黑树与AVL 树结构的区别
我们可以直观地感受到左侧AVL 树的绝对平衡， 以及右侧红黑树的相对平衡，
至于红黑树为什么呈现成这个样子， 将在下节详细分析。
6.8.2 TreeMap
TreeMap 是按照Key 的排序结果来组织内部结构的Map 类集合， 它改变了
Map 类散乱无序的形象。虽然TreeMap 没有ConcurrentHashMap 和HashMap 普及
（ 毕竟插入和删除的效率远没有后两者高） ，但是在Key 有排序要求的场景下， 使
用TreeMap 可以事半功倍。在集合框架图中， 它们都继承于AbstractMap 抽象类，
TreeMap 与HashMap 、ConcurrentHashMap 的类关系如图6-10 所示。
® I 才88
φ
仅供Ii ＇ 商业用i主或交流学习使用
第6 章数据结何与集合
《inte 「face 》
Sorted Map
Na： ；；：：~e~ap l<J
6
AbstractMap
« interface >
ConcurrentMap
今
ConcurrentHashMap
图6-10 T ree M ap 与其他TreeMap 相关类图
在TreeMap 的接口继承树申，有两个与众不同的接口SortedMap 和NavigableMap 。
SortedMap 接口表示它的Key 是有序不可重复的， 支持获取头尾Key-Value 元素，或
者根据Key 指定范围获取子集合等。插入的Key 必须实现C omparable 或提供额外的
比较器Comparator ， 所以Key 不允许为null ， 但是Value 可以； NavigableMap 接口
继承了SortedMap 接口， 根据指定的搜索条件返回最匹配的Key - Value 元素。不同于
HashMap, TreeMap 并非定要覆写hash Code 和equals 方法来达到Key 去重的目的。
pub 工ic class TreeMapRepeat {
public static void main(String[ ) args ) {
／／如果仅把此怜的TreeMap 换成HashMap ， 员t size = 1
TreeMap map= new TreeMap () ;
map . put(new Key () , ” value one " ) ;
map . put (new Key () , ” value tw 。” ） ；
11 TreeMap. size=2 . 因为Key 去重规~lj 是根据排序结束
System . out . println (map . s i ze ());
class Key implements Comparable<Key> {
自Override
／／返回负的常被． 丧示Jlt，对军永巧’j 、于知入的other 对象． 此处决I:( TreeMap 的size=2
public int compareTo(Key other) {
return - 1 ;
189
仅供Ii＇ 阳业用i主DJ/. 交流学习使用
码出高效， Java 开发手册
1 司垦的
自Override
public int hashCode() {
return 1 ;
a
@Override
public boo lean equals(Object obj) {
return true ;
上述示例把红色的TreeMap 换成HashMap, size 的结果贝lj 从2 变为l 。注意
HashMap 是使用hashCode 和equals 实现去重的。而TreeMap 依靠C omparable 或
Comparator 来实现Key 的去重。这个信息非常重要，因为如果没有覆盖正确的方
法，那么TreeMap 的最大特性将无法发挥出来，甚至在运行时会出现异常。如果要用
Tree Map 对Key 进行排序， 调用如下方法
final int compare(Ob] ect kl , Object k2) {
return comparator== null
? (( Compa rable<? super K>)kl) .compareTo((K)k2)
compa rat o r. compare ( (K) kl, (K) k2);
如果comparator 不为null ， 优先使用比较器comparator 的compare 方法，如果为
null ，贝IJ 使用Key 实现的自然排序Comparable 接口的compare To 方法。如果两者都无
法满足， 贝lj 抛出异常
Exception in thread "main” java.lang.ClassCastException : Key cannot be cast to java.base/java.
Jang.Comparable at java . base/java.util.TreeMap . compru叫TreeMap.java : 1291)
基于红黑树实现的TreeMap 提供了平均和最坏复杂度均为O(logn ） 的增删改查操
作，并且实现了NavigableMap 接口，该集合最大的特点是Key 的有序性。先从类名
和属性开始分析，
public class TreeMap<K,V> extends AbstractMap<K , V>
implements NavigableMap<K , V> , Cloneable , java. 工o . Serializable {
’~ 毛士！. p认ζ b 芸哥
private final Comparator<? super K> comparator ;
® 1190
仅供＇Ii＇ 商业fflj盘成交流学习使用
第6 章数据结构与集合
I 1r- i; .~. pu liji 一』二qi;' "'
private transient Entry<K , V> root ;
士’f 成为t: 'j 'iJ 户俨＇， 丁与fixAfterinsertion （）得拆时Z'' ,it ~＇Jj
private static final boolean RED = false ;
private static final boolean BLACK = true ;
阴.p Ii 勺甘F I ，主~！ 'r 羔，，士＇，＼＂川、U·）屯哝哇、在；＇ 1' TreeMap 卡J F司出现
static final class Entry<K , V> implements Map.Entry<K,V> {
K key;
V value ;
Entry<K , V> left; ／／才！向f 子树均引rt;
Entry<K , V> right ; I I ., ，.~右F 和[1;'111 ff,
Entry<K,V> parent ; // .'· B句式节点的号I 'f.
I I f; :?: ＇、＇.＂＇户；， f 朽的飞f 吁在电默认是主；笆
boolean color = BLACK;
TreeMap 通过put （） 和deleteEnt可（） 实现红黑树的增加和删除节点操作， 下面的
源码分析以插入主流程为例，删除操作的主体流程与插入操作基本类似，不再展开。
在插入新节点之前， 需要明确三个前提条件，
( I ）帚要调整的新节点总是红色的。
( 2 ） 如果插入新节点的父节点是黑色的， 无须调整。因为依然能符合红黑树的
5 个约束条件。
( 3 ）如果插入新乍点的父节点是红色的，因为红黑树规定不能出现相邻的两个
红色节点， 所以进入循环判断． 或重新着色，或左右旋转， 最终达到红黑树的五个约
束条件，：垦吟i 条件女［丁、
while (x ！＝ ηull && x != root && x . parent . color ==RED) { ... }
如果是根节点，则直接退出，设置为黑色即可；如果不是根节点， 并且父节点为
红色，会一直进行调整，直到退出循环。
TreeMap 的插入操作就是按Key 的对比往下遍历，大于比较节点值的向右走，小
子比较节点值的向左走，先按照二叉查找树的特性进行操作，无须关心节点颜色与树
的平衡， 后续会重新着色和旋转，保持红黑树的特性。put 的源码分析如下
19才
仅供11：商业用i主或交流学习使用
码出高效： Java 开发手册
public V put(K key, V value) {
I 192
11 t. 表示当前节点． 记住这个很1f.r 要1 先把TreeMap 的恨节点root 引用赋值给当前节点
Entry<K,V> t = root ;
／／如果当前节点为null ， 即是空树， 新增的KV 形成的节点就是恨节点
if (t == null ) {
／／看似事此一举，实际卡j啧检了Key 是否可以比较
compare (key , key) ;
／／使用KV 构：走出新的Entry 对蒙． 模中第工个多主我是pare 口t. 垠节点没有父节点
root= new Entry<>(key, value , null );
size = l ;
modCount++ ;
return null ;
II cmp 用来接收比较结果
int cmp;
Entry<K , V> parent ;
／／构吨方法中'f 入的外部比较if~
Comparator<? super K> cpr = comparator;
11 ,J! 点步扩J ：根据二支夺坊ν 的特吨． 扎菲1）新节点插入的合适位W
if (cpr != null ) {
／／循环的目标· 根据朱主i Key 与均前节点的Key 平的地：生竹对土
do {
／／当前节点叫也给父节点，故从根节点开始消历H:.1{
pare 口t = t;
／／比较输入的各歧Key f口句前节点Key 的大小
cmp = cpr . compare(key , t.key);
／／参敛呐Key 堤小‘向J’边走. 1'j!l 当前节点引「自f多功吉它的左子节点上
if (cmp < )
t = t . left ;
／／来吱均Key 、大．向右边走. fr' 率百：节点'JI ;rJ 侈才f 古的右子节点上
else if (cmp > )
t = t . right;
／／如果相罕．可lj f全，；~忍地m 盖句前节点的Value 倍，并返回吏新前的值
else
return t.setValue(value);
／／如果f 百十自1 叮Key . 一直会咆历.f1) NIL 节点为止
} while (t ! = null );
／／在1z 有指定比较嚣的’情况下‘调1罚自然才1t: 序的Comparable 比较
else {
if (key == null )
thr。w new NullPointerException();
Comparable<? super K> k = (Comparable<? super K>) key;
do {
仅供＃商业用途或交流学习使用
第6 章数据结构与集合
parent = t ;
cmp = k . comp areTo (t . key );
if (cmp < 0 )
t = t . left ;
else if (cmp > 0 )
t = t.ri ght ;
else
return t . set Val ue (va lue );
} while (t ! = null );
11 !'1].rl:_ Entry -it 寄：．并拧＇ parent fi 入参t1<
Entry<K, V> e = new E口try<> (k ey , value , parent) ;
／／新节点找到自己的位置. fl甲乍以为可以安顿下米一一一一一
if (cmp < )
else
／／如果比转结束个号o. 则成为parent 的左孩子
parent .left = e ;
／／如东比中〈结来中于0. Yl') 成为parent 的右孩子
parent . right = e ;
11 ＇£«寄一电t ;<, { i、所节衍生f丁if 帝T 苟色和旋转操’f. ；） 达到孚衡
fixAf t eri nsertion (e );
／／伙子＂＂人吨中
size++ ;
modCount++ ;
／／成功t~ 入如节，＂I; ;._• •.-_ 1,•1 甘 null
return null ;
如果一个新节点在插入时能够运行到自xA负erlnse时ion（） 进行着色和旋转， 说
明· 第一， 新节点加入之前是非空树i 第二， 新节点的Key 与任何节点都不相同。
fixAfterinsertion （） 是插入节点后的动作， 和删除节点操作中的fixAfterDeleti on（） 的原
理基本相同， 本节重点以新增节点为例讲解fixA负erlnsertion（） 源码。
private v。id fixAfterinsertion (Entry<K, V> x) {
I I 1'i\. 吹内邱主Entry 的li~U color F井认为黑色．！旦新节点一律先吠值为红色
x . color = RED ;
／／树节点；二4日节点或背其父Yi 点（简称为父亲）为黑色
／／插入h 汽节＂~ ij: F 尖破坏hM{ 怜的性质嘈无知l 调整
II x 倍的改变代用h 萨，高亮显水，改变的过程旦在不断地质l t 游边历（戎内部调整）
／／直到父亲斗黑色． 戎者到达恨节点
while (x != null && x '= root && x.parent . color == RED) {
193
仅供＇II二商业用途或交流学习使用
码出高效· Java 开发手册
/ 回4
、
if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
I I ·~斗； ， fr" ' （石1 ,' )
Entry<K, V> y = rightOf(parentOf(parentOf(x)));
F生嘈4 矗
24 -aR
真
if (colorOf(y) ==RED) {
／／ γ、段；J ：！！， 古2
（ 第1 处）
setColor (parentOf (x), BLACK) ;
.; ＇贝知;iJ f::
setColor(y, BLACK);
／／爷爷＇1 g 红色
setColor(parentOf(parentOf(x)), RED);
‘h 爱护’1 ., .• .＿＇川
、. ...‘」」、
x = parentOf(parentOf(x));
// 古口！在右才； .!t_ ＂骂台． 叫，，·舍’加F ,,:r 枯
} else {
I I 1• 桌x E 父亲约古f 节点．豆，对£亲做次夺－~ 1'专H:
'I 砖作二义卖？ ’厅q 句’ih 卅
if (x == rightOf(parentOf(x))) {
.if: ~＼ ，；，巧与信x 斗、》百入
主v
x = parentOf (x) ;
rotateLeft(x);
牛，什. ＇~ ~ -t.;
setColor (parentOf (x) , BLACK) ;
setColor(parentOf(parentOf(x)), RED);
rotateRight(parentOf(parentOf(x)));
与L 万冽影fV:t日I:{ , t;11 ！史t 手飞才亏的巧J fJ
告. "
root.color = BLACK;
在上方源码中，第1 处出现的colorOf（）方法返回节点颜色。调整后的根节点必
然是黑色的2 叶子节点可能是黑色的，也可能是红色的，叶子节点下挂的两个虚节点
即NIL 节点必然是黑色的，下方源码中的p==null 时，返回为BLACK。这些都是红
I 194
黑树的重要性质。
private static <K,V> boolean colorOf(Entry<K,V> p) {
return (p == null ? BLACK : p.color);
第6 章数据结构与集合
左旋和右旋的代码基本类似，这里仅讲解左旋代码。请结合之前的旋转示例图，
输入参数为失去平衡的那棵子树的根节点。
private void rotateLeft(Entry<K,V> p) {
节、、： N I
if (p != null ) {
/
Entry<K , V> r = p.right;
1 I r ＂·＇句斗也' :1 L n3 J 纣
p . right = r.left;
if (r . left != null )
r.left.parent = p;
J 一、
r . parent = p . parent;
'l.7 r · f 丁”丁’f J
I I .i: ＇（口$可， E .. :· i:: ＇卢· ＇.， rd 中仕代p f句’t
if (p.parent == null )
root = r ;
else if (p.parent.left == p)
p.parent.left = r ;
else
p.parent.r 工ght = r;
' t 吁. .: r ' y' r， η 』j
r.left = p;
p.pare 口t = r;
初步学完TreeMap 构造方法、插入、着色、旋转的相关源码之后，举一个简单
的例子进一步体会红黑树的平衡策略。构造一个自然排序的TreeMap 对象，插入、删
除数据的示例代码如下。
TreeMap<Integer, String> treeMap = new TreeMap<Integer , Stri 口g>();
treeMap . put( 55 , ) ;
treeMap.put( 56 , 1• -.L );
195
码出高效， J ava 开发手册
treeMap . put ( S7 , ” fifty-seven ” ) ;
treeMap . put ( 58 , ” fifty- eight” ) ;
treeMap . put( 83 , ” eighty - three ” );
treeMap . remove ( 57 ) ;
treeMa p . p u t ( 59 ， ” f 工fty - nine " );
为什么在58 和59 之间插入83 和删除57 呢？是因为需要构造这样的场景旋转
两次（先右旋， 再左旋） 。
第一步， 如图6 - 1 1 所示， 先分析55 、56 、57 三个数的插入操作。图中的55 在
插入时是空树， 它就是根节点， 根据红黑树约束条件， 根节点必须是黑色的， 将节点
55 涂黑。继续插入节点56 与节点57 ， 新节点的颜色设置为红色。当插入56 时， 由
于父亲是黑色节点， 不做任f可调整当插入57 时， 由于父节点56 是红色的， 出现两
个连续红色节点， 需要重新着色， 并且旋转。完成之后如图6-11 ( e ）所示。
@
(a) ( b ) ( c ) ( d) ( e )
图6- 1 l 节点55 、56 、57 的插入操作
第二步， 如图6 - 12 所示， 再分析节点58 的插入操作。父亲57 是爷爷56 的右节
点，左叔55 为红色。这时把父亲和左叔同时涂黑，把爷爷56 设置为红色。因为爷爷
56 是根节点， 退出循环， 最后旬代码是root.colo r=BL A CK ，重新把56 涂黑。完成
之后如图6-12 ( c ）所示。
第一种情形
) a r
t
、( h)
图6- 1 2 节点58 的插入操作
)
ρ
iv
(
｜ 才96
第6 重数据结构与集合
第三步， 如图6- 13 所示， 再分析节点83 的插入操作。根据自然排序结果， 从
根节点5 6 开始比较， 比56 大、比57 大、比58 大， 所以放置在58 的右子节点上。
在重新调整平衡时， 父亲58 是爷爷57 的右子节点， 左叔不存在， 认为是黑色NIL 。
这时把父亲颜色涂黑，把爷爷设置为红色。此时， 爷爷57 为失去平衡的那棵小树
( 57/58/83 ） 的根节点， 将它作为输入参数， 进行左旋操作。完成之后如图6 - 13 ( c )
所示。
、、， ／
( a ( i3 )
( c)
图6- 13 节点83 的插入操作
第四步， 删除57。因为节点57 没有任何子节点， 也非根节点， 本身又是红色，
不影响红黑树性质， 直接删除即可。
第五步， 如图6 -1 4 所示， 删除57 之后， 再分析” 的插入操作。根据自然排序结果，
从根节点56 开始比较， 比56 大、比58 大、比83 小， 放置在83 的左子节点上。对
于59 ， 只有满足如下条件，才会进入右旋转操作
· 父亲是爷爷的右子节点，
· 当前节点是父亲的左子节点；
· 左叔是黑色的（ 删除57 的原因所在） 。
右旋之后， 把59 涂黑， 把58 置为红色， 然后以58 为输入参数， 进入左旋操作，
完成之后如图6 -1 4 ( d ）所示。
197
码出高效. Java 开发手册
第二种情形
(a )
( c)
第三种情形
( h )
♂
( d )
图6-14 节点59 的插入操作
在树的演化过程中， 插入节点的过程中，如果需要重新着色或旋转， 存在三种情
形， 如图6- 12 和图6-14 所示。
( I ）节点If! ；.（羔居红1 . 叔叹是红色的， 川l雪茄fjfi 》
( 2 ）书点的父亲足±二年， ． 坟报是黑色的， 而乒巧汽是欠亲的左节点进行右旋。
( 3 ）节点的v 亲F 红萨， 句叹是黑色的， 而俨可λ 是？宅的右节卢进行杀；在。
如图6-14 所示， 在旋转时， 箭头方向的引出端均为红色。插入55 、56 、58 ， 删
除57 均并没有引起树的旋转调整。红黑树相比AVL 树， 任何不平衡都能在3 次旋转
之内调整完成。每次向上回溯的步长是2 ， 对于频繁插入和删除的场景， 红黑树的优
势是非常明显的。
总体来说， TreeMap 的时间复杂度比HashMap 要高一些， 但是合理利用好
TreeMap 集合的有序性和稳定性， 以及支持范围查找的特性， 往往在数据排序的场景
中特别高效。另外， TreeMap 是线程不安全的集合，不能在多线程之间进行共享数据
的写操作。在多线程进行写操作时， 需要添加互斥机制，或者把对象放在Collections .
synchroinzedMap(treeMap） 中实现同步。
在JDK7 之后的HashMap 、Tree Set 、ConcurrentHashMap ， 也使用红黑树的方式
才98
第6 章数据结构与集合
管理节点。如果只是对单个元素进行排序， 使用Tre e Set 即可。TreeSet 底层其实就是
TreeMap, Value 共享使用一个静态Object 对象， 如下源码所示。
private static final Object PRESENT = new Object{) ;
public b。olean add (E e ) {
return treeMap . put(e , PRESENT ) ==null ;
6.8.3 HashMap
分析完Tr己eMap ， 再来学习一下HashMap。除局部方法或绝对线程安全的情形外，
优先推荐使用ConcurrentHashMap。二者虽然性能相差无几， 但后者解决了高并发下的线
程安全问题。HashMap 的死链问题及扩容数据丢失问题是慎用H邵阳ap 的两个主要原因。
例如， 某个应用在initO 方法中初始化一个static 的HashMap 集合对象， 从数据库
提取数据到集合中。应用启动过程中仅单线程调用一次初始化方法， 不应该有任何问题。
但机缘巧合下， initO 被执行了两次， 启动失败、CPU 使用率飘升， dump 分析发现存在
HashMap 死链。第l 种解决方案是用ConcurrentHashMap 替代Has刷ap ； 第2 种解决方
案是使用Collections.synchronizedM a p(hashMap ） 包装成同步集合，第3 种解决方案是对
in i t（） 进行同步操作。此案例最终选择第3 种解决方案， 毕竟只有启动时调用而已。
再说另外一个案例， 新应用上线不久就发现在业务高峰期，一台服务器CPU 使
用率舰升到100% ， 从监控平台上发现大量请求超时， 初步认为是服务器负载容量不
够， 采取紧急扩容并重启，服务顺利恢复正常。但数日后， 同样的问题再次出现， 通
过jstack 命令分析， 发现了大量RUNNABLE 状态的线程都在执行HashMap 的put 和
get 操作， 日志如下
” ιF 牛Z Pc.es ！＂~－ － ' " daemon pr 工o=lO tid=Ox00007flf0c808800
nid=Oxl0a4c runnable [0x000000004b860000) Thread . State: RUNNABLE at
HashMap.get(HashMap . ] ava:464)
初步定位， 可能与使用HashMap 进行并发读写有关。先介绍一下HashMap 体系
中提到的三个基本存储概念， 如表6-2 所示。
表6-2 晗希类集合的三个基本存储概念
名桥、说日月
table 存储所有节点数据的数组
slot 晗希槽。即l a bl e (i］ 这个位置
hu P-kel ＂ 合希梢。la hl e[i ］ 上所有元素形成的表或数的集合
199
码出高效Java 开发手册
图6-15 左侧黄色实线框即为table 数组，红色箭头指向的即是晗
个位置标识，对应于tabl e 数组下标，虚线所框的晗希桶是包含头节王
槽上形成的链表或树上的所有元素的集合。黄色部分的数组长度就是t< f ’
有咕希桶的元素总和即为HashMap 的size 。
哈希槽
table
slot-0 －圃， 0 -+ --’
slot-I -+
slot-2 -+ 2 -+
slot-14 ”... 14
slot-15 寸15 • l - i －＋ ~ |• ; _ : bu制E古希桶
图6 -15 哈希槽与哈希桶
为了分析死链问题， 这里使用JD K7 的源码来分析Ha shMap 新增元素的过程·
public v put(K key , V value) {
int hash = hash(key) ;
int i= indexFor(hash , table . length) ;
／／此信环通过hashCode 迟冈佼找到对内的教务l 下杯位置
／／街口呆equals 结果为真＇ 11111 J电幸原f白电如果都为false ． 贝1J 添加元素
for (Entry<K, V> e = table ［工］； e != null ; e = e . next) {
Object k;
／／如果Key 的hash －：~ la 同的．那么再进行如下判断
, Key 是有I ;I~ if 叹·,i;· equals~ 因为哀， ＇：1) .I＼；盖原点的Value 值
if (e.hash ==hash && ((k = e . key) ==key 11 key . equals(k ) )) {
V oldValue = e . value ;
e . value = value ;
return oldValue;
11 :i~ ♀古！：＇加天嘉戎i王；t modCount＋＋ . 将为后？t. 留下很多A~. 忠
modCount++;
／／苦吃去＇ rf. 飞J 后＿，戈4 二是table 数纽约下行
addEntry(hash , key , value , i) ;
return null ;
void addEnt ry (int hash, K key , V value , int bucketindex) {
／／如果元袤的个必达到threshold 约扩容：号值旦放给］下杯！、i..f＂ 已经存在元素， 则进行扩容
1200
仅供Ii ＇ 商业用i主或交流学习使用
第6 章数据结构与集合
if ((size>= threshold) && (null ! = table[bucketindex])) {
／／扩容2 倍， size fi：实际存放;it 丰的才放啕而length k 敌细的容，－r 六1) (capacity)
resize (2 *table .length) ;
hash = (null 1= key ) ? hash (key ) : 0 ;
bucketindex = indexFor (hash , table.length );
createEntry(hash , key , value , bucket i ndex) ;
I I 1rli ／、元孝付咱l在插／、在头部． 而不毛尾部
void createEntry( int hash , K key , V value , int bucketindex) {
／／不管原来的放绍对应的下标元素是否为null ， 都作为Entry 的bucketindex 的next ti'
Eηtry ＜瓦， V> e = table [bucketindex ); （第1 处）
／／即使原来是H: 表，也铲整条H 剖l 拴在新插入的节点k
table[bucketindex] = new Entry<> (hash, key , value , e );
size++ ;
如上源码， 在create E ntry（） 方法中，新添加的元素直接放在s lot 槽上，使新添
加的元素在下次提取时可以更快地被访问到。如果两个线程同时执行到第l 处时，
那么一个线程的赋值就会被另一个覆盖掉， 这是对象丢失的原因之一。我们构造一
个HashM ap 集合，把所有元素放置在同一个晗希桶内， 达到扩窑条件后， 观察一下
resiz e（） 方法是如何进行数据迁移的， 示例代码如下
public class HashMapS 工mpleResize {
private static HashMap map= new HashMap ();
public static void main(String [ ] args) {
／／扩容11'1 ，司值是table . length* 0 . 75
／／第一次扩容发生在第13 个九紊F 人时（ 第1 处）
for (int i = O; i < 13 ; i + + ) {
map.put( new UserKey (), new EasyCoding( ));
class UserKey {
～飞飞飞飞飞
-- ~
201
仅供Ii＇ 阳业用i主DJ/. 交流学习使用
码出高效： J ava 开发手册
,, ·" 'f "'r ... r· t r t ' d，品’、k ~ i虽可
public int hashCode ( ) {
return 1 ;
I ;';\ 1it 巳hash li 韭豆h 正。（（民= 阜. key) ~ key I I key. 『quala (k) 'g fau;e
IJJ J' ·11 t ue, !Jl•! ＇.、~＼.，个K I ·"'.;ff.ι ；f. ＇苦．在f JfJ ~斗＿ h
public boolean equals ( Object obj ) {
return false ;
第i 处说明， 我们再介绍一下与扩窑相关的概念，如表6-3 所示。
表6 3 与扩容相关的概念
名智、说日月
length ta ble 数组的氏度
size 成功通过put 方法添加到H as h Map 中的所有元素的个数
has h Co rl e Obj ec Lhas h Co d eQ 返回的川值，尽可能地离散均匀分布
has h Obj ecLhash Cod eQ 与当前集合的t able.l e ngth 进行位运算的结果， 以确定哈希糟的位置
这些都是十分眼熟却易混淆的HashMap 相关概念值。理想的哈希集合对象的存
放应该符合，
· 只要对象不一样， hash C od e 就不一样；
· 只要hashCode 不一样，得到的hash Code 与hash S eed 位运算的hash 就不一样；
· 只要hash 不样，存放在数组上的slot 就不样。
理想与现实是有差距的。比如， 公司开个圆桌会议， 有12 把槽子， 必须按
照某种规则， 把12 个位置坐满。如果hashCode 按公司职务来计算， 但公司只设
置了Pl ～ P8 八个级别， 贝lj 百分百会有碰撞， 如果h a shCode 按工号来计算，虽然
hash Code 是唯一的， 但是以员工号与12 进行取模后， 工号为1 与工号为13 的员工
恰好被分配到同一把椅子上。晗希碰撞的概率取决于h a sh Code 计算方式和空间窑量
大小。
继续举例，如果某公司给1 2 个员工的会议安排了100 把椅子，虽然可以大大地
减少冲突概率， 但是会造成资源、浪费。那么具体需要准备多少把椅子合适呢？负载因e
φ
仅i!t 非商业用远成交流学习使用
第6 章数据结构与集合
子就是用以权衡资源利用率与分配空间的系数。默认的负载因子是0 .7 5 ，即12 个人
的会议， 相当于需要12÷0.75 = 16 把椅子， mod 16 比mod 12 的冲突概率要小一些，
也不会像mod 100 那样浪费资源。随着会议范围变大， 参与会议的人数越来越多，当
人数＞（椅子数量× 负载因子）时会进行扩容。在Ha shMap 中，每次进行res ize 操
作都会将窑量扩充为原来的2 倍。
多个元素落在同个晗希桶中就会形成链表（ JDK7 之后，可能会随链表长度增
加进化为红黑树）。这个链表的头节点保存在哈希槽上， 所以遍历Map 的元素从两
个方向进行：第一个方向，从下标table [ OJ 至table[len gth - 1 ］ 遍历所有晗希槽，第二个
方向，如果晗希槽上存在元素，贝lj 遍历晗希桶里的所有元素。
回到Ha shMapSimple Resize 的示例代码上， 我们在i== l2 ， 即插入第13 个元素时，
此时触发扩窑条件（ 13 > 16X0 .7 5 ）， 其中16 是默认容量大小， 0.75 是默认负载因子。
在resi ze 操作时，通过调试可以看到旧表和新表的数据变化情况， 如图6 -16 所示。
川口1 { @:)59) 56
’ 市oldTable[1).ne悦＝ {Hashl·/,ap$lnlryt乱鸣。｝ "" ->”14483609,13” |
’ 缸oldTab附］.next.next = {Ha:-.hMap饪川「yro;SC1 ） 川”〉叮915964414,13 “ |
_. W OldTable[1].next.next.next = {HashMa 昨日：1 尸ρ 说2户”＋” 383492599, 13” |
w new [1] ｛！细问3 臼
_. w newTable[1].next = {Hashrl.upSEntry 伺机川”〉叮915964414,13 ” |
’• w newTab 』e[1].ne沈阳xt = i.Hasl1Ma 川f:ntry ：必i60) •• －＞叮4483609, i3• I
II> w newTable[1 ］.帽xt.next.next = ｛灿灿阳ρ$Entry(<;iJS59 ｝ ”飞〉勺。目41347,13 ” |
图6-1 6 扩容迁移时的链表逆序排列调试结果
第4 次元素复制完成之后，即可知晗希桶内的元素被逆序排列到新表中。如何被
逆序排列的呢？我们仔细看－下JDK7 中resize（） 和非常重要的transfer（） 数据迁移源
码，
void resize( int newCapacity) {
Entry[] newTable = new Entry[newCapacity];
Dl' r 飞co' '• ＇ ， 咱也j 1 I ' 1凡与.1 · ',.j '" i. F 川i, 1 om 11 T n l ( ) . ;; tr N .JL l斗
transfer(newTable , initHashSeedAsNeeded(newCapacity)) ;
?!
1 )I 事，j f即与； 4
table = newTable;
、T ' -' 14
203
仅供非商业用i主ex交流学习使用
码出高效： Java 开发手册
threshold= (int)Math.min(newCapacity * loadFactor ,
MAXIMUM CAPACITY + 1) ;
I I ））、i日步’t 移放据到新表寥寥fL fr 啕极为重要
void transfer(Entry[] newTable, boolean rehash) {
／／外部悉数传人时． 指定新表的大小为： 2*oldTable . length
int newCapacity = newTable . length ;
／／使用foreach 方式选历整个放组下朽、
for (Entry<K,V> e : table) {
／／也口呆此slot 上存在元东． 则进行选历． 直到i e==null. 退出循环
while (null != e) {
Entry<K, V> next= e . next ;
／／当前元主总是直接放在社绍下标的slot 上．而不是放在统表的最后
if (rehash) {
e.hash = null == e . key? 0 : hash(e . key) ;
int i= indexFor(e .hash , newCapacity) ;
／／把原来slot 上的元素作为当前元素的下一个
e. 口ext= newTable[i] ;
／／新迁移过来的节点直接放置在slot 位置上
newTable[i] = e;
／／链表继续向下边历
e = next ;
transfer（） 数据迁移方法在数组非常大时会非常消耗资源。当前线程迁移过程中，
其他线程新增的元素有可能落在已经遍历过的晗希槽上1 在遍历完成之后， table 数
组引用指向了newTable ， 这时新增元素就会丢失，被无情地垃圾回收。
如果resize 完成， 执行了table = newTable ， 贝lj 后续的元素就可以在新表
上进行插入操作。但是如果多个线程同时执行resize ， 每个线程又都会new
Entry[ newCapacity］， 这是线程内的局部数2且对象， 线程之间是不可见的。迁移完成后，
resize 的线程会赋值给tab l e 线程共享变量，从而覆盖其他线程的操作，因此在“ 新表”
中进行插入操作的对象会被无情地丢弃。总结下， HashMap 在高并发场景中， 新增
对象丢失原因如下
®1204
@
仅供非商业用途或交流学习使用
第6 章数据结构与集合
·并发赋值时被覆盖。
·己遍历区间新增元素会丢失。
·“新表”被覆盖。
·迁移丢失。在迁移过程中，有并发时， next 被提前置成null 。
数据丢失是HashMap 除死链外带人的另一个高并发问题，但通常不被重
视。因为数据丢失的环节非常长，而且不会形成脏数据，所以不易察觉，不像
死链那样火烧眉毛，比较明显。如图6-17 所示， 10 万个线程采用均匀的Key 往
同一个HashMap 放置不同的自定义对象EasyCoding ，观察内存中的对象数量。
Results 。囚i Collected data 臼Snopshot Perform GC Heap Dump
Nome live Bytes ... Live O问ects
民，＂＇田........,... •••• , I _ ..., ,. .... .，~，.，－. ..恤 咱……四阴四”’圃”酬
图6-17 HashMap 并发时产生对象丢失
多线程下新i曾对象时， “丢失”了1092 个对象。这与在对象赋值阶段产生的覆
盖有关。此时单击图6-1 8 中的Perfom1 GC 按钮进行垃圾回收，贝lj 可以看到对象又少
了8055 个，在迁移过程中丢失引用的对象在此阶段被回收，剩下的数据都被Map 强
51 用持有。
Results
Nome
。因Collected data CiJ Snopshot
Live 时tes ...
[1 ＿.，.，.....，.，.，＿回m
图6- 1 8 GC 回收Hash Map 中失去引用对象
L叫
接下来分析死链问题，将示例代码进行抽象。启动10 万个线程，以System.
nano Time（）返回的Long 值为Key ， 自定义对象EasyCoding 为Value ，运行环境是
JDK7 ， 示例代码如下
public class HashMashEndlessLoop {
private static HashMap<Long , EasyCodi 口g> map = new HashMap<Long,
EasyCoding>();
public static void main(String[] args ) {
for (int i = 0 ; i < 100000 ; i++ ) {
(new Thread () {
public v。id run() {
map. put (System . nano Time() , new EasyCoding () ) ;
} ) . start () ;
205
仅iJ 飞H二商业用途或交流学习使用
码出高效· Java 开发手册
class EasyCoding {}
程序运行后不久， 对象计数达到l 万个左右时， l oad 呈阶梯式上升，如绿色箭头
方向所示， 4 核机器的CPU 使用率上升到304 . 7% ，如图6- 19 红色箭头方向所示。
户广O'"''S 飞号三二313 ~9cal, 7 俨J门广l 户g , 336 sleeping , 2185 tt:reaos
回国lmtL"r.lf(i田园也－－1 LOa'i A 吁： 1 白. 75 , · 18 . 15 , 20 . 68 I CPU usage: 89 . 87乞［ user , 9 . 87 、sys ， 自. 24但id le Sha 「edl i bs : 24
M 仔作＂＂＇；： ens: 75348 ~ota l , 7日'l7M r芒S id en t , 213刊pri·1at 哇， 15日9M sha f 叹J. PhysMerr, : i6G used I 204 0
VM: 9J巳G V 弓l ze ， 日2iM fra~e,10 ：’卡vs 11e ， 自！ 0) s•.- 1ap~ns ， 。（白） S'.·1apouts . tJ e t\olO r·ks ； 口ackets : 2285 97
Disks: 321 月12/0323M rξad , 66368/2511M virnte仁．
。ID f 仔仔1;.; fl '..:(Pli 丁刀，IE llTH 11'1/Q #POP MEM PIJRG CMPR PGRP PPID STATE BOOSTS
4816 J aγa - 3自4 . 7 2 白： 27 . 86 28/5 1 94 38 日·I ＋ 自B OB 435 435 r unnrn 日本日［ l ]
图6- 19 出现Hash Map 死链时的资源情况
到底是哪些线程导致C PU 使用率如此之高呢？通过监测工具查看图6 -20 中的两
个线程，一直处于Rill刑ING 状态，已经持续运行了1 8 分钟，相信死链已经形成，
才会导致如此严重的资源消耗。
St lcmd Name ll:30AM Running
,,._mμ冒I －••＂酌’n;11.川~•II咀凹’
＠ 口”irea d - 12296 1,097,080 ms 1 1:1
图6-20 H ashM ap 处于死链的两个线程
使用jstack 命令查看一下，分别在哪几行代码上遇到了问题，如图6 -21 所示。
” Thread-12296" pri。＝ 5 t1d=0x00007fb33682d800 nid=0xb50f runnable (0x0000700010683000]
java. tang.Thread.State: RUNNABLE
at Java. ut1 l. Hash问ap (transfer(HashMap.java:601
at Java. ut i l. HashMap. resize { HashMap. j ava: 581 J
at 1ava.ut1l.HashMap.addEntry(Hash问ap.java:879)
at j ava. uti l. Hash问ap. put ( 11ashMap. j ava. 505)
at HashMapEndlessLo 。pSl. run(Hash问apEndlessL 。。p. java: 12)
Locked ownable synchronizers·
None
"Thread-10 799" prio= 5 tid=0x00007 fb337049000 nid=0x 5803 runnable (0x0000700010 580000]
java. tang.Thread.State: RUNNABLE
at 1ava.util HashMap l put(HashMap.java.494)
at HashMapEnd lessloopsl. run ( HashMapEndlessLoop. j ava: 12)
图6 -21 jstack 线程信息
这两处都存在对晗希桶内链表的遍历访问，其中， 60 1 行是循环提取同一个晗希
桶里的所有元素， 然后逐一倒序插入新表中。而494 行也是遍历访问， 在新增元素之
® 206
®
仅供非商业用途或交流学习使用
第6 章数据结构与集合
前进行hashCode（） 和equals（） 判断， 决定是覆盖Value 值， 还是新增一个链表节点，
源码如下
if (e. hash == hash && ( (k = e . key) == key 11 key. equals (k))) {
我们分析494 行的链表情况，如图6 -22 所示，红色箭头表示死链对象的循环指
向， 从节点5415 指向5416 ，而5416 回指向5415 （在classLoader=null 表示HashMap
是由Bootstrap 类加载器加载的）。
’ = ”Thread - 10799” prio=S tid=l0808 RUNNABLE
T atjava uul.HashMap put lilashM.p.1avi 19'11
T local variable Cl java.util HashMap$Entry#5415 [GC r。。t - Java frame)
、， ＜ fi e l ds >
~ hash ＝ 口in t 1179784955
， 泪next = o java.uttl HashMap$Entry#5416
3目hash z 口i nt 1746769659
T ~ next= u java util HashMap$Entry#5415 [GC root - Java 衍ame]
3目hash 王且.i.nL.ll 7978495 5
~ next 4@ loop Jto jav a.uti l. HashMapSEnt町， 5416
• 冒E value 豆百E磊K。ding#5354
l ， 盲’ key = U java.lang.Longtt5356 1 刊·15」Qj9019的l·Iυυυ l
~ static <ela 目Loader> = o null
.v.al阻止三五LE as~瓜。”d.io.gι5.3.5.5.
....占. 1J.'f:1l’国TIT!'
static <elassl。ader> = o null
I> ~ value = o EasyC。ding # 5354
.. ~ k町＝ o java.lang.Long#5356 i, 3'1 川03901%51·1000
图6 22 死链节点的形成
我们再来详细计算一下两个Key 是否落在同一个slot 晗希槽，如表6-4 所示。
表6 -4 从hashCode 值到落槽位置的计算
方法说明Ent「y#5415 Entry#5416
nanoTimeO
long 类型，自动装箱为
15348203901965 14000L 15348203907958570001
Long 包装类对象
hashCodeQ (int)( value <(value >> 32)) 1123830739 1847921515
通过Hash Map 的hashSeed
hashO 对hash Code 进行重新计算， 1179784955 1746769659
尽可能离散
indexForO slot 槽的数组下标5883 5883
扩展说明一下， 由于Integer 的hash Code（）就是自身的值，因此有些人误以
207
仅供11：商业用i主或交流学习使用
码出高效： Ja v a 开发手册
为Long 的hash Code（） 也是自身值， 实际并非如此。以图6-23 为例， 先获取Long
( 1534820390 l 965 l 4000L ）的二进制值，然后右移32 位后， 再与原来的值进行异或，
最后进行int 的强制类型转换， 相当于高位被截掉， 如图6-23 阴影部分所示。
~ ',· L 。川叫
' L 。ng.t。B＂飞aryStrir、g （（＇门IJi,53482口39 口1965140 。OL 《（ 153482039 口196514000L >» 32)), I
10101010011001100011100000011010I011110110000I0001100110 I 0000
异或结果00010101010011001100011100000011
01000010111111000100101111010011
图6 - 23 计算h as h 时的位移运算
在异或的结果中， 不一样的都是l ， 一样的都是0 。这个算法比较普遍， 在很多
hash 计算场景中都用到过。这样做的原因是， hash Code 的返回值是int ，如果此集合
内某些Key 是由int 向上转型而来的， 那些long 的值直接截取高位， 会形成很大的冲
突；如果仅拿高位， 当long 的取值范围在Integer.MAX_VALUE 之内时， 结果都是0 。
所以将高位与低位进行异或， 有助于泊松分布。
从表6-4 可以看出， 经过3 步的计算， 得到晗希槽位置为5883 。直接访问table 数组，
查看下标为5883 存储的链表元素， 验证这一系列的推断， 如图6- 24 所示。
I V 毡［ 5883 ） 卡O j ava.ut i l.HashMap$Entry#541 ~ [GC root - Java frame]
凶hash ＝ 口int 11797 阳55 f …' tal>le[5883]
v 、『next = o j ava .ut il.HashMap$Entry#54 16
hash ＝ 口i nt 1746769659
.. 、
V 回next = o j ava. util.HashMap$Entry# 5415 [GC root - Java frame)
hash ＝口i nt 1179784955
｜ 三· next - ~ .. ~ looρto 1ava. 川. HashMapSEntrylf5416 I
图6-24 Has hMap 特定哈希槽的节点信息
此前的10799 号线程虽然只是读操作，但是既成事实的死链会导致该查询陷入
死循环。这就验证了在本节之初的第二个故障打出来的jstack 日志， get （） 始终处于
RUl叶'1'ABLE 状态。那死链是如何形成的呢？这里12296 号线程也被绕在死链中， 它
所在的transfer （） 方法， 正是生产死链的地下黑工厂， 这里只分析关键步骤。为了方
便理解， 直接以slot=5883 进行继续分析
while (null != e) {
Entr y< K, V> next = e .next ;
e . next = newTable[ 3];
newTable [ ' ] = e ;
导2 0 8
（第1 步）
（第2 步）
（第3 步）
第6 章数据结构与集合
e = next; （第4 步）
本示例最后次扩容十分耗时， 大量线程都在齐心协力地一起做数据迁移工作。
其中， Key 在同一个s l ot 上的链表在进行遍历时， 在第2 步和第3 步之间形成了数据
互相覆盖的情形。而对于死链的生成， 需要先明确三点
( I ）原夕τλ 有r- i.；主的问/: slot 节点il年足台y ~； 技）｜肝？走芫υ 因为e 和
n ext 都是线程内的局部变量， 是绝对不会互相干扰的， 所以w hi le 循环在此次生成死
链的过程中是会正常退出的。
1 2 1 table 以主且正Lft ！－：封呈臼ρ ［ _-k‘」共； J 修改的对象。
( 3 ） 阴阳、get （） 王C transfer() 种操作在运行到此拥有开性节slot 上， CPU 仗用
率都含在A 升。
图6 - 2 5 所示为HashMap 的旧表结构。
。,,
一「LLJ
叫5415 1 next I →曰
罔6-25 Has hM ap 的旧表结构
两个线程A 和B ， 执行tran sfe r 方法， 虽然n ewTabl e 是局部变量， 但是原先
ta bl e 中的Entry 链表是共享的。产生问题的根源是Entry 的next 被并发修改。这可能
导致
( I ）到象λ 失。
( 2 ）两个对象可惧。
( 3 ＼对a, 气,::::J '1 {it
形成环路的原因是两个线程都执行完第一个节点的遍历操作后，到第二个节点时，
产生互链， 如图6 - 26 所示。
209
码出高效， J ava 开发手册
5883 16384 32i68
生是程A Entry巧4 15
叫到1 6 lnext ！ ＆ 囚
气883 16384 32768
线程B E 川口气门尹
叫刘16 l next I s 囚
主主导呈A
\
囚。
线斗呈B
、
囚。
完成全部
5883
|||||
开始第2 次循环第一步
5416 next 之前
因6-26 Has hMap 死链分析示意阁
JDK7 的扩容条件是（ size >= threshold) && (n ull != table[bucketlndex ］）， 即达到阔
值，并且当前需要存放对象的slot 上已经有值。从代码上看， 是先扩窑， 然后进行新
增元素操作， 而JDK8 是增加元素之后扩窑。
当然扩窑之后， 虽然CPU 还有一定的运行能力，但get（）请求刚好又赶到这个死
链存在的s lot 位置上， 因而雪上加霜。在第二个业务案例中， 就是在put（） 已经形成
死链的情况下， get（） 又命中， 使得服务器基本处于看机状态。
I 210
第6 章数据结构与集合
JDK8 的HashMap 改进了这种从头节点就开始操作数据迁移的做法， 采用对
原先链表的头尾节点51 用， 保证“ 有序性”。对于HashMap 的分析仅限于死链和
对象丢失分析，是希望在使用JDK8 之前的版本时，规避这样的风险，或直接使用
Conc urrentHashMap 。
6.8.4 ConcurrentHashMap
考虑到线程并发安全性， ConcurrentHashMap 是比HashMap 更加推荐的－种晗希
式集合。JDK8 对ConcurrentHashMap 进行了脱胎换骨式的改造， 使用了大量的lock
仓ee 技术来减轻因锁的竞争而对性能造成的影响。它是学习并发编程的一个绝佳示例，
此类超过6300 行代码，涉及volatile 、CAS 、锁、链表、红黑树等众多知识点。
下面简要介绍在高并发场景下的其他晗希式集合。Hashtable 是在JDKl.O 中引
人的晗希式集合，以全互斥方式处理并发情况， 性能极差； HashMap 是在JDKl.2
中引人的， 是非线程安全的，它最大的问题是在并发写的情形下， 容易出现死链问
题，导致服务不可用。ConcurrentHashMap 是在JDK5 中引入的线程安全的哈希式集
合，在JDK8 之前采用了分段锁的设计理念， 相当于Hashtable 与HashMap 的折中版
本， 这是效率与一致性权衡后的结果。分段锁是由内部类Segment 实现的，它继承于
ReentrantLock ，用来管理它辖区的各个HashEntry 。ConcurrentHashMap 被Segment 分
成了很多小区， Segment 就相当于小区保安， HashEntry 列表相当于小区业主， 小区
保安通过加锁的方式，保证每个Segment 内都不发生冲突。
下面对JDKl l 版本的ConcurrentHashMap 进行深度分析，它对JDK7 的版本进行
了三点改造
\ I ) ~X.I~分段锁机制， ；~t 主J 咚｛臣也突概率。
( 2 ） 引入红军树结均l 同一个晗希槽上的元素个数超过一定阑值后， 单向链表
改为红黑树结构。
( 3 ）使用了更加1f 仲的芦飞统计集合内的7 素敖骂首先， Map 原有的size()
方法最大只能表示到23 1 - l, ConcurrentHashMap 额外提供了mappingCount（） 方法，
用来返回集合内元素的数量，最大可以表示到263 一l 。此外， 在元素总数更新时， 使
用了CAS 和多种优化以提高并发能力。
下面先学习下ConcurrentHashMap 的相关属性定义，对这些信息的深刻理解有
助于对整个类的体系认知。因此，我们在字段上方详细地注明了字段意义、使用方式、
211
码出高效· Java 开发手册
注意事项等， 如下所示·
212
／／默认为null . Concurren tHashMap 存放挝据的恍亨． 扩容时六4 、•z. i是2 约w: 次万
／／初始化发生.•｛£ 苇卢次4＆－人i是ft 电改组叹认初始作斗、个为16
transient volatile Node<K , V>(] table ;
／／默认为口ull ， 扩容叶新生~u1v ~女1｝］ . 其犬小为！草tl -IJJ 的，可｛吉
private transient volatile Node<K , V>[] nextTable ;
／／存储单F KV 数捺节点内部有key 、value 、hash 、next~~－ I句F 一个节点
／／它有4 11、在ConcurrentHashMap 逛内部定义的子髦·
II TreeBin 、TreeNode 、ForwardingNode 、ReservationNode
／／前3 个子卖部重写了查浅凡素的1重要方法find()
／／气些节点的jf.1 t 必啧·f!; * Jt!r ［＜.兮． 否冒1）梗犬~.ll E号）（－［，咱A 的理解
static class Node<K , V> implements Map.Entry<K , V> { . . . )
／／它并手存储实际放得． 维护对悦i句i'I 喂叶的读写锁． 存！•吉对妇黑衬节点的引唱
static final class TreeBin<K , V> extends Node<K , V> { .. . )
／／在J工.［ •1" 结吁中．头可tr，「与节点
static final class TreeNode<K, V> extends Node<K , V> { . .. )
／／扩容转发节点，放1!~ J也节点e; • 外部对原有哈希芒n'1 I是宇会转变苦11 nextTable .I:
static final class ForwardingNode<K , V> extends Node<K, V> { ... )
／／占位加纠节；.~. ii;_ fi 某些牛毛计， ＜t 培加~：1 . Ir.口comput-.e I fAbsen t 等
static final class ReservationNode<K , V> extends Node<K,V> { ... }
／／默认为0 . 重要展\t生．耳＇. t( j主轧table 的初始d七f口扩容校作
11 sizeCtl= - 1. 表示正在i;'i !;(,·ft 中
II s 工zeCtl=-n . 表示（ n-1 ）’、汽ff if 在进行矿答中
II sizeCtl>O. t.iJ 始It~ 扩容丰击萎使l哥奇与容量
11 sizeCtl=O , 平1.l、u":. • ~~ fj 'I 川、容量进行中可松什
private transient volatile int sizeCtl ;
／／察合size 小于64 . 无论如何． 部不会使用fr ;f!; tit 结构
／／怜化为了黑付毛r--1、乍但工TREEIFY THRESHvi.D
static final int MIN TREE 工FY CAPACITY= ti1 ;
／／同一个哈希桶内存储的兀占于坎坷过此间值时
I I fi11）存储结构由H 委传为扩嘿~if
static final int TREEIFY THRESHOLD = 8 ;
第6 章数据结构与集合
／／同一个哈希桶内存储的元东个数小子等于此间值时
／／从红黑树回迟至链表结构，因为元素个数较少时，链表吏快
static final int UNTREEIFY THRESHOLD = 6;
根据属性的初步认知，我们可以勾勒出ConcurrentHashMap 的大致存储结构， 如
图6-27 所示。
0: ~皿I 1 ： 阻2 回3: I a Rese「v
匾E 卢圃醺\
归回归因: ..－ ：：回皿
图6-27 ConcurrentHash Map 的元素存储类型
在图6-27 示例中， table 的长度为64 ， 数据存储结构分为两种链表和红黑树。
当某个槽内的元素个数增加到超过8 个且table 的容量大于或等于64 时， 由链表转为
红黑树，当某个槽内的元素个数减少歪IJ 6 个时，由红黑树重新转回链表。链表转红
黑树的过程，就是把给定顺序的元素构造成一楝红黑树的过程。需要注意的是，当
table 的容量小于64 时，只会扩窑，并不会把链表转为红黑树。在转化过程中，使用
同步块锁住当前槽的首元素，防止其他进程对当前槽进行增删改操作，转化完成后利
用CAS 替换原有链表。因为TreeNode 节点也存储了next 引用，所以红黑树转链表的
操作就变得非常简单，只需从TreeB in 的first 元素开始遍历所有的节点， 并把节点从
TreeNode 类型转化为Node 类型即可， 当构造好新的链表之后，会同样利用CAS 替
换原有红黑树。相对来说，链表转红黑树更为复杂，流程图如图6-28 所示。
2才3
码出高效· J ava 开发手册
图6 28 ConcurrentHas hMap 元素插入流程图
触发上述存储结构转化最主要的操作是增加元素， 即put（） 方法。基本思想与
Has剧ap 一致， 区另lj 就是增加了锁的处理， ConcurrentHashMap 元素插入流程。图如图
6-29 所示。
I 214
第6 章数据结构与集合
• ｜；第落在恒丁
图6一29 ConcuITen tHashMap 扩容流程图
最后我们简要介绍Node 的另两个子类ForwardingNode 和ReservationNode 。
F orwardingN ode 在table 扩窑时使用，内部记录了扩窑后的table ， 即nextTable。当
table 需要进行扩容时， 依次遍历当前table 中的每一个槽， 如果不为null ，则需要把
其中所有的元素根据hash 值放入扩窑后的nextTable 中， 而原table 的槽内会放置个
ForwardingN ode 节点。正如其名，此节点会把自nd（） 请求转发到扩窑后的nextTable 上。
而执行put（） 方法的线程如果碰到此节点， 也会协助进行迁移。
ReservationNode 在compute！且bsentO 及其相关方法中作为一个预留节点使用。
compute！队bsentQ 方法会先判断相应的Key 值是否已存在， 如果不存在，贝iJ调用由用户实
现的自定义方法来生成Value 值， 组成KV 键值对， 随后插入此晗希集合中。在并发场景
215 1
码出高效： Java 开发手册
下， 在从得知Key 不存在到插入晗希集合的时间间隔内， 为了防止晗希槽被其他线程抢占，
当前线程会使用一个ReservationNode 节点放到槽中并加锁， 从而保证了线程的安全性。
最后， 让我们来聊一聊ConcurrentHashMap 对于计算集合size（） 的优化。需要
注意的是， 无论是JDK7 还是JDK8, ConcurrentHashMap 的size（） 方法都只能返回
个大概数量， 无法做到100% 的精确， 因为已经统计过的槽在size（） 返回最终结
果前有可能又出现了变化， 从而导致返回大小与实际大小存在些许差异。在多个槽
的设计下，如果仅仅是为了统计元素数量而停下所有的增删操作， 又会显得因噎废
食。因此， ConcurrentHashMap 在涉及元素总数的相关更新和计算时，会最大限度
地减少锁的使用，以减少线程间的竞争与互相等待。在这个设计思路下， JDK8 的
ConcurrentHashMap 对元素总数的计算又做了进一步的优化， 具体表现在在put（） 、
remove（） 和size（） 方法中， 涉及元素总数的更新和计算， 都彻底避免了锁的使用， 取
而代之的是众多的CAS 操作。
我们先来一起看下在JDK7 版本中的put（） 方法和remove（） 方法， 对于segment
内部元素和计数器的更新， 全部处于锁的保护下。如Segment.put（） 方法的第一行，
／／经h 气－ 1-i 1-;. i斗，元价f¥.1且与~u 绞t'> ；｛~；斗l在Se gm电nt 卡约ι＇. 飞后可以人月号J也夏新元在正口
// ’：司的计；毛；1号
HashEntr y<k> node = tryLock () ? null : scanAndLockForPut (key, hash, value );
而JDK7 版本的ConcurrentHashMap 获取集合大小流程图如图6-30 所示。
图6-30 JDK7 版本的ConcurrentHashMap 获取集合大小流程图
1216
第6 章数据结构与集合
可以看到， 在JDK7 版本中， ConcurrentHashMap 在统计元素总数时已经开始避
免使用锁了，毕竟加锁操作会极大地影响到其他线程对于晗希元素的修改。当经过了
3 次计算（ 2 次对比） 后， 发现每次统计时晗希都有结构性的变化， 这时它就会“气
急败坏” 地把所有S egment 都加上锁，而当自己统计完成后，才会把锁释放掉，再允
许其他线程修改晗希中的元素。
获取集合元素个数是否还有进一步的优化空间呢？ JDK8 的ConcurrentHashMap
给出了答案有｜前面已经分析过了， 在put（） 中，对于晗希元素总数的更新， 是置
于对某个槽的锁之外的， 主要会用到的属性如下。
／／记录f 7L 在总裁fr'i . 主要明在k，吃争状恋丁、
／／在总敬~j 暂住． 通t CAS ；市’飞在校史，所进个1户
private tran sient volatile long baseCount ;
／／一个汁数器单元．啡护了一个value 伯
static final class CounterCell { .. . }
／／在竟争激烈的状怒"f .'§ )j']. J,旨. f￥会把总tlz 平＇：）再情况1字放手1] i变结构t与
／／当竞争j止一步力口别时． 全通过扩容拭少奇t 争
private transient volatile CounterCel l[] counterCells ;
正是借助baseCount 和counterCells 两个属性，并配合多次使用CAS 方法， JKD8
中的ConcurrentHashMap 避免了锁的使用。虽然源码过程看起来非常复杂，但是思路
却很清晰。
·当并发量较小时， 优先使用CAS 的方式直接更新baseCount 。
·当更新b aseCount 冲突，贝IJ 会认为进入到比较激烈的竞争状态， 通过启用
counterCells 减少竞争， 通过CAS 的方式把总数更新情况记录在counterCells
对应的位置上。
·如果更新counterCell s 上的某个位置时出现了多次失败， 贝IJ 会通过扩窑
counterCells 的方式减少冲突。
·当counterCells 处在扩容期间时，会尝试更新baseCount 值。
对于元素总数的统计，逻辑就非常简单了，只需要让baseCount 加上各
counterCe ll s 内的数据，就可以得出晗希内的元素总数，整个过程完全不需要借助锁。
正因为ConcurrentHashMap 提供了高效的锁机制实现，在各种多线程应用场景中，
推荐使用此集合进行KV 键值对的存储与使用。
217 1
'
仅供＇II二商业用途或交流学习使用
第7 章并发与多线程
是以驷牡异力， 而六譬如琴l 并驾齐驱， 而一鼓统辐。行文如此， 并
发亦如此。
--’-·
仅供书商业用途或交流学习使用
第7 章并发与多线程
目前CPU 的运算速度已经达到百亿次每秒，甚至更高的量级，家用电脑即使维
持操作系统正常运行的进程也会有数十个，线程更是数以百计。所以，在现实场景中，
为了提高生产率和高效地完成任务，处处均采用多线程和并发的运作方式。
首先从并发（ Concurrency ）与并行（ Parallelism ）说起。并发是指在某个时间段
内，多任务交替处理的能力。所谓不患寡而患不均，每个CPU 不可能只顾着执行某
个进程，让其他进程一直处于等待状态。所以， CPU 把可执行时间均匀地分成若干份，
每个进程执行一段时间后，记录当前的工作状态，释放相关的执行资源并进入等待状
态，让其他进程抢占CPU 资源。并行是指同时处理多任务的能力。目前， CPU 已经
发展为多核，可以同时执行多个互不依赖的指令及执行块。并发与并行两个概念非常
容易混淆，它们的核心区别在于进程是否同时执行。以KTV 唱歌为例，并行指的是
有多少人可以使用话筒同时唱歌，并发指的是同一个话筒被多个人轮流使用。
并发与并行的目标都是尽可能快地执行完所有任务。以医生坐诊为例，某个科室
有两个专家同时出诊，这就是两个并行任务，其中一个医生，时而问诊，时而查看
化验单，然后继续问诊，突然又申断去处理病人的咨询，这就是并发。在并发环境下，
由于程序的封闭’｜全被打破，出现了以下特点：
( I ）并发挥序之间有侣可制约的关系。直接制约体现为一个程序需要另一个程
序的计算结果，间接制约体现为多个程序竞争共享资源，如处理器、缓冲区等。
( 2 ）并发程序的妆，句1兰特是断断续续的。程序需要记忆现场指令及执行点。
( 3 ）当并发数设rt ”1里并且C PU 拥有足够的处理能力句，并发会提高程序的运
行效率。
7.1 线程安全
线程是CPU 调度和分派的基本单位，为了更充分地利用CPU 资源，一般都会使
用多线程进行处理。多线程的作用是提高任务的平均执行速度，但是会导致程序可理
解性变差，编程难度加大。例如，楼下有一车砖头需要工人搬到21 楼，如果10 个人
一起搬，速度定比l 个人搬要快，完成任务的总时间会极大减少。但是论单次的时
间成本，由于楼梯交会等因素10 个人比l 个人要慢。如果无限地增加入数，比如
10000 人参与搬砖时，反而会因为楼道拥墙不堪变得更｜雯，所以合适的人数才会使工
作效率最大化。同理，合适的线程数才能让CPU 资源被充分利用。如图7 - 1 所示，
219
仅供－ 11 ： 商业用途或交流学习使用
码出高效： Java 开发手册
这是计算机的资源监视数据，红色箭头指向的PID 就是进程ID ，绿色箭头表示Java
进程运行着3 0 个线程。
Process Nam。
Java
mysqld
% CPU CPU Time Threads v Idle Wake Up s __. PID User
Q_1 26.45
Q_Q 1:41 .56
30
29
3 1 55979 yangguanbao
5 1 1 6 －罚1ysql
图7-1 计算机的资源监视数据
线程可以拥有自己的操作枝、程序计数器、局部变量表等资源，它与同－进程
内的其他线程共享该进程的所有资源。线程在生命周期内存在多种状态。如图7 -2 所
示，有NEW （新建状态）、RUNNABLE （就绪状态）、RUNNING （运行状态）、
BLOCKED （阻塞状态）、DEAD （终止状态）五种状态。
去
才
万
－
HH
一
目
－
东山即’机刑a·
胃建
M
新噩噩噩获得CPU执行时间片
CPU 时间片用完终止状态
DEAD
图7-2 线程状态图
( I )NEW ， 即新建状态，是线和被创建旦未启动的状态。创建线程的方式有三种：
第一种是继承自Thread 类，第二种是实现Runnable 接口，第三种是实现Callable 接
口。相比第一种，推荐第二种方式，因为继承自Thread 类往往不符合里氏代换原则，
而实现Runnable 接口可以使编程更加灵活，对外暴露的细节比较少，让使用者专注
于实现线程的run （）方法上。第三种Ca llable 接口的ca ll （） 声明如下，
220
仅供＇II二商业用途或交流学习使用
第7 章并发与多结程
／芥＊
* Computes a re.suit , or throw" an exception if unable ~o do so .
女e ret:.urn computed resul':: , V is generics value
安理throws Exception if unable to compute a result
女／
V call() throws Exception;
由此可知， Callable 与Runnable 有两点不同第－，可以通过call（）获得
返回值。前两种方式都有个共同的缺陷，即在任务执行完成后，无法直接获
取执行结果， 需要借助共享变量等获取，而Callable 和Future 则很好地解决了
这个问题； 第二， call（）可以抛出异常。而Runnable 只有通过setDefaultUncaug
htExceptionHandler（） 的方式才能在主线程中捕捉到子线程异常。
( 2 ) RUM、！ ABLE ， 即就绪状态， 是调用start（） 之后运行之前的状态。线程的
start（） 不能被多次调用，否则会抛出Illega!StateException 异常。
( 3 ) RUN!'叫ING ， 即运行状态， 是run （） 正在执行时线程的状态。线程可能会由
于某些因素而退出RUNNING ，如时间、异常、锁、调度等。
( 4 ) BLOCKED ，即阻塞状态， 进入此状态， 有以下种情况。
·同步阻塞锁被其他线程占用。
·主动阻塞调用Thread 的某些方法，主动让出CPU 执行权，比如sleep（） 、
join（） 等。
·等待阻塞I 执行了wait（）。
( 5 ) DEAD ， 即终止状态，是run （） 执行结束，或同异常退出后的状态， 此状态
不可逆转。
再用医生坐诊的例子说明， 医生并发地处理多个病人的询问、开化验单、查看化
验结果、开药等工作，任何一个环节一旦出现数据混淆，都可能引发严重的医疗事故。
延伸到计算机的结程处理过程中，因为各个线程轮流占用CPU 的计算资源，可能会
出现某个线程尚未执行完就不得不中断的情况，容易导致线程不安全。例如，在服务
端某个高并发业务共享某用户数据，首先A 线程执行用户数据的查询任务， 但数据
尚未返回就退出CPU 时间片，然后B 线程抢占了CPU 资源执行并覆盖了该用户数据，
最后A 线程返回到执行现场，直接将B 线程处理过后的用户数据返回给前端，导致
页面显示数据错误。为保证线程安全，在多个线程并发地竞争共享资源时，通常采用
同步机制协调各个线程的执行，以确保得到正确的结果。
221 I
仅供书商业用途或交流学习使用
码出高效： Java 开发手册
线程安全问题只在多线程环境下才出现，单纯程串行执行不存在此问题。保证高
并发场景下的结程安全，可以从以下四个维度考量
( I ）数据单线程内可见。单线程总是安全的。通过限制数据仅在单线程内可见，
可以避免数据被其他结程篡改。最典型的就是线程局部变量，它存储在独立虚拟机枝
帧的局部变量表中，与其他线程毫无瓜葛。ThreadLocal 就是采用这种方式来实现线
程安全的。
( 2 ）只读对象。只读对象总是安全的。它的特性是允许复制、拒绝写人。最典
型的只读对象有String 、Integer 等。一个对象想要拒绝任何写人，必须要满足以下条件，
使用final 关键字修饰类，避免被继承，使用private final 关键字避免属性被中途修改；
没有任何更新方法；返回值不能可变对象为引用。
( 3 ）线程安全类。某些线程安全类的内部有非常明确的结程安全机制。比如
StringBuffer 就是一个线程安全类，它采用synchronized 关键字来修饰相关方法。
( 4 ）同步与锁机制。如果想要对某个对象进行并发更新操作，但又不属于上述
三类，需要开发工程师在代码中实现安全的同步机制。虽然这个机制支持的并发场景
很有价值，但非常复杂且容易出现问题。
线程安全的核心理念就是“要么只读，要么加锁”。合理利用好JDK 提供的并发包，
往往能化腐朽为神奇。Java 并发包（ java.util.concurrent ，只JC ） 中大多数类注释都写有
@author Doug Lea。如果说Java 是一本史书，那么Doug Lea 绝对是开疆拓土的伟大
人物。Doug Lea 在当大学老师时，专攻并发编程和并发数据结构设计，主导设计了
JUC 并发包，提高了Java 并发编程的易用性，大大推进了Java 的商用进程。并发包
主要分成以下几个类族·
( 1 ）线程同步类。这些类使线程间的协调更加容易，支持了更加丰富的线程
协调场景，逐步淘汰了使用Object 的wait（）和notify（）进行同步的方式。主要代表为
CountDownLatch 、Semaphore 、CyclicBarrier 等。
( 2 ）并发集合类。集合并发操作的要求是执行速度快，提取数据准。最著名的
类非ConcurrentHashMap 莫属，它不断地优化，由刚开始的锁分段到后来的CAS,
不断地提升并发性能。其他还有ConcurrentSkipListMap 、CopyOnWriteArrayList、
BlockingQueue 等。
( 3 ）线程管理类。虽然Thread 和ThreadLocal 在JDKl.O 就已经引入，但是真
正把Thread 发扬光大的是线程池。根据实际场景的需要，提供了多种创建线程池的
I 222
仅供＃商业用途或交流学习使用
第7 章并发与多线程
快捷方式，如使用Exec utors 静态工厂或者使用ThreadPoolExecutor 等。另外，通过
ScheduledExecutorService 来执行定时任务。
( 4 ）铁相关头。锁以Lock 接口为核心，派生出在一些实际场景中进行互斥操
作的锁相关类。最有名的是ReentrantLock。锁的很多概念在弱化，是因为锁的实现
在各种场景中已经通过类库封装进去了。
并发包中的类族有很多，差异比较微妙，开发工程师需要有很好的Java 基础、
逻辑思维能力，还需要有定的数据结构基础，才能够彻底分清各个类族的优点、缺
点及差异点。
解决线程安全问题的能力是开发工程师进阶的重要能力之一。由于初创公司的业
务流量通常比较小，再加上其初级程序员缺乏线程安全意识。所以，即使出现了由高
并发导致的错误，往往也由于复现难度大、追踪困难而不了了之。但是在后期的系统
重构中，这些公司一定会为以上线程安全隐患买单。
7.2 什么是锁
从古代的门问、铁锁到现代的密码锁、指纹锁、虹膜识别锁等，锁的便捷性和安
全性在不断提升，对于私有财产或领地的保护也更加高效和健全。在计算机信息世界
里，单机单线程时代没有锁的概念。自从出现了资源竞争，人们才意识到需要对部分
场景的执行现场加锁，昭告天下，表明自己的“短暂”拥有（其实对于任何有形或无
形的东西，拥有都不可能是永恒的）。计算机的锁也是从开始的悲观锁，发展到后来
的乐观锁、偏向锁、分段锁等。锁主要提供了两种特性， 互斥性和不可见性。因为锁
的存在，某些操作对外界来说是黑箱进行的，只有锁的持有者才知道对变量进行了什
么修改。
计算机的锁分类有很多，本书并不打算详细介绍每种锁，而是通过对java.util.
concurrent ( JUC ）包中基础类的解析来说明锁的本质和特性。Java 中常用锁实现的方
式有两种。
I. #J 并发包中华锁尖
并发包的类族中， Lock 是JUC 包的顶层接口，它的实现逻辑并未用到
synchroniz时，而是利用了volatile 的可见性。先通过Lock 呆了解JUC 包的一些基础类，
如图7- 3 所示。
223 I
仅供＇II二商业用途或交流学习使用
码出高效· Java 开发手册
国翩翩画
一一一本→→← ...... E'.iii噩噩~
图7-3 Loc k 的继承关系
图7-3 为Lock 的继承类图， ReentrantLock 对于Lock 接口的实现主要依赖了
Sync ， 而Sync 继承了AbstractQueuedSynchronizer ( AQS ） ， 它是JUC 包实现同步的
基础工具。在AQS 中， 定义了一个volatile int state 变量作为共享资源，如果线程获
取资源失败， 贝lj 进入同步FIFO 队列中等待；如果成功获取资源就执行临界区代码。
执行完释放资源时， 会通知同步队列中的等待线程来获取资源后出队并执行。
AQS 是抽象类， 内置自旋锁实现的同步队列， 封装入队和出队的操作， 提供独
占、共享、中断等特性的方法。AQS 的子类可以定义不同的资源实现不同性质的方
法。比如可重入锁ReentrantLock ， 定义state 为0 时可以获取资源并置为l 。若已获
得资源， state 不断加l ， 在释放资源时state 减l s 直至为0 ; CountDownLatch 初始时
定义了资源总量state=count, countDown （） 不断将state 减l g 当state=O 时才能获得锁，
释放后state 就一直为0。所有结程调用await（） 都不会等待，所以CountDownLatch 是
次性的， 用完后如果再想用就只能重新创建一个，如果希望循环使用， 推荐使用基
于Reentran tLock 实现的CyclicBarrier。Semaphore 与CountDownLatch 略有不同， 同
样也是定义了资源总量state=permits ， 当state>O 时就能获得锁， 并将state 减l ， 当
state=O 时只能等待其他线程释放锁， 当释放锁时state 加l ， 其他等待线程又能获得
这个锁。当Semphore 的permits 定义为l 时，就是互斥锁，当permits> I 就是共享锁。
JDK8 提出了一个新的锁StampedLock ， 改进了读写锁ReentrantReadWriteLock。
这些新增的锁相关类不断丰富了几JC 包的内容， 降低了并发编程的难度，提高了锁
的性能和安全性。
1224
仅供＃商业用途或交流学习使用
第7 章并发与多线程
2. 利用同步代码块
同步代码块一般使用Java 的synchronized 关键字来实现，有两种方式对方法进行
加锁操作第，在方法签名处加synchronized 关键字；第二，使用synchronized （对
象或类）进行同步。这里的原则是锁的范围尽可能小，锁的时间尽可能短，即能锁对象，
就不要锁类，能锁代码块，就不要锁方法。
synchron i zed 锁特性由JVM 负责实现。在JDK 的不断优化迭代中， synchron i zed
锁的性能得到极大提升，特别是偏向锁的实现，使得synchronized 已经不是昔日那个
低性能且笨重的锁了。川、4 底层是通过监视锁来实现synchronized 同步的。监视锁
即monitor ， 是每个对象与生俱来的一个隐藏字段。使用synchronized 时， 川岛4 会根
据sy nchronized 的当前使用环境，找到对应对象的monitor ，再根据monitor 的状态进
行加、解锁的判断。例如，线程在进入同步方法或代码块时，会获取该方法或代码块
所属对象的monitor ， 进行加锁判断。如果成功加锁就成为该monitor 的唯一持有者。
monitor 在被释放前，不能再被其他线程获取。下面通过字节码学习synchronized 锁
是如何实现的I
public v。id testSynchronized() ;
descriptor : () V
flags: ACC PUBLIC
Code :
stack=2 , locals=2 , args size=l
0 : getstat 工c #13
eld 响1 t x. ： .：..〕'l ＇立’ lang/Objec• ;
3 : dup
4 : astore 1
5 : monitorenter
6 : getstatic #39
I i=-ield －丑飞弓lan 1 月ystem . out : L 丁ava/i)/p 、n tStream;
9 : ldc #45
;_i .e 「w r d
11 : invokevirtual #47
,_ thv 、；J 3.V 主lio. PrintStream . println : (L1 .. va/ldng/Srring ; )V
14 : aload 1
15 : monitorexit
16 : goto 22
19 : aload 1
20 : monitorexit
21 : athrow
22 : return
225 I
仅供＇II二商业用途或交流学习使用
码出高效· J ava 开发手册
Exception tabl e:
from to target type
6 16 19 any
19 21 19 any
LineNumberTable :
line 26 : 0
line 27 : 6
l i ne 26 : 14
l 工ne 29 : 22
LocalVariableTable :
Start Length Slot Name Signat ure
O 23 O this Ltest/Test ;
方法元信息中会使用ACC SYNCHRONIZED 标识该方法是一个同步方法。同
步代码块中会使用monitorenter 及monitorexit 两个字节码指令获取和释放monitor。
如果使用monitorenter 进入时monitor 为0 ，表示该线程可以持有monitor 后续代码，
并将monitor 加l ，如果当前线程已经持有了monitor ， 那么monitor 继续加l ；如果
monitor 非0 ， 其他线程就会进入阻塞状态。JVM 对synchronized 的优化主要在于对
monitor 的加锁、解锁上。JDK6 后不断优化使得synchronized 提供三种锁的实现，
包括偏向锁、轻量级锁、重量级锁， 还提供自动的升级和降级机制。JVM 就是利用
CAS 在对象头上设置线程ID ， 表示这个对象偏向于当前线程， 这就是偏向锁。
偏向锁是为了在资源没有被多线程竞争的情况下尽量减少锁带来的性能开销。在
锁对象的对象头申有一个Threadld 字段， 当第一个线程访问锁时， 如果该锁没有被其
他线程访问过， 即Threadld 字段为空，那么JVM 让其持有偏向锁， 并将Threadld 字
段的值设置为该线程的囚。当下一次获取锁时， 会判断当前线程的ID 是否与锁对象
的Threadld 一致。如果一致， 那么该线程不会再重复获取锁， 从而提高了程序的运行
效率。如果出现锁的竞争情况， 那么偏向锁会被撤销并升级为轻量级锁。如果资源的
竞争非常激烈， 会升级为重量级锁。偏向锁可以降低无竞争开销， 它不是互斥锁，不
存在线程竞争的情况， 省去再次同步步IJ 断的步骤， 提升了性能。
7.3 线程同步
7.3.1 同步是什么
资源共享的两个原因是资源紧缺和共建需求。线程共享CPU 是从资源紧缺的维
度来考虑的， 而多线程共享同一变量， 通常是从共建需求的维度来考虑的。在多个线
I 226
仅供＇II二商业用途或交流学习使用
第7 章并发与多线程
程对同一变量进行写操作时，如果操作没有原子性，就可能产生脏数据。所谓原子性
是指不可分割的一系列操作指令， 在执行完毕前不会被任何其他操作中断， 要么全部
执行， 要么全部不执行。如果每个线程的修改都是原子操作， 就不存在线程同步问题。
有些看似非常简单的操作其实不具备原子性， 典型的就是i＋＋操作， 它需要分为三步，
即ILOAD → IINC → IS TORE。另方面，更加复杂的CAS ( Compare and Swap ）操
作却具有原子性。
线程同步现象在实际生活随处可见。比如乘客在火车站排队打车， 每个人都是一
个线程， 管理员每次放10 个人进来， 为了保证安全，等全部离开后， 再放下一批人进来。
如果没有协调机制， 场面一定是混乱不堪的， 人们会窝蜂地上去抢车， 存在严重的
安全隐患。计算机的线程同步， 就是线程之间接某种机制协调先后次序执行， 当有
个线程在对内存进行操作时， 其他线程都不可以对这个内存地址进行操作，直到该线
程完成操作。实现线程同步的方式有很多， 比如同步方法、锁、阻塞队列等。
7 .3.2 volatile
先从happen before 了解线程操作的可见性。把happen before 定义为方法
hb(a,b）， 表示a happen before b。如果hb(a,b） 且hb(b ,c）， 能够推导出hb(a,c）。类似于
x>y 且y>z ，可以推导出x>z。这不就是一种放之四海而皆准的规律吗？但其实很多
场景并不符合这种规律，比如在201 8 年俄罗斯世界杯上，韩国队战胜德国队， 德国
队战胜瑞典队， 并不能推导出韩国队战胜了瑞典队。
线程执行或线程切换都是纳秒级的， 执行速度如此之快， 直觉上会认为线程本地
缓存的必要性特别弱。做个类比， 我们人类以年为计而宇宙以亿年为计，宇宙老人看
待人类的心态不正如我们看待CPU 世界的心态吗？时间成本的巨大差异只要存在，
缓存策略自然就会产生。再比如， 去学校图书馆仅需要10 分钟， 借一本书， 无须缓存。
但如果去市图书馆， 往返需要5 个小时， 般为了减少路程开销而会考虑多借几本。
CPU 访问内存远远比访问高速缓存L1 和L2 慢得多，对应借书的例子，应该得去国
外图书馆了。
接着再谈指令优化。计算机并不会根据代码顺序按部就班地执行捆关指令， 再
回到借书例子， 假如你刚好要去还书， 然后再借一本， 你的室友恰好也让你帮他归还
Easy Coding 这本书， 然后再借本〈码出高效Java 开发手册〉。这个过程有两件事，
你的事和他的事。先办完你的事， 再办他的事， 是一种单线程的死板行为。此时你会
潜意识地进行“ 指令优化” 把你要还的书和Easy Coding 先一起归还， 再一起借你
227
码出高效· J ava 开发手册
们要借的书， 这相当于合并数据进行存取的操作过程。CPU 在处理信息时也会进行
指令优化，分析哪些取数据动作可以合并进行， 哪些存数据动作可以合并进行。CPU
拜访一趟遥远的内存，一定会到处看看， 是否可以存取合并， 以提高执行效率。指令
重排示例代码如下
@Override
public void run( ) {
／ （ 第1 处）
int x = 1 ;
int y = 2 ;
int z = 3 ;
／／ （ 第2 处）
x = x + 1 ;
／／ （ 第3 处）
int sum = x + y + z ;
happen before 是时钟顺序的先后， 并不能保证线程交互的可见性。在第2 处和第
3 处都是写操作， 不会进行指令重排， 但是前三行是不互斥的， 并且第l 处的操作如
果放在z=3 赋值操作之后， 明显是效率最大化的处理方式。所以指令重排的最大可能
是把第1 处和第2 处串联依次执行。happen before 并不能保证线程交互的可见性。那
么什么是可见性呢？可见性是指某线程修改共享变量的指令对其他线程来说都是可见
的，它反映的是指令执行的实时透明度。
每个线程都有独占的内存区域， 如操作枝、本地变量表等。线程本地内存保存7
号｜用变量在堆内存中的副本， 线程对变量的所有操作都在本地内存区域中进行， 执行
结束后再同步到堆内存中去。这里必然有一个时间差， 在这个时间差内，该线程对副
本的操作， 对于其他线程都是不可见的。
volatile 的英文本义是“ 挥发、不稳定的” ， 延伸意义为敏感的。当使用volatil e
修饰变量时， 意昧着任何对此变量的操作都会在内存中进行， 不会产生副本， 以保证
共享变量的可见性，局部阻止了指令重排的发生。由此可知， 在使用单例设计模式时，
即使用双检锁也不定会拿到最新的数据。
如下示例代码在高并发场景中会存在问题
class LazyinitDemo {
private static TransactionService service = null ;
public static TransactionServ 工ce getTransacti onService( ) {
228
第7 章并发与多结程
if (service == null ) {
synchronized (this ) {
if (service == null ) {
service = new Tr a nsactionService( );
return service ;
I I ot.her fl'.eth0ds and fields ..
使用者在调用getTransactionService（） 时，有可能会得到初始化未完成的对
象。究其原因，与Java 虚拟机的编译优化有关。对Java 编译器而言，初始化
TransactionService 实例和将对象地址写到service 字段并非原子操作， 且这两个阶段
的执行顺序是未定义的。假设某个线程执行new TransactionService（） 肘， 构造方法还
未被调用， 编译器仅仅为该对象分配了内存空间并设为默认值，此时若另一个线程调
用getTransactionService（） 方法，由于service! =null ，但是此时service 对象还没有被赋
予真正有效的值， 从而无法取到正确的service 单例对象。这就是著名的双重检查锁
定（ Double-checked Locking ）问题， 对象引用在没有同步的情况下进行读操作， 导
致用户可能会获取未构造完成的对象。对于此问题，一种较为简单的解决方案是用
volatile 关键字修饰目标属性（适用于JDK5 及以上版本） ， 这样service 就限制了编
译器对它的相关读写操作，对它的读写操作进行指令重排， 确定对象实例化之后才返
回引用。
锁也可以确保变量的可见性， 但是实现方式和volatile 略有不同。线程在得到锁
时读入副本， 释放时写回内存，锁的操作尤其要符合happen before 原则。
volatile 解决的是多线程共享变量的可见性问题， 类似于synchronized ，但不具备
sy飞I
犯错i吴的地方。一个线程对共享变量进行10000 次i＋＋操作，另一个线程进行10000
次i一操作， 如下示例代码
public class Volat i leNotAtomic {
private static volatile l。ng count = 01;
private static final int NUMBER = 10000 ;
public static v。id main (String [ ] args) {
Thread subtractThread = new SubtractThread();
229
码出高效： J ava 开发手册
subtractThread . start();
for ( int i = 0 ; i < NUMBER ; i++) {
cou nt++ ;
’／飞占＇ '" 4晶『＜ y ' ，吁
while (subtractThread . isAlive ()) {)
System.out . println( LD cil;o 的市：： • + count) ;
private static class SubtractThread extends Thread {
@Over rid e
public void ru口（） ｛
for (int 工＝ 0 ； 工＜ NUMBER ; i ++) {
count --;
多次执行后， 发现结果基本都不为0。如果在co u nt ＋＋和count－－ 两处都进行加锁
操作， 才会得到预期是0 的结果。这里对count 的读取、加l 操作的字节码如下
A 飞J.r L ，（；.己
GETSTATIC com/alibaba/easy/cod 工ng/other/VolatileNotAtomic . count ：工
、、也
ICONST 1
m; ＂－＇飞飞r ·t ；：丁I'
IADD
I I 4. :.r 1 中i t w 聋J t肉和－，c ＂·；句＇ I t
PUTSTATIC com/alibaba/easy/coding/othe r /VolatileNotAtom 工C . count ： 工
需要4 步才能完成加l 操作。在该过程中，其他线程有足够的时间覆盖变量的值，
如果想让示例代码最后的结果为零，需要对count+＋和count－－ 加锁．
for ( int i = O ； 工＜ MAX VALUE; i++) {
synchroniz e d (VolatileNotAtomic . class) {
’在coun芒－－八J ＂元'fl!:· /z占3
count++ ;
230
第7 章并发与多线程
能实现count＋＋原子操作的其他类有AtomicLong 和LongAdder。JDK8 推荐使用
LongAdder 类，它比AtomicLong 性能更好， 有效地减少了乐观锁的重试次数。
因此，“ volatile 是轻量级的同步方式” 这种说法是错误的。它只是轻量级的线程
操作可见方式， 并非同步方式， 如果是多写场景， 定会产生线程安全问题。如果是
写多读的并发场景， 使用volatile 修饰变量则非常合适。volatile 写多读最典型的
应用是CopyOn WriteArrayList。它在修改数据时会把整个集合的数据全部复制出来，
对写操作加锁，修改完成后， 再用setArray（） 把array 指向新的集合。使用volatile 可
以便读线程尽快地感知array 的修改， 不进行指令重排，操作后即对其他线程可见。
源码如下，
public class CopyOnWriteArrayList<E> {
／／、今，＇ ＇＂俨＇ ' ' ' ~
private transient volatile Object[] array ;
final void setArray (Object [] a ) {
array = a ;
在实际业务中， 如何清晰地判断一写多读的场景显得尤为重要。如果不确定共享
变量是否会被多个线程并发写， 保险的做法是使用同步代码块来实现线程同步。另外，
因为所有的操作都需要同步给内存变量， 所以volatile 一定会使线程的执行速度变慢，
故要审慎定义和使用volatile 属性。
7.3.3 信号量同步
信号量同步是指在不同的线程之间，通过传递同步信号量来协调线程执行的
先后次序。这里重点分析基于时间维度和信号维度的两个类： CountDownLatch 、
Semaphore 。
某国际化基础语言管理平台收到一个多语言翻译请求后， 根据目标语种拆分成
多个子线程， 对翻译引擎发起翻译请求。翻译完成后， 同步返回给调用方， 结果由于
countDown（） 抛出异常，导致发生故障，警示代码如下
public class CountDownLatchTest {
public static void main( String[ ] args ) {
CountDownLatch count = new CountDownLatch( 3 ) ;
23才
码出高效： Java 开发手册
Thread thread! = new TranslateThread ( ” l st ιon t E'n t ” , count);
Thread thread2 = new TranslateThread ( ” 2nd ce,,ntE i扫t ” ， count);
Thread thread3 = new TranslateThread ( ” 3rd content ” , count);
thread! . start () ;
thread2.start();
thread3.start();
count.await( lO , TimeUnit . SECONDS);
System . out . println （ ” 所右地程材l f or，快” ）；
I I '.(,iR·l 1'＇端电四川材、』11. iK
class TranslateThread extends Thread {
private String co口tent ;
private final CountDownLatch count ;
public TranslateThread(String content , CountDownLatch count) {
this .content = content;
this . count = cou 口t;
@Override
public void run() {
I {r \' ！中l；，，”，1, T. 付， 1, >, t t1r 时. ~；；. i11 ir 常（ 第1 处）
if (Math. random() > 0 . 5) {
throw new RuntimeExcept 工on （ ” 原文存在非法宇料” ）；
System . out.println(content ＋ ” 的fu:li.'· ＂＇瑞克成， 还是)J~ ...”) ;
count.countDown();
代码中第l 处抛出异常，且该异常没有被主线程try-catch 到，最终该线程没有执
行countDown（）方法。程序执行的时间较长，该问题难以定位，因为异常被吞得一干
二净。扩展说明下，子线程异常可以通过线程方法setUncaughtExceptionHandler()
捕获。
CountDownLatch 是基于执行时间的同步类。在实际编码中，可能需要处理基于
空闲信号的同步情况。比如海关安检的场景，任何国家公民在出国时，都要走海关的
1232
第7 章并发与多结程
查验通道。假设某机场的海关通道共有3 个窗口1 一批需要出关的人排成长队，每个
人都是一个结程。当3 个窗口中的任意一个出现空闲时，工作人员指示队列中第一个
人出队到该空闲窗口接受查验。对于上述场景， JDK 中提供了个Semaphore 的信号
同步类，只有在调用Semaphore 对象的acquire（）成功后，才可以往下执行，完成后执
行release（） 释放持有的信号量，下一个线程就可以马上获取这个空闲信号量进入执行。
基于Semaphore 的示例代码如下。
public class CustomCheckWindow {
public static void main(String[) args ) {
／咱，
Semaphore semaphore= new Semaphore( 3 );
for (int i = 1; i <= 5 ; i++) {
new SecurityCheckThread (i, semaphore) . start( );
private static class SecurityCheckThread extends Thread {
private int seq;
private Semaphore semaphore ;
public SecurityCheckThread(int seq, Semaphore semaphore) {
this .seq = seq;
this .semaphore = semaphore;
@Override
public void run() {
try {
semaphore.acquire();
System . out . println ( ” No . ” + seq ＋ ” 乘客． 正在查验中” ）；
4三
if (seq 宅2 == 0 ) {
Thread . sleep( lOOO );
System . out . println( "No . ” + seq ＋ ” 乘客． 岛份可疑．
在能出同！ ” );
} catch (InterruptedException e) {
e . printStackTrace() ;
} finally {
233
码出高效Java 开发手册
semaphore . release() ;
System . out . println （ ” N飞．·’ ＋ seq + " ·;;.. e :." L飞"l!_ l乍” ）；
执行结果如下
No . 2 乘客，正在查验中
No . 3 乘客，正在查验中
No .l 乘客，正在查验中
N o . 1 乘客已完成服务。
No . 3 乘客已完成服务。
No . 4 乘客， 正在查验中
No . 5 乘客， 正在查验中
No . 5 乘客已完成服务。
N o . 2 乘客， 身份可疑， 不能出国！
No . 2 乘客已完成服务。
No . 4 乘客， 身份可疑， 不能出国！
No . 4 乘客已完成服务。
如果某个人身份可疑，需要确认更多的信息， 这不会影响到其他窗口的安检速度。
只要其他线程能够拿到空闲信号量，都可以马上执行。如果Semaphore 的窗口信号量
等于l ， 就是最典型的互斥锁。
还有其他同步方式， 如CyclicBarrier 是基于同步到达某个点的信号量触发机制。
Cyc l icBarrier 从命名上即可知道它是一个可以循环使用（ Cycl ic ）的屏障式（ Barrier)
多线程协作方式。采用这种方式进行刚才的安检服务， 就是3 个人同时进去，只有3
个人都完成安检，才会放下一批进来。这是一种非常低效的安检方式。但在某种场景
下就是非常正确的方式，假设在机场排队打车时，现场工作人员统一指挥，每次放3
辆车进来，坐满后开走， 再放下一批车和人进来。通过Cycl icBarrier 的reset（） 来释放
线程资源。
最后温馨提示， 无论从性能还是安全性上考虑， 我们尽量使用并发包中提供的信
号同步类， 避免使用对象的wait（） 和notify（） 方式来进行同步。
234
第7 章并发与多结程
7.4 线程池
7.4.1 线程池的好处
线程使应用能够更加充分合理地协调利用CPU 、内存、网络、1/0 等系统资源。
结程的创建需要开辟虚拟机枪、本地方法枝、程序计数器等线程私有的内存空间。在
线程销毁时需要回收这些系统资源。频繁地创建和销毁线程会浪费大量的系统资源，
增加并发编程风险。另外，在服务器负载过大的时候，如何让新的线程等待或者友好
地拒绝服务？这些都是线程自身无法解决的。所以需要通过线程池协调多个线程， 并
实现类似主次线程隔离、定时执行、周期执行等任务。线程池的作用包括·
·利用线程池管理并复用线程、控制最大并发数等。
· 实现任务线程队列缓存策略和拒绝机制。
· 实现某些与时间相关的功能，如定时执行、周期执行等。
· 隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两
个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池，
将较慢的交易服务与搜索服务隔离开，避免各服务线程相互影响。
在了解线程池的基本作用后，我们学习下线程池是如何创建线程的。
首先从ThreadPoolExecutor 构造方法讲起， 学习如何自定义ThreadF actory 和
RejectedExecutionHandler ， 并编写一个最简单的线程池示例。然后，通过分析
ThreadPoo!Executor 的execute 和addWorker 两个核心方法，学习如何把任务线程加入
到线程池中运行。T hreadPoo!Executor 的构造方法如下，
public ThreadPoolExecutor(
int corePoolSize , II
int maximumPoolSize, ti
long keepAliveTime , I/
TimeUnit un 工t, I.'
BlockingQueue<runnable> workQueue , // (
ThreadFactory threadFactory,
RejectedExecutionHandler handler) {
if (corePoolSize < 0 I I
内.ax'm11 盯飞、、1、1 气f 飞飞J- 1 ~；. '"
maximumP 。olS 工ze <= 0 I I
maximumPoolSize < corePoolSize I I
keepAliveTime < 0 )
throw new IllegalArgumentExcept 工on();
、叫f'PoolSi:e （ 第1 处）
235
码出高效： Java 开发手册
（第2 处）
if (workQueue == null I I threadFactory == null I I handler == null )
throw new NullPointerException();
/ /, l'
第l 个参数I corePoo!Size 表示常驻核心线程数。如果等于0 ，则任务执行完之后，
没有任何请求进入时销毁线程池的线程，如果大于0 ，即使本地任务执行完毕，核心
线程也不会被销毁。这个值的设置非常关键，设置过大会浪费资源，设置过小会导致
结程频繁地创建或销毁。
第2 个参数。maximumPoo!Size 表示线程池能够容纳同时执行的最大线程数。从
上方示例代码中的第1 处来看，必须大于或等于1 。如果待执行的线程数大于此值，
需要借助第5 个参数的帮助，缓存在队列中。如果maximumPoo!Size 与corePoo!Size
相等，即是固定大小线程池。
第3 个参数： keepAliveTime 表示线程池中的线程空闲时间，当空闲时间达
到keepAliveTime 值时，线程会被销毁，直到只剩下corePoolSize 个线程为止，避
免浪费内存和旬柄资源。在默认情况下，当线程池的线程数大于corePoo!Size 时，
keepAliveTime 才会起作用。但是当ThreadPoo!Executor 的allowCoreThreadTimeOut
变量设置为true 时， 核心线程超时后也会被回收。
第4 个参数TimeUnit 表示时间单位。keepAliveTime 的时间单位通常是
TimeUnit.SECONDS 。
第5 个参数， workQueue 表示缓存队列。当请求的线程数大于maximumPoo!Size
时， 线程进入BlockingQueue 阻塞队列。后续示例代码申使用的LinkedBlockingQueue
是单向链表，使用锁来控制入队和出队的原子性，两个锁分另lj控制元素的添加和获取，
是一个生产消费模型队列。
第6 个参数threadFactory 表示线程工厂。它用来生产一组相同任务的结程。线
程池的命名是通过给这个factory 增加组名前缀来实现的。在虚拟机枝分析时，就可
以知道线程任务是由哪个线程工厂产生的。
第7 个参数handler 表示执行拒绝策晤的对象。当超过第5 个参数workQueue
的任务缓存区上限的时候，就可以通过该策略处理请求，这是种简单的限流保护。
像某年双十没有处理好访问流量过载时的拒绝策略，导致内部测试页面被展示出来，
使用户手足无措。友好的拒绝策略可以是如下三种
1236
仅供非商业用途或交流学习使用
第7 章并发与多结程
( I ）保存到数据库进行{jlj峰填谷。在空间时丐提取出来执行。
( 2 ） 转向某个提示页由。
( 3 ) VfD Fl 毛。
从代码第2 处来看， 队列、线程工厂、拒绝处理服务都必须有实例对象， 但在实
际编程中，很少有程序员对这三者进行实例化，而通过Executors 这个线程池静态工
厂提供默认实现， 那么Exceutors 与ThreadPool Executor 是什么关系呢？线程池相关
类图如图7-4 所示。
I Exe山「｜ ...
E x ecutorSe 「vice
Abst「actE x ecuto 「Serv i ce Sc h edu l edE x ecuto 「Service
I Fo咔Joi n Pool I T h 「ead P oo l E x ecuto 「
Schedu l edTh 「eadPoolE x ecutor
图7-4 线程池相关类图
／＊诀
* @param 线程任务
节e L hrows· RE i ectedExζt..u' i 1nEx 、：ert ion llri 未飞江南！！范作扣I t 态的约tr 1'下每‘
贺／
void execute (Runnable command );
ExecutorService 接口继承了Executor 接口，定义了管理线程任务的方法。
ExecutorService 的抽象类A bstractExecutorService 提供了submi t（） 、invokeAll（） 等
部分方法的实现， 但是核心方法Executor.execute（） 并没有在这里实现。因为所
有的任务都在这个方法里执行， 不同实现会带来不同的执行策略，这点在后
续的ThreadPoo!Executor 解析时， 会一步步地分析。通过Executors 的静态工
厂方法可以创建三个结程池的包装对象。ForkJoinPool 、ThreadPooIExecutor 、
ScheduledThreadPoolExecutor。Executors 核心的方法有五个
237
仅供＇II二商业用途或交流学习使用
码出高效· J ava 开发手册
• Executors.newWorkStealingPool: JDK8 引人，创建持有足够线程的线程池支
持给定的并行度， 并通过使用多个队歹lj减少竞争， 此构造方法中把CPU 数量
设置为默认的并行度ι
public static E xecutorSer飞rice n ewWo r kSteal 工ngPool ( ) {
产I
return new ForkJoinPool(Runtime . getRuntime () . a飞railab l eProcessors ( ) ,
ForkJoi nPool .defaultForkJoinWorke r ThreadFactory,
null , true);
• Executors.newCachedThreadPool: maximumPoolSize 最大可以至Integer. MAX_
VAL阻， 是高度可伸缩的线程池， 如果达到这个上限， 相信没有任何服务器
能够继续工作，肯定会抛出OOM 异常。keepAliveTime 默认为60 秒，工作
线程处于空闲状态， 贝lj 回收工作线程。如果任务数增加， 再次创建出新线程
处理任务。
• Executors.r
上述相同’ 存在OOM 风险。它是Schedu ledExecutorService 接口家族的实现类，
支持定时及周期性任务执行。相比Timer , Schedu l edExecutorService 更安全，
功能更强大， 与newCachedThreadPool 的区别是不回收工作线程。
• Executors.newSingl eThreadExecutor ： 创建个单线程的线程池，相当于单线
程串行执行所有任务， 保证接任务的提交顺序依次执行。
• Executors.newFixedThreadPool : 输入的参数即是固定线程数，既是核心线程
数也是最大线程数， 不存在空闲线程，所以keepAliveTime 等于O·
public static Executor Service newFixedThreadPool (int nThreads ) {
return new ThreadPoolExecutor(nThreads , nThreads , OL,
Ti meUni t .MILLISECONDS , new LinkedBlockingQueue<runnable>()) ;
这里， 输入的队歹lj没有指明长度，下面介绍LinkedB lockin gQueue 的构造方法·
public LinkedBlockingQueue() {
this (Integer .MAX VALUE );
使用这样的无界队歹lj ， 如果瞬间请求非常大， 会有OOM 的风险。除
newWorkStealingPool 外， 其他四个创建方式都存在资源耗尽的风险。
238
仅供－ 11 ： 商业用途或交流学习使用
第7 章并发与多结程
Executors 中默认的线程工厂和拒绝策路过于简单，通常对用户不够友好。线程
工厂需要做创建前的准备工作，对线程池创建的线程必须明确标识，就像药品的生产
批号一样，为线程本身指定有意义的名称和相应的序列号。拒绝策略应该考虑到业务
场景，返回相应的提示或者友好地跳转。以下为简单的ThreadF actory 示例
public class UserThreadFactory implements ThreadFactory {
private final String namePrefix;
private final Atomicinteger nextid = new Atomicinteger( l );
d 号召1 平- • 飞仨古丁量也
UserThreadFactory(String whatFeatureOfGroup) {
namePref ix = ” ’白’ c.r 亏’ s ” ＋ whatFeatureOfGroup
＋ ”哥’ ，
@Override
publi c Thread newThread(Runnable task) {
String name = namePrefix + nextid.getAndincrement ();
Thread thread= new Thread( null , task , name ， 。， false );
System. out .println (thread. getName ());
return thread;
I I ,_ '- J俨
class Task implements Runnable {
private final AtomicLong count= new AtomicLong( OL );
自Override
public void run () {
System . out . println （ ” J~ n . τlg ” ＋ count . getAndincrement()) ;
上述示例包括线程工厂和任务执行休的定义， 通过newThread 方法快速、统一地
创建线程任务，强调线程一定要有特定意义的名称，方便出错时回溯。
如图7 -5 所示为排查底层公共缓存调用出错时的截图，绿色框采用自定义的结
程工厂，明显比蓝色框默认的线程工厂创建的线程名称拥有更多的额外信息。如调
用来源、线程的业务含义，有助于快速定位到死锁、StackOverflow Error 等问题。
239 1
仅供作商业用埠或交流学习使用
码出高效· J ava 开发手册
}
．、‘，
E9 e3 1
@
b2
1
0
:
e
na
g
ov
a
-&
a
-
zJ
I
--
a
dr
e
ne
2
02
@
C1
·
sn
e
v0
7
er
@
zh
@
SE
e
nn
a
。
y
-a
rs
e
hg
l
ce nu
n
ve
。
su
a
do
t
et
--
uc
d
ea
n
ur
。
01
C
EB
}}
cb77
n
aA
}
21
0
rt7
1
6
飞飞｝
6I
q
--
Zoa
n
ba41auv
a
Awd
-
va
t
-
8·aa
-
-
sa
“vj
a
ktv2··r
W
Ee
--
jro
oe
--
oz
3
11
·
rtHU
e
-
bpOUE
b
tsoutζe
a
n70eueua
2
EEOUC
足
ε
x
r
:
aoeEt
e
ratg
筑
lo
－－
UM
－－
anE
。
a
d
cad
－－
t
。
P
£
nJnkopd
n
o
-
ocoda
ctEOpae
o
rSIder
e
torsarh
a
apeuehy
a
tpzery
-
-
uuIkhtn
b
snnyru
3
ak
。
Ater
E
VErLLRK
c
a
。”｛
srr
··
>
Lzeaoe
f
tnkywk
7
2·kyatn
俨
B
Irsteuo
’
’-
dqrw
..
,
pee
-
og
e
e
-
uurrr
x
steeooo
e
7
俨
uuttt
｝
＝
＠。。。
uuu$
0
7·p19ceca
-
d3PEn
-zee7
.‘
107uataax ’
h6srkEEEa
I
nt7KEel
-‘
tuv
3
1eec
，，。。。
oa
Z
枫问＠。
b
飞
ago
－
o
reLABPPP
··
aee
-
-odddd
r
pves
--
zaaaa
p
{
··akkkeeee
－
飞＠
CEnrrrr
s
Gaxo
。
ahhhhn
。
MNe
－－－
tTYTT
Et
‘
...
..
{
5
TKEta
-‘‘
tn
=
zrnnnnnnu
O
Aaree
--
Eeer
－
－RP
。
rrrrrr
r
frrrrrra
p
eeuuuuuua ef
飞
ECEζCEe
8
1a
且
nnnnnnr
－
aesa
。。。。。。”
3
tnwCEECEET
--
su
--
l
ilt
-
119
1
<
Ea
--
AAAn
i
s--::
a
i;
uuuuuut
l::
;
iaaaaaaa
l
nk:::
v
1
uFaaaaaaa
i
;
ill
--
;
p
i
t:::
t
i
aaaaaaaa
; - i i
loCllt!d 向】吨ab ＼~气yoch r。n tzers
"one
，、，
e3 1· b2
·
na
o
。”
W
O
卫’－
8
2
’
dr
@
ne
2
。
E
S
Ca
-
-n
e
，。
7
er
e
zh
e
nn
＠
。
y
u典
rs
e
hd
l
Ee
n
ye
o
su
i
do
t
et
d
ea
n
ur
o
OE
c
tgJl cb77
n
···
”’
23
。
rt716．‘．、｝
6
－
9
gazen
ba41av
i
AW
--
va
t
-
aaaJ
a
ktv
‘··F
W
CCa1
，。
。
e1
。
t
3
11·rtu
e
‘,
beouc
’
－
tsou
－、
ce
a
n
?”
eueMA
z
e
-
oucxE
WA
rtoeEt
-
rat9x10
z
uvinEoo
d
cae
-A10p
i
n
』
nkopa
n
o--
godua
EEE
。
pae
e
rstdeF
0
4
。
rgarh
e
a’
edehny
g
tpzery
{
g
uu
-
khtn
z
snnyru
3
akoa
{
ev
e
verLLRK
c
·
。
htsvr
f
AKEea
。－
E
f
tnkywk
7
·by
--‘
n,
@
trsteue
e
-
d
-
9,w
g
飞pnvee
－－’
·
·
·
uurrr
x
steeooe
e
ueruuEERi
z
--
oouuus
d
｝－
pt9ζEZ4
1
d3pcneee7
t
｝
0·EU
－－
Lam
－局
’hSSFKEEEa
t
nE
,
ktEt
--
v
3
Ae
，，、，，。
oooa
＝
k
”．。也飞。。。
l
o
r
－－、
aREPPP
-
aee
--
ddddo
r
pv-sseaaaa p
｛且’
hkk
－E·E
－ze
－
，‘．，、
ζnrrrr
s
Gaxooih
川
hh
。
”
N－ttkyTTT
S
Tktttzttn
z
zrnnnnnnu
O
A·r
-Ee·e
-zee
,
aA
MP
@
rrrrrr
p
eeuuuuuua
eft
，、，、
εεεce
7
1·annnnnnr z
a
－－。。。。。。
h
3
tnM
，、
EECEEY
--
su
‘.E, ..
。
ttttttq
;
EE
--
Baa
-
n
i::
ttta
i
ii
:
1
;: ;
-
Baa
--
j
i
nkvvvvvvv
-
Ja
--···
i
jll
--
i
ttt::
1:::
Loζ... 。wn.lb 飞• synchcon1ur.
”。..
8 8 @ b 8 8 8 2 8 @ 。
｝
7
t
e
c
e
e
@
>
8
b
x
o
e
n
l
o -
n
z
。
a
i
d
t
n
i
o
d
c
n
$
0
r
z
e z
n
B
o
an 。
9
,
n
n
i
c
t
n
-
y
a
s
w
d -E
3
u
e
e
7
u
a
0
2
Z
MA
C
e
a
=
r
d
e
l
·’
n
抽
@ e
s
e
k
z
z
c
。
s
t
2
·
e
ts
c
n7
f
ez
f
f
7
ra
e
uv
e
Ea
e
nJ
e
o·
樨
Et
e
-
r
z
l
。
d
1p
z
tp
t
uu -s
l
at
恨
3
vc
＝
画。
。
SK
A
{
r
ah
s
tF
lw
a
s
－
、，
P
。
8·’
t
5
2r
z
go
o
--
p
i
d3P
T
｝。
fu
p
9hEGS
nt7
‘民
6
1eeE
-
h”-
0
3
r
-
t
’
aea
’
!
i
;;
k
i
teE
i: 1
;:
1: 1
rn
i: ;:, :
ir
l: i:
c
l; i
i
:
E
l
u
-
-
-
ot
i
:
1
i: ;
aqu
.--F-
n-
i
i
i
j
l: -7
·9ga
-
--m-Mtgt ;: 国
州
国
ι
i
图7- 5 有意义的线程命名
下面再简单地实现一下RejectedExecutionHandler ，实现了接口的rejectedExecution
方法，打印出当前线程池状态，源码如下。
public class UserRejectHandler implements RejectedExecutionHandler {
@Override
public void re] ectedExecution(Runnable task,
ThreadPoolExecutor executor) {
System . out . println ( ” task re] PCt e d . ” + executor . toString()) ;
在ThreadPoo!Executor 中提供了四个公开的内部静态类
• AbortPol icy （默认）：丢弃任务并抛出RejectedExecutionException 异常。
• DiscardPolicy ： 丢弃任务，但是不抛出异常， 这是不推荐的做法。
• DiscardOldestPolicy ： 抛弃队列中等待最久的任务， 然后把当前任务加入队
列中。
• Call erRunsPo l icy ：调用任务的run （）方法绕过线程池直接执行。
根据之前实现的结程工厂和拒绝策略，线程池的相关代码实现如下·
public class UserThreadPool {
public static void main(String[] args ) {
／／续存队手1j 设置固定长度为2. 为了快速触发rejectHandler
BlockingQueue queue = new LinkedBlockingQueue( 2 );
1240
仅供叶商业用遥或交流学习使用
第7 章并发与多结程
手引号飞L~ 唁工节” F再ιv ~ '';;. ' ' - <
UserThreadFactory fl = new UserThreadFactory （ ” 古1 机房” ） ；
UserThreadFactory f2 = new User ThreadFactory ( ” if, 2 机房” ） ；
UserRejectHand ler handler = new UserRejec tHandler ();
/ ιA 与＇1'. 书＇ 1. 走’多’ ．勺了y, ·r_ －走rejectHc:l.ndler
ThreadPoolExec utor threadPoolFirst
= new ThreadPo olExe c utor( l , 2 , 60 ,
TimeUn it.SECONDS , queue , fl , handle r);
／／会？：二1、线亮句•j •1J 't. 事之机约和池
ThreadPoolExecutor threadPoolSecond
= new ThreadPoolExecutor( l , 2 , 60 ,
TimeUnit . SECONDS , queue , f2 , handler) ;
// 有11 ~ '-J (] C i fτt z卡哇
Runnable task= new Task();
for (int i = O; i < 200 ; i++) {
threadPoolFirst . execute ( task) ;
threadPoolSeco nd . exec ute(task) ;
执行结果如下
From User Thr eadFactory ’ s 第1 机房－ Wor k er -1
From UserThreadFactory ’ s 第2 机房－ Worker - 1
From UserThreadFactory ’ s 第1 机房－ Worker - 2
From UserThreadFactory ’ s 第2 机房－ Worker - 2
running 2
running 3
r u n n ing 4
ru口n ing 5
running_ O
running_ l
your task is re j ected . java . util . concurr en t . ThreadPoolExecutor@l396
9fbe[Running , pool size = 2 , active threads = 2 , queued tasks = 2 ,
completed tasks = l]
当任务被拒绝的时候，拒绝策略会打印出当前线程池的大小已经达到了
maximumPoo! S i ze =2 ，且队列已满，完成的任务数提示已经有1 个（最后一行）。
241
仅供'I非商业fljj幸成交流学习使用
码出高效J ava 开发手册
7.4.2 线程池j原码详解
在ThreadPool Executor 的属性定义中频繁地用位移运算来表示线程池状态， f立
移运算是改变当前值的一种高效手段， 包括左移与右移。下面从属性定义开始阅读
ThreadPoolExecutor 的源码。
’ f 二＿｝ l L－~飞J Z 红～ J 》, LC l !\_ r 俨，ι ，－ i'.!t ·－~ H 全市是付7
山. I" ~ ~ ＂＂~ - 式
，、、
e 汇· _, 'U • .., <; 8 · （第1 处）
private static final int COUNT_B I TS ＝ 工nt eger . S I ZE - 3 ;
I/ l)JC'-11-llLl l 工l 1: 111 吨11 吨11 吨i lτ111 . ~飞f:I 干9 ”飞
J 士～ E伊‘
℃辛苦价3 ·-1r ‘ t
private static final int COUNT_ MA S K = ( 1 < COUN T_B I TS ) - l ;
/, ：生~~i 3 付．气. ) ' !i;_ F ，也非气（在1 』役之'i' t. λ 卡r 气’ .!1H'
/I 111 -:.'0JOOO)O 。”。lQOI lQO,JOO-lOOO )(,(, . 卡主哇吉，. \ : －：，悦， P I) ,
μ｛ γR 去← J飞’
private static final int RUNNING = - 1 < COUNT_BITS ;
// 00) -0 η000')0C11JOCOOl o J001JC 【00 巳ooc 已。． 十进；训班：，＇.
I I if ＂＇气乓再接哇.· /f +. '", " ＂在，， 11 ' .＇中均怀々
private static final int SHU T DOWN = O < COUNT_BIT S;
II C'Ol -rJ ] C00'.)001C 0 JC'OO 丁COJC'O"OOOOOOO . ← 5吃串＇］ fr~ : c 巾， 87C, 'l1
/ 七1 比叫人oii 二？” · :i-r, 』J 、勺’牛
private static final int STOP = 1 < COUNT_BITS ;
II u i ℃－ l OJC' OJ"OJC'Oll C 00 Ci .l ‘ 00 、C co J . 卡·生拿； ti＂ ：唱， ·n 古， 14 ,E< '!.
d 护l 凡、｛飞J王＇ fl
private static final int TIDYING = 2 < COUNT_BITS ;
11 1Jll -JC'UOOOrJOC'OJ 巳u ）巳巳f)n 巳OJCO.l 巳C'OOC. 卡i些d 付： , E 气。， b -. , 7 ~巳
11 A:.:t1、足飞、毛"
private static final int TERMI NATED = 3 < COUNT_B IT S ;
// 古飞；i. 1'..1w 号。~ -01 )')< (1 )(·(1 )J 〔rJ')(.llJCOrJOOOJlUJ 飞ι ． 气，气、，『1' l (' 起程．
／／千d 取＂＇＇ ： 11-JCO l ,oo .JC 11 、巳O JOCO',C'OOOOJJCO JC' . “V 扣~ '.:ii C'Ol.
专f哇’r
private static int runStateOf (int c) { return c &~COUNT MASK ; }
两i
J ♂ ~ i 'lill 噜． , '
private static int workerCountOf ( int c ) { retur n c & COUNT MASK ; }
I I tP, t 也3 位与右’t 二q 气，＿）＂： 戎旬之~i' . "' ： 钱1、气
242
仅供叶商业用遥或交流学习使用
第7 章并发与多结程
private static int etlOf( int rs , int we) { return rs I we ; }
第l ：处说明， 线程池的状态用高3 位表示，其中包括了符号位。五种状态的
十进制值按从小到大依次排序为RUNNING < SHUTDOWN < STOP < TIDYING <
TERMINATED ， 这样设计的好处是可以通过比较值的大小来确定线程池的状态。例
如程序中经常会出现isRunnin g 的判断
private static boolean i sRunning( int e) {
return e < SHUTDOWN ;
我们都知道Ex ecutor 接口有且只有－个方法execute ， 通过参数传入待执行线程
的对象。下面分析ThreadPoo!Executor 关于execute 方法的实现，
public void exeeute(Runnable eommaηd) {
守＂ , , ,,, f, ·~＂ i','I; '" rrteger J~ 理~r (tl
int e = etl . get ();
俨钉详：飞
if (workerCountOf(e) < eorePoolSize) {
亨
if (addWorker (eommand , true ))
return ;
·但．：卢‘；l、：~口气生ι ’呈z !' ~.i 人，写任
e = et l. get () ;
lJιi <- 1”二＂，. ’,,
if (isRunning(e) && workQueue.offer(eommand)) {
int reeheek = etl . get() ;
R 二J
if ( ! isRunning(reeheek) && remove(command))
r ejeet(eommand) ;
else if (w orkerCountOf ( reeheek ) == 0 )
addWorker( null , false );
、王鸟
} else if ( ! addWorker (eommand, false ))
~μ a 叫L '-er r ~ P •• • ,
reject (eommand) ;
1 飞
（第1 处）
（第2 处）
第l 处： execute 方法在不同的阶段有三次a dd Worker 的尝试动作。
243
仅供＃商业用途或交流学习使用
码出高效： J ava 开发手册
第2 处， 发生拒绝的理由有两个( 1 ） 线程池状态为非Rill刑ING 状态（ 2)
等待队列己满。
下面继续分析addWorker 方法的源码，
／＊、
* tit ＇署当前冯~池吃亏飞．检t（是否可；，＇. ~；加宫’为仨苓i足轻．已~ \f;: "f ,} i'1 户；建于言寺； f 象
＊生口呆－ ~l] 正主咧斗S 21 true ~~臼false 树可在平如下：
安1. ！｛.. 洼地1\t 育处于RUNNING 状态
* 2 . f飞程工广创建新的任~线f~ 失败
台first Task ：干部g 主t ·lf呈，{ii. :t 吾主H号毛的苇一个2王岛．它是是程的手tj.
* core ： 新常工作绞程。才约，，；！］如指杯. t:i 路如下
true 专示亲！哈工作线程时．需要斗中Jj- 当前RUNNING 状毛的线往是否少于corePoc,lS 工ze
女false 表示新增工作线笔对．等著J嘀当前RUNNING i,~ 冬的纹理是否吁rr.axlll1umPoolSize
食l
private boolean addWorker(Runnable firstTask , boolean core) {
// 在J &.t t 冬京定足自甘苦圭手签．啕咛下之；.J continue retry. '1t".l.. ·.;_ f甘各层乒t: f苦苦，. （第1 处）
retry :
1244
for (int c = ctl.get () ;;) {
// 张专之在a';·\ "15 ＇宇生吁：码要PUNNING~）；、古~. ljlj :r-- 件为侣. ；，（ 柏？后窑的多
／／也果是STOP 及之上的次毛．气·＃ firstTask 平j ｛告我ti 吃力空．主瓦者飞j 为空电
／／却会直接：~ u!J ＇~1J 莲k －~iz （第2 处）
if (runStateAtLeast(c , SHUTDOWN )
&& (runStateAtLeast(c , STOP) I I firstTask ! = null
I I workQueue . isEmpty () ) )
return false ;
for (;;) {
／／如果超过是六允丁子必程在.：i 下注再示加到灼绞程
／／最气〈停飞τ 能超过J '2 9. 否则骂，阶t -;,_ 1走3 位约儿程也吠恋信
if (workerCountOf(c)
>= ( ( core?corePoolS 工ze:maximumPoolSize ) &COUNT MASK ) )
return false ;
／／将当苦J舌均1立于呈敬＋ l （第3 处｝
if ( compareA口d 工ncrementWorkerCount ( c ))
break retry ;
／／线呈也对（~字口工作气程放是可变化约．需要经常提取达1、最著i ;;;:
c = ctl.get() ;
／／切果已？关明．别再次从retry 标签处进入噜在结2 处再做判断（第4 处）
if (ru口StateAtLeast(c , SHUTDOWN))
continue retry;
第7 章并发与多结程
／／缸＇ft I飞11. 飞＂ ' x 且U刊NING ’t 毛．可~~吃苦泞百： f':Z 1 是ti'l3~， l<..~
／／哩作J tr-;11 fr （第5 处）
11 ~t· til ''· 1二4”呻f"
boolean workerStarted = false ;
boolean workerAdded = false ;
Worker w = null ;
try {
’, .W 门
、r.1户
、
、A• 主快牛气二t f1orker 对句
w = new ThreadPoolExecutor.Worker(firstTask);
'i-. ，、t w飞k ~ ·~’咱村「、th re 刊（第6 处）
final Thread t = w.thread;
if (t ! = null ) {
／／才叫i l'b 叫adPoolE:-:ec1」tor 的筑总出「～
，，足
final ReentrantLock mainLock = this .mainLock;
mainLock.lock();
try {
int c = ctl . get() ;
／／、I ＼’ i\' ＇状:t 为RUNNING F戈SHUTDOWN
aSK 、·J "’
if (isRunn 工ng(c) I I (runStateLessThan(c, STOP)
&& firstTask == nul 工）） ｛
workers.add(w);
int s =workers.size();
/ 队，总倦、）.＇ i: 、、俨T ;;: . F飞飞－＊；＿排豆l 导l、民
if (s > largestPoolSize) largestPoolSize = s ;
workerAdded = true;
} finally {
mainLock . unlock();
if (workerAdded ) {
·~＇ ,.;-' ·，毛t '3.1 t 于－＇！；
I 1 •峪．、ii
t.start() ;
workerStarted = true ;
} finally {
if ( ! workerStarted)
／叹， I.日动i , . t' r~u r ~i 3 处)Jp 卡的工作绞f'_ i 十；吉＇l-ri- 问问主
245
码出高效： Java 开发手册
addWorkerFailed(w);
return workerStarted;
这段代码晦涩难懂，部分地方甚至违反了代码规约，但其中蕴含的丰富的编码知
识点值得我们去学习，下面接序号来依次讲解。
第l 处， 配合循环语旬出现的label ，类似于goto 作用。label 定义时，必须把标
签和冒号的组合语旬紧紧相邻定义在循环体之前，否则会编译出错。目的是在实现多
重循环时能够快速退出到任何一层。这种做法的出发点似乎非常贴心，但是在大型软
件项目中，滥用标签行跳转的后果将是灾难性的。示例代码中，在retry 下方有两个
无限循环，在workerCount 加l 成功后，直接退出两层循环。
第2 处，这样的表达式不利于代码阅读，应该改成
B。。工ean isNotAllowedToCreateTask
= runStateAtLeast(c , SHUTDOWN) && (runStateAtLeast(c, STOP)
I I firstTask ! = null I I workQueue . isEmpty ());
if (isNotAllowedToCreateTask) {
//...
第3 处， 与第1 处的标签呼应， Atomiclnteger 对象的加l 操作是原子性的。
break retry 表示直接跳出与retry 相邻的这个循环体。
第4 处，此continue 跳转至标签处，继续执行循环。如果条件为假，贝lj说明线程
池还处于运行状态，即继续在for（； ；）循环内执行。
第5 处， co mpareAndlncrementWorkerCount 方法执行失败的概率非常低。即使失
败， 再次执行时成功的概率也是极高的，类似于自旋锁原理。这里的处理逻辑是先加1 '
创建失败再减l ，这是轻量处理并发创建线程的方式。如果先创建线程，成功再加l ,
当发现超出限制后再销毁线程，那么这样的处理方式明显比前者代价要大。
第6 处， Worker 对象是工作线程的核心类实现，部分源码如下
／食
~;fl F.口nnaLl μ . ·:ry 飞1占窍七E r ,r ( ~ r ... nWr,r Ker (• r L,J.
贪苦， I .Jo 货币'1..>j £
，、＇＂＇ ＂＇芽”” ζ 厅』area " · ..;; ？： ：丧I r' nWnk r
private final class Worker
extends AbstractQueuedSynchronizer
1246
第7 章并发与多结程
implements Runnable {
Worker(Runnable firstTask) {
I I t ;;! Ab.川I d 「tQueued己yncnrr;n1zer 的占it.
11 if rur 叫γk r 乌七执卡＿，， 1'' !,' l 气恬喂’中t
setState (-1 );
this . firstTask = firstTask;
this . thread= getThreadFactory() .newThread(this );
II J'i tbr d 在j[ st 司rr （）夕T, ｛~ i-i- rnnWo.' kd<? r t；~ Jj ；七
public void run() {
runWorker( this );
线程池的相关源码比较精炼，还包括线程池的销毁、任务提取和消费等，与线程
状态图一样，线程池也有自己独立的状态转化流程，本节不再展开。总结一下，使用
线程池要注意如下几点
（ ！ ）合土里以吕西叉参数1 应根据实际业务场景来设IT1于理1内［作线梧数。
( 2 ）线捍资源必须油dt支杠〉也提供，不允许在应用中n1 千显式创建线转。
( 3 ）创5扫射手现钱怦；1↑， fHlFJHljf' 有冉义的吗科有机， j飞ii¥ 出惜时间洲
线程池不允许使用Executors ，而是通过ThreadPoolExecutor 的方式创建，这样的
处理方式能更加明确线程池的运行规则，规避资源耗尽的风险。
7 .5 Thread Local
“水能载舟，亦能覆舟。”用这句话来形容ThreadLocal 最贴切不过。
ThreadLocal 初衷是在线程并发时，解决变量共享问题，但由于过度设计，比如弱51
用和哈希碰撞，导致理解难度大、使用成本高，反而成为故障高发点，容易出现内存
泄漏、脏数据、共享对象更新等问题。单从ThreadLocal 的命名看人们会认为只要用
它就对了，包治变量共享问题，然而并不是。本节以内存模型、弱引用、晗希算法为
铺垫， 然后从cs 真人游戏的示例代码入手，详细分析ThreadLocal 源码。我们从中
可以学习到全新的编程思维方式，并认识到问题的来源，也能够帮助我们谙熟此类的
设计之道，扬长避短。
247
码出高效： J ava 开发手册
7.5.1 引用类型
前面介绍了内存布局和垃圾回收，对象在堆上创建之后所持有的51 用其实是一种
变量类型，可｜用之间可以通过赋值构成条引用链。从GC Roots 开始遍历，判断引
用是否可达。引用的可达性是判断能否被垃圾回收的基本条件。NM 会据此自动管
理内存的分配与回收，不需要开发工程师干预。但在某些场景下，即使引用可达，也
希望能够根据语义的强弱进行有选择的回收，以保证系统的正常运行。根据可｜用类型
语义的强弱来决定垃圾回收的阶段，我们可以把引用分为强51 用、软引用、弱号｜用和
虚引用四类。后三类引用，本质上是可以让开发工程师通过代码方式来决定对象的垃
圾回收时机。我们先简要了解一下这四类引用。
强习｜用， 即S trong Reference ， 最为常见。如Object o均ect = new O均ect（）；这样的
变量声明和定义就会产生对该对象的强引用。只要对象有强引用指向，并且GC Roots
可达，那么Java 内存回收时，即使濒临内存耗尽，也不会回收该对象。
软引用， 即So ft Reference ， 亏｜用力度弱于
在即将OOM 之前，垃圾回收器会把这些软引用指向的对象加入回收范围，以获得更
多的内存空间，让程序能够继续健康运行。主要用来缓存服务器中间计算结果及不需
要实时保存的用户行为等。
弱引用， 即Weak Reference ， 引用强度较前两者更弱，也是用来描述非必需对象
的。如果弱引用指向的对象只存在弱可｜用这条线路，贝lj在下一次YGC 时会被回收。
由于YGC 时间的不确定性，弱引用何时被回收也具有不确定性。弱51 用主要用于指
向某个易消失的对象，在强引用断开后，此引用不会劫持对象。调用WeakReference.
get（）可能返回null ，要注意空指针异常。
虚引用， 即Phantom Reference ， 是极弱的一种可｜用关系，定义完成后，就无法
通过该引用获取指向的对象。为一个对象设置虚引用的唯一目的就是希望能在这个对
象被回收时收到一个系统通知。虚引用必须与引用队列联合使用，当垃圾回收时，如
果发现存在虚引用，就会在回收对象内存前，把这个虚引用加入与之关联的可｜用队列
中。
对象的引用类型如图7 -6 所示。
1248
－ 强召
锚’ 嗣同
［ 叫白rence<H
_ = n~w SoftRE!l~e「e户c巳5Hou~~ ＞（♀~I归di 中＿ _,. _
a圈，~ \l\l s l
［… ~ferenc…ρbuye 「3
= new WeakReference<House>(selle 「）；
锢’ 虚引用
「hantomR白re nee＜…叫4 ll = new PhantomReference<House>(seller, null); I
第7 章并发与多线程
…II House se e 「＝ new House; I
- se e 「＝ nu ;
, , , ,
, ,
, ,
, ,
, , ,
图7-6 对象的引用类型
举个具体例子， 在房产交易市场中， 某个卖家有一套房子，成功出售给某个买
家后引用置为null 。这里有4 个买家使用4 种不同的引用关系指向这套房子。买家
buye r ！ 是强引用，如果把seller 引用赋值给它，则永久有效，系统不会因为seller=null
就触发对这套房子的回收， 这是房屋交易市场最常见的交付方式。买家buyer2 是软
引用，只要不产生QOM , buyer2 . get （） 就可以获取房子对象， 就像房子是租来的一样。
买家buyer3 是弱引用， 一旦过户后， seller 置为null, buyer3 的房子持有时间估计只
有几秒钟， 卖家只是给买家做了一张假的房产证， 买家高兴了几秒钟后，发现房子已
经不是自己的了。buyer4 是虚引用， 定义完成后无法访问到房子对象，卖家只是虚构
了房源， 是空手套白狼的诈骗术。
强引用是最常用的，而虚引用在业务中几乎很难用到。本节重点介绍一下软
引用和弱引用。先来说明一下软引用的回收机制。首先设置口币4 参数－Xms20m
-Xm x 20m ， 即只有20MB 的堆内存空间。在下方的示例代码中不断地往集合里添加
House 对象， 而每个House 有2000 个Door 成员变量， 狭小的堆空间加上大对象的产
生， 就是为了尽快触达内存耗尽的｜商界状态，
249
码出高效： Java 开发手册
public class SoftRef erenceHouse (
public static void main(String[] args) {
（ （筝1 处）
L工st<SoftReference > houses = new ArrayL 工st<SoftReference> ();
int i = O;
while (true ) {
门ι1( ilct(new Hιl < E' () ) ;
SoftRef erence<House> buyer2
（第2 处）
= new SoftReference<House>(new House()) ;
' ·}
houses . add(buyer2);
System . out . println （ ＇’ 工＝ + (++i)) ;
class House {
private static final Integer DOOR NUMBER = 2000 ;
public Door[] doors= new Door[DOOR NUMBER] ;
class Door {)
new House（） 是匿名对象，产生之后即赋值给软51 用。正常运行一段时间后，内
存到达耗尽的｜自界状态， House$Door 超过lOMB 左右，内存占比达到8 0.4% ， 如图7-7
所示。
N•m• Liv e 伪t町’
εom.all baba . memory . anal yze . reference ”ouseSDoor(]
com.ahbaba.memory.analyze .reference House
Live Objecis
l0.02s.016 s " o I
20.016 8 ’ ·' ·' I
图7-7 软引用下的对象堆积
软引用的特性在数秒之后产生价值， House 对象数从干数量级迅速降到百数量级，
内存容量迅速被释放出来， 保证了程序的正常运行，如图7-8 所示。
Name Live Objects Live Bytes
．，町，在···'illli雪司， •in• i-r1-11 .. 'Elll I
com.allbaba.memory.analyze.reference.House 172 I 5 ， 』
图7 8 QOM 时软引用触发对象回收
250
第7 章并发与多结程
软引用So 负Refere nce 的父类Reference 的属性： private T referent ，它指向new
House （）对象，而So位Reference 的get （），也是调用了super.get（）来访问父类这个私有
属性。大量的House 在内存即将耗尽前，成功地次又一次被清理掉。对象buyer2
虽然是引用类型，但其本身还是占用一定内存空间的，它是被集合ArrayList 强引用
劫持的。在不断循环执行houses .a dd （） 后，在i=360035 时，终于产生了OOM 。软引用、
弱引用、虚号｜用均存在带有队列的构造方法·
public SoftR巳ference(T referent, ReferenceQueue<? super T> q){ ... }
可以在队列中检查哪个软引用的对象被回收了，从而把失去House 的软引用对
象清理掉。
反转一下剧情。在同一个类中， 使用完全相同的运行环境和内存参数，把
So 位Reference<Hous巳＞申被注释掉的两旬代码激活（即示例代码中的第1 处和第2 处），
同时把在后边标记了“剧情反转注释处”的3 旬代码注释掉，再次运行。观察下，
在没有软引用的情况下，这个循环能够撑多久？运行得到的结果在i=2 404 时，就产
生OOM 异常。这个示例简单地证明了软引用在内存紧张情况下的回收能力。软引用
一般用于在同一服务器内缓存中间结果。如果命中缓存，贝IJ 提取缓存结果，否则重新
计算或获取。但是，软引用肯定不是用来缓存高频数据的，万一服务器重启或者软引
用触发大规模回收，所有的访问将直接指向数据库，导致数据库的压力时大时小，甚
至崩溃。
如果内存没有达到OOM ，软引用持有的对象会被回收吗？下面用代码来验证一下
public class SoftRef erenceWhenidle {
public static void main(String[] args) {
House seller= new House();
I I （第1 处）
SoftReference <House> buyer2 = new SoftReference<House>(seller);
seller = null ;
while (true) {
I 1 ,,. if ，＿，件L ，~， i.>'. 』＼／M 玲「f ↓与政＇f'J 护
System. gc () ;
System.runFinalization();
if (buyer2. get() == null ) {
System.out.printl 口（ ” l 1seιe n 1• ) ;
break ;
} else {
251
码出高效： Java 开发手册
System . out . println ( ” still there .” );
System.gc （）方法建议垃圾收集器尽快进行垃圾收集，具体何时执行仍由口叫来
判断。S ystem.runFinal ization （） 方法的作用是强制调用已经失去引用对象的fi nalize（） 。
在代码中同时调用这两者，有利于更快地执行垃圾回收。在相同的运行环境下，
一直输出sti ll there ， 说明buyer2 一直持有new House （）的有效引用。如果在对方置为
null 时仍能自动感知，并且主动断开引用指向的对象， 这是哪种51 用方式可以担负的
使命？答案是弱引用。事实上，把示例代码中第1 处的两个红色S o丘Reference 修改
为WeakReference 即可实现回收。出于对WeakReference 的尊重，摒弃刚才催促垃圾
回收的代码，让Wea kReference 自然地被YGC 回收，使对象能够存活更长的时间。
我们可以在NM 启动参数加－ XX : +PrintGCDetails （或高版本JDK 使用－Xlog:gc ）采
观察GC 的触发情况
public class WeakReferenceWhenidle {
public static void main(String[) args) {
252
House seller = new House();
WeakReference<House> buyer3 = new WeakReference<House>(seller);
seller = null ;
long start = System . naηoTime ();
int count = O;
while ( true ) {
if (buyer3 . get () == null ) {
long duration= (System.nanoTime() - start) I ( 1000 * 1< l ) ;
System . out. println ( ” house is null and exited time = ”
+ duration + ” ms ” );
break;
} else {
System.out.println ( ” s till there . count = ” + (count++));
第7 章并发与多线程
执行结果如下，
still there . count = 2 3 2639
[GC [PSYoungGen : 65536K 一＞ 688K (76288K)) 65536K- > 696K (251392K) , 0 . 0074719
secs) [T 工mes : user=0 . 01 sys=0.00 , real=0 . 01 secs)
still there . count = 232 640
house is null and exited time = 1013ms
这个示例代码在YGC 下，可以轻松地回收Weak.Reference 指向的new House（） 对
象。Wea k.Reference 典型的应用是在WeakHashMap 中。在刚才的房源案例中， 卖家
的房子对应系列的房源资料，如果卖家的房源已经售出，贝lj 中介也不需要一直保存
相关信息，自动回收存储空间即可，如下方示例代码。
public class WeakHashMapTest {
public static void main (String [) args) {
House sellerl = new House （ ” l 号吴弘房：军” ） ;
Sellerinfo sellerinfol = new Sellerinfo();
House seller2 = new House （ ” 2 号美哀号＇＇ r1. " );
Sellerinfo sellerinfo2 = new Sellerinfo() ;
／／如r1 唤成HashM.ip, IJ!l/ KPy 是对HoUSl 、，，， .~~’／11·1 ’ ·r. 'I tl （第1 处）
WeakHashMap<House , Sellerinfb> weakHashMap
= new WeakHashMap<House, Sellerinfo>();
weakHashMap . put(sellerl , sellerinfol) ;
weakHashMap . put(seller2, sellerinfo2);
System . out.println ( ” 1-J akHashMap befci: 主口i;._l, ..;ize = ”
+ weakHashMap . size()) ;
sellerl = null ;
System . gc();
System.runFinalization();
II ~口小俨呐Ha ,J' '1, , .., ZE＇ ’气快~； ;- ( ·' （第2 处）
System.out.println ( ” weakHashMap after null , size = ”
+ weakHashMap.size());
System . out.println(weakHashMap) ;
253
码出高效： Java 开发手册
执行结果如下·
weakHashMap before null, size = 2
weakHashMap after null, size = 1
{ 2 号卖家房源＝com . alibaba . easy . coding . reference . Sellerinfo@326de728}
说明一下第1 处和第2 处。如果是HashMap, Key 就是强引用指向House 对象，
即使seller1 =null ，也并不影响HashMap 这个Key 被置为null。如果是HashMap,
则最后的size 依然等于2 ，而WeakHas灿fap 就是1 ，回收sellerl 指向的引用。因而
WeakHashMap 适用于缓存不敏感的临时信息的场景。例如，用户登录系统后的浏览
路径在关闭浏览器后可以自动清空。
WeakReference 这种特性也用在了ThreadLocal 上。JDK 中的设计原意是在
ThreadLocal 对象消失后，线程对象再持有这个ThreadLocal 对象是没有任何意义的，
应该进行回收，从而避免内存泄漏。这种设计的出发点很好，但在实际业务场景中却
并非如此，弱引用的设计方式反而增加了对ThreadLocal 和Thread 体系的理解难度。
除强可｜用外，其他三种引用可以减少对象在生命周期中所占用的内存大小。如果
控制得当，垃圾回收就能够随意地释放这些对象。如果使用了这些引用，就应该像示
例中的seller 一样，为避免强51 用劫持，把强51 用置为null ，否则这三种引用就无法
发挥它们的价值。这三者的使用成本是偏大的，开发工程师应该多去考虑如何不造成
内存泄漏，如何提升性能，使方法快速执行完成后形成自然回收。如果这些引用在程
序中使用不当，就会造成更大的风险。
7.5.2 Th 「eadlocal 价值
我们从真人cs 游戏说起。游戏开始时，每个人能够领到一把电子枪，枪把上有
三个数字：子弹数、杀敌数、自己的命数，为其设置的初始值分别为1500 、0 、10 。
假设战场上的每个人都是一个线程，那么这三个初始值写在哪里呢。如果每个线程
写死这三个值，万一将初始子弹数统改成1000 发呢？如果共享，那么线程之间的
并发修改会导致数据不准确。能不能构造这样一个对象，将这个对象设置为共享变
量，统一设置初始值，但是每个线程对这个值的修改都是互相独立的。这个对象就是
ThreadLocal。注意不能将其翻译为线程本地化或本地结程，英语恰当的名称应该叫作I
CopyValuelntoEveryThread。具体示例代码如下
public cl&•• CsGameByThreadLocal {
private •tatic final Integer BULLET_NUMBER = 1500;
private •tatic final Integer KILLED ENEMIES = O;
1254
第7 章并发与多结程
private static final Integer LIFE VALUE = 10 ;
private static final Integer TOTAL_PLAYERS = 10 ;
I I I ’·机坎f A 及:;r 句’咛可＇＂干问J” ;bl fl （第1 典1:)
private static final ThreadLocalRandom RANDOM
= ThreadLocalRandom.current();
I I "ii＜仲， －｛＇ 攻
private static final ThreadLocal ＜工nteger> BULLET NUMBER THREADLOCAL
{ ) (
f
‘
e u
、
J14
(
a
>
V
r1
-·’
eaR giE etB tiM nnU IiN <-lET aeE cqJ
?U
oe
守卜U
YLU
+Lnu
dnB aI e
n
re
dz
hd
eu
Tl
tt
r
ce
w
z
ez
e
e
t
n
v
o
o
z
=
g
p
／／初始｛t. 杀敌数
private static final ThreadLocal<Integer> KILLED ENEMIES THREADLOCAL
{ (
{
e u
、
J14
「、
a
>
V
J
E1
在
S
eanb qJlTi etM t
工
E
nnN I
--
E
<-lrD aeE cqdL oeL
TLU
←』甲
i
dnk aI e
n
re
dr
电扫唱
d
eu
Ti
tt
r
ce
w
r
er
e
e
t
n
v
o
o
z
＝由、
D·
// 毛叫L I）＇乌已吗备在
private static final ThreadLocal<Integer> LIFE_VALUE_THREADLOCAL
= new ThreadLocal<Integer>() {
自Override
protected Integer initial Value() {
return LIFE VALUE;
I I ·1~ , t廿＇ ＇员
private static class Player extends Thread {
@Override
public v。id run() {
Integer bullets = BULLET_NUMBER_THREADLOCAL.get()
RANDOM.nextint(BULLET NUMBER);
Integer killEnemies = KILLED ENEMIES_ THREADLOCAL. get() +
RANDOM.nextint(TOTAL PLAYERS/ 2 );
Integer lifeValue = LIFE_VALUE THREADLOCAL.get ()…
RANDOM.nextint(LIFE VALUE);
255
码出高效： J ava 开发手册
System . out . println (getName () + ”, BULLET NUMBER is "
+ bullets) ;
System . out .println(getName() + ”, KILLED ENEMIES is "
+ killEnemies) ;
System.out.pri 口tln (getName () + ”, LIFE VA;..UE is
+ lifeValue + ” \ n ” ) ;
BULLET NUMBER THREADLOCAL .remove ();
KILLED ENEMIES THREADLOCAL . remove ();
LIFE VALUE THREADLOCAL . remove ();
public static void main ( Str 工ng[] args ) {
For ( int 工＝ ; i < TOTAL PLAYERS ; i++ ) {
new Player() .start() ;
此示例中， 没有进行set 操作， 那么初始值又是如何进入每个线程成为独立拷
贝的呢？首先， 虽然ThreadLocal 在定义时覆写了initia!Value（） 方法，但并非是在
BULLET NUMBER THREADLOCAL 对象加载静态变量的时候执行的， 而是每个线
程在ThreadLocal. get（） 的时候都会执行到， 其源码如下
public T get( ) {
Thread t = Thread . currentThread() ;
ThreadLocalMap map= getMap(t) ;
if (map != null ) {
ThreadLocalMap.Entry e = map . getEntry (this );
if (e ' = null ) {
@S uppressWarnings ( ” unchecked" )
T result = (T) e . value ;
return result ;
return setinitialValue ();
每个线程都有自己的ThreadLoca!Map ， 如果map==null ，则直接执行
setlnitia!Value（）。如果map 已经创建，就表示Thread 类的threadLocals 属性已经初始化，
如果e==null ， 依然会执行到setlnitia!Value() 0 setlnitia!Value（） 的源码如下。
I 256
仅供非商业用途或交流学习使用
第7 章并发与多线程
protected T initialValue() {
return null ;
pr工vate T setinitialValue () {
／／这是一个保护非法. CsGameByThreadLocal 中初始化ThreadLocal 对象时已！在写
T value = initial Value();
Thread t = Thread . currentThread( );
II getMap 的源斗手l是提取钱t¥. 对象t 的ThreadLocalMap 属性： t threadLocals
ThreadLocalMap map = getMap(t);
if (map != null )
map.set( this , value) ;
else
createMap(t , value);
return value ;
在C sGameByThreadLocal 类的第l 处，使用了ThreadLoca!Random 生成单独的
Random 实例。此类在JDK7 中引人，它使得每个线程都可以有自己的随机数生成器。
我们要避免Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争
同－ seed 而导致性能下降。
我们已经知道了ThreadLocal 是每个线程单独持有的。因为每个线程都有独
立的变量副本，其他线程不能访问，所以不存在线程安全问题，也不会影响程序的执
行性能。ThreadLocal 对象通常是由private static 修饰的，因为都需要复制进入本地线
程，所以非static 作用不大。需要注意的是， Thread Local 无法解决共享对象的更新问题，
下面的代码实例将证明这点。因为CsGameByThreadLocal 中使用的是I nteger 的不可
变对象， 所以可以使用相同的编码方式来操作一下可变对象看看，示例源码如下
public class InitValueinThreadLocal {
private static final StringBuilder INIT_VALUE = new
StringBuilder ( ” init ” );
/ 写在写巾hreadL ，『al 的工nitialValue ， 返回StringBuilder ~＇革专引唱
private static final ThreadLocal<StringBuilder> builder
= new ThreadLocal<StringBuilder>() {
@Override
protected StringBuilder initial Value() {
return INIT VALUE ;
257
仅供'I非商业fljj幸成交流学习使用
码出高效： Java 开发手册
private static class AppendStringThread extends Thread {
@Override
public void run() {
StringBuilder inThread =builder.get();
for (int 主＝ 0 ; i < 10 ; i ++) {
inThread . append ( ”’' + i);
System ．。ut.println(inThread.toString());
public static void main(String[] args) thr。ws InterruptedException {
for (int i = u; i < 10 ; i++) {
new AppendStringThread() .start();
TimeUnit.SECONDS . sleep( );
输出的结果是乱序不可控的，所以使用某个引用来操作共享对象时，依然需要进
行线程同步。
我们看看T hreadLocal 和Thread 的类图，了解其主要方法，如图7-9 所示。
-static At。miclnteger nextHashCode
- int theadlocalHashC。de
T get.
，。1d se!'T value:
’01j ren 0·1e1
-void createMap()
-T setlnitialValue()
…m!!I酬”明事丽珊曹鸭”’…
EntryO table
-int threshold
-Entry ge!Entry(ThreadLocal key)
- Th rea1 I r比al.Th re~dl :alMap threadlocals
+synchronized void start()
-void se!(Threadlocal key,Oh1ect value)
void re01ove(Threadlcoa1 key)
+static native Thread currentThread() －」：
-Object value
-staticThreadLocal KILLED ENEMIES
-staticThread Lo cal LIFE VAL UE
图7-9 ThreadLocal 和Thread 的类关系图
258
仅供非商业用途或交流学习使用
第7 章并发与多线程
ThreadLocal 有个静态内部类叫ThreadLocalMap ，它还有个静态内部类
叫En町，在Thread 中的ThreadLoca!Map 属性的赋值是在ThreadLocal 类中的
createMap（）中进行的。ThreadLocal 与ThreadLocalMap 有三组对应的方法get（）、
set（）和remove（）， 在ThreadLocal 中对它们只做校验和判断，最终的实现会落在
ThreadLoca!Map 上。Entry 继承自WeakReference ，没有方法，只有一个value 成员变量，
它的key 是ThreadLocal 对象。再从枝与堆的内存角度看看两者的关系，如图7-10 所示。
I T~；宫前|
I 1x~眉眼：｜
晤时
钱
图7-10 中的简要关系
堆
（线程内成员变量）
ThreadlocalMa口对象
Entry对象－ 1
Jl 弱引用Key-1 I
Entry对象－ 2
飞船｜用Key-2 I
图7一10 TheadLocal 的弱引用路线图
• 1 个Thread 有且仅有1 个ThreadLoca!Map 对象，
• 1 个Entry 对象的Key 弱可｜用指向1 个ThreadLocal 对象；
• 1 个ThreadLoca\Map 对象存储多个Entry 对象，
• 1 个ThreadLocal 对象可以被多个结程所共享i
• ThreadLocal 对象不持有Value, Value 由线程的Entry 对象持有。
图中的红色虚线箭头是重点，也是整个ThreadLocal 难以理解的地方， Entry 的
源、码如下
259
仅供＇II二商业用途或交流学习使用
码出高效： J ava 开发手册
static class Entry extends WeakReference <Threadlocal<?>{
Obj ect value ;
Entry(ThreadLocal<?> k, Ob] ect v) {
super (k);
value = v ;
所有Entry 对象都被ThreadLocalMap 类实例化对象threadLocals 持有。当线程
对象执行完毕时， 线程对象内的实例属性均会被垃圾回收。源码中的红色字标识
的ThreadLoca l 的弱引用， 即使线程正在执行中， 只要ThreadLocal 对象引用被置成
null, Entry 的Key 就会自动在下一次YGC 时被垃圾回收。而在ThreadLocal 使用
set（） 和get（） 时， 又会自动地将那些key==null 的value 置为null ， 使value 能够被垃圾
回收，避免内存泄漏，但是理想很丰满， 现实很骨感， ThreadLocal 如源码注释所述
ThreadLocal instances are typically private static fields in classes.
Thr巳adLocal 对象通常作为私有静态变量使用， 那么其生命周期至少不会随着线
程结束而结束。
线程使用ThreadLocal 有三个重要方法·
( l ) set（） ： 如果没有set 操作的Thread Local ， 容易引起脏数据问题。
( 2 ) get（） ，始终没有get 操作的Thread Local 对象是没有意义的。
( 3 ) remove() ：如果没有rcmo\e 操作，容易引起内存）llh扁。
如果说一个ThreadLocal 是非静态的， 属于某个线程实例类， 那就失去了线程
间共享的本质属性。那么Thread Local 到底有什么作用呢？我们知道， 局部变量在
方法内各个代码块间进行传递， 而类内变量在类内方法间进行传递。复杂的线程方
法可能需要调用很多方法来实现某个功能， 这时候用什么来传递线程内变量呢？答
案就是ThreadLocal ， 它通常用于同一个线程内，跨类、跨方法传递数据。如果没有
ThreadLocal ， 那么相互之间的信息传递，势必要靠返回值和参数， 这样无形之中， 有
些类甚至有些框架会互相辑合。通过将Thr巳ad 构造方法的最后一个参数设置为true ,
可以把当前线程的变量继续往下传递给它创建的子线程，；原码如下，
public Thread(ThreadGroup group , Runnable target , String name ,
I 260
long stackSize, b。olean inheritThreadLocal s) {
this (group , target , name , stackSize , null , inheritThreadLocals );
仅供Ii＇商业用i主旦旦交流学习使用
第7 章并发与多结程
下方代码中的parent 是它的父线程
if (inheritThreadLocals && parent.inheritableThreadLocals ! = null )
this .inheritableThreadLocals =
ThreadLocal.createinheritedMap(parent . inheritableThreadLocals);
createlnheritedMap （） 其实就是调用ThreadLocalMap 的私有构造方法来产生→个
实例对象， 把父线程的不为null 的线程变量都拷贝过来－
private ThreadLocalMap(ThreadLocalMap parentMap) {
II table 立＼.足存储
Entry[) parentTable = parentMap . table ;
int len = parentTable . length ;
setThreshold (len) ;
table= new Entry[len) ;
for (Entry e : parentTable) {
if (e != null ) {
ThreadLocal<Obj ect> key = (ThreadLocal<Obj ect>) e. get() ;
if (key != null ) {
Object value= key . childValue ( e . value );
Entry c = new Entry ( key , value) ;
int h = key . threadLocalHashCode & (len - 1 );
while ( table[h) ! = null )
h = nextindex(h , len) ;
table[h) = c;
size++ ;
淘宝在很多场景下就是通过ThreadLocal 来透传全局上下文的， 比如用
ThreadLocal 来存储监控系统的某个标记位，暂且命名为trace Id 。某次请求下所有的
traceld 都是一致的，以获得可以统一解析的日志文件。但在实际开发过程中，发现
子线程里的traceld 为null ，跟主线程的trace Id 并不一致，所以这就需要刚才说到的
InheritableThreadLoca l 来解决父子线程之间共享线程变量的问题，使整个连接过程中
的traceId 一致。实现代码如下所示。
public class RequestProcessTrace {
private static final InheritableThreadLocal<FullLinkContext> FULL
LINK THREADLOCAL
261 I
仅供II＇商业用途或交流学习使用
码出高效· Java 开发手册
= new InheritableThreadLocal<>();
publ ic static FullLinkContext getContext() {
FullLinkContext fullLinkContext = FULL_LINK_THREADLOCAL.get();
if (fullLinkContext == null ) {
FULL LINK THREADLOCAL.set(new FullLinkContext()) ;
fullLinkContext = FULL LINK THREADLOCAL. get () ;
return fullLinkContext;
public static class FullLinkContext {
private String traceid;
public String getTraceid () {
if (StringUtils . isEmpty(traceid)) {
FrameW。rk . startTrace( null ， ” ） ;
traceid = FrameWork . getTraceid();
return traceid;
public v。id setTraceid(String traceid) {
this . traceid = traceid ;
使用Threa dLoca l 和Inheritabl eThreadLoca l 透传上下文时，需要注意线程间切换、
异常传输时的处理，避免在传输过程中因处理不当而导致的上下文丢失。
最后， S i mpl e D ateFormat 是线程不安全的类，定义为stati c 对象，会有数据同步
风险。通过源码可以看出， Simp l eDateFonnat 内部有一个Ca l e n dar 对象，在日期转字
符串或字符串转曰期的过程中，多线程共享时有非常高的概率产生错误， 推荐的方式
之一就是使用Th rea dLoca l ，让每个线程单独拥有这个对象。示例代码如下，
private static final ThreadLocal<DateFormat> DATE FORMAT THREADLOCAL =
new ThreadLocal<DateFormat>() {
@Override
protected DateFormat initialValue() {
return new SimpleDateFormat ( " - 1 ” );
262
第7 章并发与多线程
7 .5.3 Thread Local 副作用
为了使线程安全地共享某个变量， JDK 开出了ThreadLocal 这剂药方。但“是药
三分毒”， ThreadLocal 有一定的副作用，所以需要仔细阅读药方说明书，了解药性
和注意事项。ThreadLocal 的主要问题是会产生脏数据和内存泄漏。这两个问题通常
是在线程池的线程中使用ThreadLocal 引发的，因为线程池有线程复用和内存常驻两
个特点。
！. 脏数据
线程复用会产生脏数据。由于结程池会重用Thread 对象，那么与Thread 绑定的
类的静态属性ThreadLocal 变量也会被重用。如果在实现的线程run（）方法体中不显
式地调用remove（） 清理与线程相关的TbreadLocal 信息，那么倘若下一个结程不调用
set（）设置初始值，就可能get（）到重用的线程信息，包括ThreadLocal 所关联的线程对
象的value 值。
脏数据问题在实际故障中十分常见。比如， 用户A 下单后没有看到订单记录，
而用户B 却看到了用户A 的订单记录。通过排查发现是由于session 优化引发的。在
原来的请求过程中，用户每次请求S erver ， 都需要通过sessionld 去缓存里查询用户的
session 信息，这样做无疑增加了一次调用。因此，开发工程师决定采用某框架来缓存
每个用户对应的SecurityContext ， 它封装了session 相关信息。优化后虽然会为每个用
户新建一个session 相关的上下文，但是由于Threadlocal 没有在线程处理结束时及时
进行remove（） 清理操作， 在高并发场景下，线程池中的线程可能会读取到上→个线程
缓存的用户信息。为了便于理解，用段简要代码来模拟，如下所示·
public class DirtyDatainThreadLocal {
public static ThreadLocal<String> threadLocal
= new ThreadLocal<String>();
public static void main(String[) args) {
／／货帘亘定仨1J 吁：－的线号呈立，二主唱上－＂＇古~~主程i禹生会气气士－ ~＇绞笔哇，位复唱
ExecutorService pool= Executors . newFixedThreadPool(l );
for (int i = 0 ; i < 2 ; i++) {
Mythread thread= new Mythread() ;
pool . execute(thread);
263 I
白出高效， Java 开发手册
private static class Mythread extends Thread {
private static boolean flag = true;
@Override
public void run() {
if (flag) {
／／，冉T 气！4 ~et tu .午2λ ·有进行r8mov•
／／叫也才•I t rfi · l \f ：~＇月？.，习：~ h 吁衍。： et l号、作
threadLocal . set (this .getName() + ” . session info . ” );
flag = false ;
System . out .println( this .getName() ＋ ” ？主程是”
+ threadLocal . get()) ;
执行结果如下
Thread - 0 线程是Thread-0, sess 工on info . '
Thread -1 线程是Thread-0, session info .
2. 内存泄漏
在源码注释中提示使用static 关键字来修饰ThreadLocal。在此场景下，寄希望于
ThreadLocal 对象失去引用后， 触发弱引用机制来回收Entry 的Value 就不现实了。在
上例中，如果不进行remove（） 操作， 那么这个线程执行完成后，通过ThreadLocal 对
象持有的String 对象是不会被释放的。
以上两个问题的解决办法很简单，就是在每次用完ThreadLocal 时， 必须要及时
调用remove（）方法清理。
I 264
第8 章单元测试
祸乱生于疏忽， 单元测试先于交付。穿越暂时黑暗的时光隧道，才能
迎来系统的曙光。
守
主
J呵’
’穹
4咱「
码出高效： J ava 开发手册
计算机世界里的软件产品通常是由模块组合而成的， 模块又可以分成诸多子模块。
比如淘宝系统由搜索模块、商品模块、交易模块等组成，而交易模块又分成下单模块、
支付模块、发货模块等子模块，如此细分下去，最终的子模块是由不可再分的程序单
元组成的。对这些程序单元的测试，即称为单元测试（ Unit Testin g ，简称单测）。单
元的粒度要根据实际情况判定，可能是类、方法等，在面向对象编程中，通常认为最
小单元就是方法。单元测试的目的是在集成测试和功能测试之前对软件中的可测试单
元进行逐一检查和验证。单元测试是程序功能的基本保障， 是软件产品上线前非常重
要的环。
虽然单元测试的概念众所周知，但是能够深入理解的人却屈指可数， 精于单测之
道的工程师更是凤毛麟角。在很多人看来，单元测试是－件功不在当下的事情， 快速
完成业务功能开发才是王道， 特别是在评估工作量的时候，如果开发工程师说需要额
外时间来写单测， 并因此延长项目工期， 估计有些项目经理就接捺不住了。其实单元
测试是一件有情怀、有技术素养、有长远收益的工作， 它是保证软件质量和效率的重
要手段之一。单元测试的好处包括但不限于以下几点
l 提升软件质量
优质的单元测试可以保障开发质量和程序的鲁棒性。在大多数互联网企业中，
开发工程师在研发过程中都会频繁地执行测试用例，运行失败的单测能帮助我们快速
排查和定位问题， 使问题在被带到线上之前完成修复。正如软件工程界的一条金科玉
律一一越早发现的缺陷，其修复成本越低。一流的测试能发现未发生的故障；二流的
测试能快速定位故障的发生点三流的测试则疲于奔命，一直跟在故障后面进行功能
回归。
2 促进代码优化
单元测试是由开发工程师编写和维护的， 这会促使开发工程师不断重新审视自己
的代码， 白盒地去思考代码逻辑， 更好地对代码进行设计，甚至想方设法地优化测试
用例的执行效率。这个过程会促使我们不断地优化自己的代码，有时候这种优化的冲
动是潜意识的。
3. 提升研发效率
编写单测表面上占用了项目研发时间， 但磨刀不误砍柴工， 在后续的联调、集成、
回归测试阶段， 单元测试覆盖率高的代码通常缺陷少、问题易修复， 有助于提升项目
1266
第8 章单元测试
的整体研发效率。
4 增加重构自信
代码重构往往是牵一发而动全身的。当修改底层数据结构时，上层服务经常会受
到影响。有时候只是简单地修改一个字段名称， 就会引起系列错误。但是在有单元
测试保障的前提下， 重构代码时我们会很自然地多一分勇气，看到单元测试100 % 执
行通过的刹那充满自信和成就感。
单元测试的好处不言而喻，同时我们也要摒弃诸如单元测试是测试人员的工作，
单元测试代码不需要维护等常见误解。对于开发工程师来说， 编写并维护单元测试不
仅仅是为了保证代码的正确性， 更是一种基本素养的体现。
8.1 单元测试的基本原则
宏观上， 单元测试要符合AIR 原则；微观上， 单元测试的代码层面要符合BCDE
原则。
AIR 即空气， 单元测试亦是如此。当业务代码在线上运行时， 可能感觉不到测试
用例的存在和价值， 但在代码质量的保障上， 却是非常关键的。新增代码应该同步增
加测试用例， 修改代码逻辑时也应该同步保证测试用例成功执行。AIR 原则具体包括·
• A : Automatic （自动化）
• I : Ind ependent （独立性）
• R : Repeatable （可重复）
单元测试应该是全自动执行的。测试用例通常会被频繁地触发执行， 执行过程必
须完全自动化才有意义。如果单元测试的输出结果需要人工介入检查，那么它一定是
不合格的。单元测试中不允许使用System.out 来进行人工验证，而必须使用断言来验证。
为了保证单元测试稳定可靠且便于维护， 需要保证其独立性。用例之间不允许互
相调用， 也不允许出现执行次序的先后依赖。如下警示代码所示， testMethod2 需要
调用testMe thod I 。在执行t estM ethod2 时会重复执行验证testM ethod I ，导致运行效率
降低。更严重的是， t estM e thod I 的验证失败会影响testMethod2 的执行。
@Test
public void testMethodl() {
267
码出高效. Java 开发手册
@Test
public void testMethod2() {
testMethodl ();
在主流测试框架中， JU nit 的用例执行顺序是无序的，而TestNG 支持测试用例的
顺序执行（默认测试类内部各测试用例是按字典序升序执行的，也可以通过泪也或
注解priority 的方式来配置执行顺序）。
单元测试是可以重复执行的， 不能受到外界环境的影响。比如， 单元测试通常会
被放到持续集成中，每次有代码提交时单元测试都会被触发执行。如果单测对外部环
境（ 网络、服务、中间件等）有依赖，贝IJ 很容易导致持续集成机制的不可用。
编写单元测试时要保证测试粒度足够小， 这样有助于精确定位问题，单元测试
用例默认是方法级别的。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试
需要覆盖的范围。编写单元测试用例时，为了保证被测模块的交付质量，需要符合
BCD E 原则。
• B: Border ， 边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。
• C: Correct ， 正确的输入， 并得到预期的结果。
• D: Des i gn ， 与设计文档相结合，来编写单元测试。
• E : Error ， 单元测试的目标是证明程序有错，而不是程序无错。为了发现代
码中潜在的错误， 我们需要在编写测试用例时有一些强制的错误输入（如非
法数据、异常流程、非业务允许输入等）来得到预期的错误结果。
由于单元测试只是系统集成测试前的小模块测试，有些因素往往是不具备的，因
此需要进行M ock ， 例如，
( l ）功能因素。比如被测试方法内部调用的功能不可用。
( 2 ） 时间因素。比如双十一还没有到来3 与此时间相关的功能点。
( 3 ）环境因素。政策环境，如支付宝政策类新功能，多端环境， 如PC 、手机等。
( .+ ）数据因素。线下数据样本过小，难以覆盖各种线上真实场景。
( 5 ） 其他因素。为了简化测试编写， 开发者也可以将一些复杂的依赖采用Mock
方式实现。
1268
仅供＇II二商业用途或交流学习使用
第8 章单元测试
最简单的Mock 方式是硬编码，更为优雅的方式是使用配置文件，最佳的方式是
使用相应的Mock 框架， 例如JMockit 、EasyMock 、JMock 等。Mock 的本质是让我
们写出更加稳定的单元测试， 隔离上述因素对单元测试的影响， 使结果变得可预测，
做到真正的“单元”测试。
8.2 单元测试覆盖率
单元测试是种白盒测试， 测试者依据程序的内部结构来实现测试代码。单测覆
盖率是指业务代码被单测测试的比例和程度，它是衡量单元测试好坏的一个很重要的
指标，各类覆盖率指标从粗到细、从弱到强排歹lj如下。
I. 粗粒度的覆盖
粗粒度的覆盖包括类覆盖和方法覆盖两种。类覆盖是指类中只要有方法或变量被
测试用例调用或执行歪lj ， 那么就说这个类被测试覆盖了。方法覆盖同理， 只要在测试
用例执行过程中，某个方法被调用了，贝lj 无论执行了该方法中的多少行代码，都可以
认为该方法被覆盖了。从实际测试场景来看， 无论是以类覆盖率还是方法覆盖率来衡
量测试覆盖范围，其粒度都太粗了。以阿里研发场景为例， 大多数开发工程师都能做
到类覆盖率和方法覆盖率达到100% ，但这并不能说明测试用例已经写得很好，因为
这个标准是远远不够的。
2 细粒度的覆盖
细粒度的覆盖包括以下几种。
( I ）行覆盖（ Line Coverage )
行覆盖也称为语句覆盖，用来度量可执行的语旬是否被执行到。行覆盖率的计算
公式的分子是执行到的语旬行数， 分母是总的可执行语句行数。示例代码如下，
public class CoverageSampleMethods {
public Boolean testMethod(int a , int b , int c) {
boolean resul t = false ;
if <a == 1 & & b == 2 I I c = = 3 l <
result = true ;
return result ;
269 [
i旦iJtll0商业用途成交流学习使用
码出高效： Java 开发手册
以上方法中有5 行可执行语旬和3 个人参，针对此方法编写测试用例如下
@Test
@DisplayName (” line coverage sample t e st ” )
void testL工neCoverageSample() {
CoverageSampleMethods coverageSampleMethods = new
CoverageSampleMethods();
Assertions.assertTrue(coverageSampleMethods.testMethod( l , 2 , 0 ));
以上测试用例的行覆盖率是100% ，但是在执行过程中c==3 的条件判断根本没
有被执行到， a!=I 并且c!=3 的情况难道不应该测试一下吗？由此可见，行覆盖的覆
盖强度并不高，但由于容易计算，因此在主流的覆盖率工具中，它依然是一个十分常
见的参考指标。
{ 2 ）分支覆盖｛ Branch Coverage )
分支覆盖也称为判定覆盖，用来度量程序中每一个判定分支是否都被执行到。分
支覆盖率的计算公式中的分子是代码中被执行到的分支数，分母是代码中所有分支的
总数。譬如前面例子中，（ a == I && b == 2 II c = 3 ） 整个条件为一个判定， 测试数据
应至少保证此判定为真和为假的情况都被覆盖到。分支覆盖容易与下面要说的条件判
定覆盖混淆，因此我们先介绍条件判定覆盖的定义，然后再对比介绍两者的区别。
( 3 ）条件判定农盖（ Condition Decision Coverage )
条件判定覆盖要求设计足够的测试用例，能够让判定中每个条件的所有可能情况
至少被执行一次， 同时每个判定本身的所有可能结果也至少执行一次。例如（a 二l
&&b 二2 11 c 二3 ） 这个判定中包含了3 种条件， ~D a== I 、b ==2 和c =3 。为了便
于理解，下面我们仍使用行覆盖率中的tes tMethod 方法作为被测方法，测试用例如下，
@ParameterizedTest
@DisplayName ( ” Condition Decision coverage sample test result true ” )
@CsvSource({
})
” 。， 2 , 3 ” ,
” 1 ， 。， 3 ” ，
void testConditionDecisionCoverageTrue (int a , int b , int c) {
CoverageSampleMethods coverageSampleMethods = new
CoverageSampleMethods() ;
Assertions . assertTrue(c 。verageSampleMethods.testMethod(a, b, c)) ;
270
仅供非商业用途或交流学习使用
第8 章单元测试
自DisplayName （ ” Condition Decisior coverage sample test result false ” )
void testCondi tionDecisionCoverageFalse () {
CoverageSampleMethods coverageSampleMethods = new
CoverageSampleMethods() ;
Assertions . assertTrue ( coverageSa mple Methods.testMethod ( O ， 。， 。））；
通过＠ParameterizedTest ， 我们可以定义个参数化测试，＠CsvSource 注解使
得我们可以通过定义一个String 数组来定义多次运行测试时的参数列表，而每一个
String 值通过逗号分隔后的结果，就是每一次测试运行时的实际参数值。我们通过两
个测试用例分别测试判定结果为true 和false 这两种情况， 第一个测试用例testConditi
onDecisionCoverageTrue 会运行两次， a、b 、c 这3 个参数的值分别为0 , 2 、3 和1 、0 、3;
第二个测试用例testConditionDecisionCoverageFalse 的3 个参数的值都为0。在被测方
法testMethod 中，有个判定（ a== 1 && b == 2 11 c == 3 l 包含了三个条件（ a== 1 、
b == 2 、c== 3 ），判定的结果显而易见有两种（仕町、false ）， 我们已经都覆盖到了。
另外，我们设计的测试用例，也使得上述三个条件真和假的结果都取到了。因此，这
个测试用例满足了条件判定覆盖。
反过来再看下分支覆盖，分支覆盖只要求覆盖分支所有可能的结果， 可以看出
它是条件判定覆盖的一个子集。
( 4 ）条伴组合覆盖（ Multiple Condition Cove1吨e )
条件组合覆盖是指判定中所有条件的各种组合情况都出现至少一次。还是以
(a == 1 && b == 2 11 c == 3）这个判定为例，我们在介绍条件判定覆盖时，忽略了如
a==l 、b==2 、c==3 等诸多情况。针对被测方法testMethod ，满足条件组合覆盖的一
个测试用例如下，
@ParameterizedTest
@DisplayName （ ” Mult 工ple Condition Coverage sample test result true ” )
@CsvSource ( {
” l ' 2, 3 ” F
” 1, 2, 0" '
"1, 0' 3” ,
” 。＇ 2 , 3 " '
” 。， 0' 3 " '
})
void testMultipleConditionCoverageSampleTrue(int a, int b , int c) {
CoverageSampleMethods coverageSampleMethods
= new CoverageSampleMethods();
271
仅供＃商业用途或交流学习使用
码出高效Java 开发手册
Assertions . assertTrue(coverageSampleMethods . testMethod(a , b, c)) ;
@ParameterizedTest
@DisplayName( "Multiple Condit 工on Coverage sample test result false " )
@CsvSource({
})
” 1 ， 。， 。” ，
” 。， 。， 。” ，
” 0 , 2 ， 。” ，
void testMultipleConditionCoverageSampleFalse(int a , int b , int c) {
CoverageSampleMethods coverageSampleMethods
= new CoverageSampleMethods();
Assertions.assertFalse(coverageSampleMethods . testMethod(a , b , c)) ;
这组测试用例同时满足了（ a== !, b==2, c==3 ）为（ true, true, true ）、（ true,
true, false ）、（ true, false, true ）、（ true, false, false ）、（ false, true, true ）、（ false,
true, false ）、（ false, false, true ）、（ false, false , false ）这8 种情况。对于一个
包含了n 个条件的判定， 至少需要7 个测试用例才可以。虽然这种覆盖足够严谨，
但无疑给编写测试用例增加了指数级的工作量。
( 5 ）路伊覆盖（ Path Cove1吨e )
路径覆盖要求能够测试到程序中所有可能的路径。在testMethod 方法中，可能的
路径有① a= l , b二2 ② a== l 力！ ＝2,c==3 ③ a= l ,b!=2 ,c! =3 ④ a! = l ,c二3 ⑤ a !=l ,c! =3
这5 种。当存在“｜｜”时， 如果第一个条件已经为true ， 贝lj不再计算后边表达式的值1
而当存在“＆＆ ” 时，如果第一个条件已经为false ， 贝lj 同样不再计算后边表达式的值。
满足路径覆盖的测试用例如下
@ParameterizedTest
自DisplayName （ ” Path coverage sample test result true " )
@CsvSource ( {
})
" l , 2 ， 。” ，
” 1 , 0 , 3” ,
” 。， 0 , 3” ,
void testPathCoverageSampleTrue(int a, int b, int c) {
CoverageSampleMethods coverageSampleMethods
= new CoverageSampleMethods( );
Assert 工ons . assertTrue ( coverageSampleMethods . testMethod(a, b , c)) ;
I 272
仅供＇II二商业用途或交流学习使用
@ParameterizedTest
@DisplayName ( ” Path coverage sample test result false ” )
@CsvSource({
} )
” l ，。， 。” ，
” 。， 0 , J ” ,
v。id testPathCoverageSampleFalse(int a , int b, int c) {
CoverageSampleMethods coverageSampleMethods
第8 章单元测试
= new CoverageSampleMethods ();
Assertions . assertFalse(coverageSampleMethods . testMethod2(a , b , c)) ;
8.3 单元测试编写
单元测试编写是开发工程师的日常工作之一， 利用好各种测试框架并掌握好单元
测试编写技巧， 往往可以达到事半功倍的效果。本节主要介绍如何编写JUnit 测试用例。
我们先简要了解一下JU nit 单元测试框架。
8.3.1 JUnit 单元测试框架
Java 语言的单元测试框架相对统－ ， JUnit 和TestNG 几乎始终处于市场前两位。
其中JUnit 以较长的发展历史和源源不断的功能演进， 得到了大多数用户的青睐，也
是阿里内部目前使用最多的单元测试框架。
JU nit 项目的起源可以追溯到1997 年。两位参加“面向对象程序系统语言
和应用大会”（ Conf1巳rence for Object-Orient巳d Programming Systems, Languages &
Applications ）的极客开发者Kent Beck 和Erich Gamma ， 在从瑞士苏黎世飞往美国亚
特兰大的飞机上， 为了打发长途飞行的无聊时间，他们聊起了对当时Java 测试过程
中缺乏成熟工具的无奈，然后决定起设计一款更好用的测试框架， 于是采用结对编
程的方式在飞机上完成了JU nit 雏形，以及世界上第一个JUnit 单元测试用例。经过
20 余年的发展和几次重大版本的跃迁， JUnit 于2017 年9 月正式发布了5.0 稳定版本。
JUnit5 对JDK8 及以上版本有了更好的支持（如增加了对l ambda 表达式的支持），
并且加入了更多的测试形式，如重复测试、参数化测试等。因此本书的测试用例会使
用JUnit5 采编写，部分写法如果在JUn it4 中不兼窑，则会提前说明。
JUnit5.x 由以下三个主要模块组成。
• JU nit Platform· 用于在NM 上启动测试框架， 统一命令行、Gradle 和Maven
273
仅供＃商业用途或交流学习使用
码出高效： Java 开发手册
等方式执行测试的人口。
• JU nit Jupiter: 包含JUnit5.x 全新的编程模型和扩展机制。
• JU nit Vintage ： 用于在新的框架中兼容运行JUnit3.x 和JUnit4.x 的测试用例。
为了便于开发者将注意力放在测试编写上， 即不必关心测试的执行流程和结果展
示， JUnit 提供了一些辅助测试的注解， 常用的测试注解说明如表8-1 所示。
表8-1 测试注解说明
注解释义
注明一个方法是测试方法， JU nit 框架会在测试阶段自动找出所有使用该注解
@Test 标明的测试方法并运行。需要注意的是，在JU nitS 版本中，取消了该注解的
timeout 参数的支持
@TestFactory 注明一个方法是基于数据驱动的动态测试数据源
@Parameterize<lTest
注明一个方法是测试方法，这一点同＠Test 注1仰作用一样。此外， 该注解还可
以让一个测试方法使用不同的人参运行多次
@RepeatedTest 从字面意思就可以看出，这个注释可以让测试方法自定义重复运行次数
与JUnit4 中的＠Be fore 类似，可以在每一个测试方法运行前， 都运行一个指
@BeforeEach 定的方法。在JUnit.5 中， 除了运行＠Test 注解的方法，还额外支持运行＠
Paramet eri zedTest 和＠R epeatedTest. 注解的方法
与JU nit4 中的＠After 类似， 可以在每一个测试方法运行后，都运行一个指
@After Each 定的方法。在JU nitS 中，除了运行＠Test 注解的方法，还额外支持运行＠
Para meteri zedTest 和＠RepeatedTest 注解的方法
@BeforeAll
与JU n i t4 中的＠BeforeCl ass 类似，可以在每一个测试类运行前，都运行一个指
定的方法
@AfterAll
与JUnit4 中的＠Aft.erC lass 类似，可以在每一个测试类运行后， 都运行一个指
定的方法
@Disabled 与JUnit4 中的＠I gnore 类似，注明一个测试的类或方法不再运行
@Nested 为测试添加嵌套层级，以便组织用例结构
@Tag 为测试类或方法添加标签，以便有选择性地执行
1274
仅供＇II二商业用途或交流学习使用
下面是个典型的JU nit 测试类结构
／／尺吐一？、：l 气飞J「，，§＇＜王侈J 川在w气
@DisplayName （ ” ＇.~ ＇甲器←兰型，l’；It式” ）
public class TicketSellerTest {
定义一马’实’
private TicketSeller ticketSeller ;
/ 吃x ·＇：.穹'i·-[;i式二楚千峰、可l t 句也＇1 i王俨
飞7 旦抖、局和外舌P 资与（包括，~·， t走呼）向叮廷和i!J 始化
@Bef oreAll
public static void init() {
／／专义在等A ’！试二是吃咦后.ti;_ Ff 的投i在
哇，；句后担岛和外部斗派的每放f!l 销咬
@After All
public static void cleanup() {
／／定义在每个川试咱例开始前执行钩操作
－重f 包＂＇戎带和i三ff 飞吨的－~备
@BeforeEach
public v。id create() {
this . ticketSeller =new TicketSeller() ;
／／建义在每卜，p 试用！到宅可飞后校行的战作
／边吊也才；i注f~＂、埃f句治理
@Af terEach
public void destroy() {
di式审｝71）、也t 车祟jt 出后余柔厄才走，式少
@Test
@DisplayName （ ” 售票后余翼应减少” ）
public void shouldReduceinventoryWhenTicketSoldOut() {
ticketSeller . setinventory( lO );
第8 章单元测试
275
仅供＃商业用途或交流学习使用
码出高效· Java 开发手册
ticketSeller.sell( l );
assertThat(ticketSeller . getinventory()) . isEqualTo( 9);
I I ;c::j i式唱例噜旦与余累不足时应l~ 根错
@Test
@DisplayNarne （ ” 余在不足1、Hfl. 错＂ ）
public void shouldThrowExceptionWhenNoEnoughinventory()
ticketSeller . setinventory( O);
assertThatExcept 工onOfType(TicketException . class )
. isThrownBy ( () -> { ticketSeller . sell ( 1 ) ; ) )
withMessageContain 工ng （ ” all tickeζ sold 古在t ” ）
.withNoCause();
II Disabled 注译将禁屑，划试！有何
／／访测试明例会出现在最终的报告中． 但不会被执行
@Disabled
@Test
@DisplayNarne （ ” 苦了？吕票时余罢l是增加＂ ）
public void shouldincreaseinventoryWhenTicketRefund()
t 工cketSeller.setinventory( lO );
ticketSeller.refund( l );
assert That (ticketSeller. get Inventory()) . isEqualTo ( 11 ) ;
需要注意的是，＠DisplayName 注解仅仅对于采用IDE 或图形化方式展示测试运
行结果的场景有效，如图8 - 1 所示。
事↓↓毛主丰
v ( Test Results
’ CD 售票器类型测试
8 有退票时余票应增加
余票不足应报错
① 售票后余票应减少
图8 1 测试场景
.. »
71 ms
但对于使用Maven 或Gradle 等命令行方式运行单元测试的情况，该注解中的内
容会被忽略，例如单元测试出错时，实际展示结果如下·
1276
仅供Ii＇商业用i主旦旦交流学习使用
第8 章单元测试
[ERROR] Failures :
[ERROR] ExchangeRateConverterTest.shouldReduceinventoryWhenT 工cketSoldO
ut : 29
Expecting: < ” failed ” >
to contain: < ” succes s ” >
当测试用例较多时，为了更好地组织测试的结构，推荐使用JU n i t 的＠Nested 注
解来表达有层次关系的测试用例：
@DisplayName （ ” 变易报与；＂＇.， i式” ）
public class TransactionServiceTest {
@Nested
@DisplayName （ ” F 户.. ':I; ~： iii ＇ ” ）
class UserTransactionTest {
@Nested
@DisplayName ( ” ,',lf'f911 ” )
class PositiveCase {
@Test
@DisplayName ( ” 手T 斗过” ）
public void shouldPassCheckWhenParameterValid() {
@Nested
@DisplayName （ ” υ ‘例” ）
class NegativeCase {
@Nested
@DisplayName ( ” v 0' '; '\ ” )
class CompanyTransactionTest {
JU nit 没有限制嵌套的层级数，除非必要， 般不建议使用超过3 级的嵌套用例，
过于复杂的测试层级结构会增加开发者理解用例关系的难度。
分组测试和数据驱动测试也是单元测试中十分实用的技巧。其中，分组测试能够
实现测试在运行频率维度上的分层，例如，将所有单元测试用例分为“执行很快且很
277
码出高效· Java 开发手册
重要”的冒烟测试用例、“执行很慢但同样比较重要”的曰常测试用例，以及“ 数量
很多但不太重要”的回归测试用例。然后在不同的场景下选择性地执行相应的测试用
例。使用JUnit 的＠Tag 注解可以很容易地实现这种区分。示例代码如下
@DisplayName （ ” 售2霎衷于ι 用功式” ）
public class TicketSellerTest {
@Test
@Tag (” fast " )
自D工spla yName （ ” 售'If,, ）苦余禁应减少” ）
public void shouldReduceinventoryWhenTicketSoldOut() {
@Test
@Tag (” slow” )
自D工splayName （ ” 一次哇巧与实20 张车票” ）
public v。id shouldSuccessWhenBuy20TicketsOnce() {
通过标签选择执行的用例类型， 在Maven 中可以通过配置maven-surefire-pI ugi n
插件来实现·
<build>
<plug ins>
<plug in>
<artifactid>maven- surefire- plugin</artifactid>
<version>2 . 22 . 0</version>
<configuration>
<properties>
<includeTags >fast </includeTags>
<excludeTags>s low</excludeTags>
</properties>
</configuration>
</plugin>
</plug ins>
</build>
在Gradle 中可以通过JUnit 专用的junitPlatform 配置来实现
junitPlatform {
filters {
I 278
第8 章单元测试
engines {
include ’ junit-jupiter ’ , ’ junit-vintage ’
tags {
include ’ fast ’
exclude ’ slow '
数据驱动测试适用于计算密集型的算法单元，这些功能单元内部逻辑复杂，对于
不同的输入会得到截然不同的输出。倘若使用传统的测试用例写法，需要重复编写大
量模板式的数据准备和方法调用代码，以便覆盖各种情况的测试场景。而使用JU nit
的＠ TestFactory 注解能将数据的输入和输出与测试逻辑分开，只需编写段测试代码，
就能一次性对各种类型的输入和输出结果进行验证。示例代码如下。
@DisplayName （ ” 售票器类型测试” ）
public class ExchangeRateConverterTest {
@TestFactory
@DisplayName （ ” 时间售票检查” ）
Stream<DynamicTest> oddNumberDynam工cTestWithStream() {
ticketSeller . setCloseTime(LocalTime.of( l2 , 20 , 25 , 0 ));
return Stream.of(
Lists.list （ ” 提前购票E ’ ， LocalT 工me.of( l2 , 20 , 24 , 0 ) , true ),
Lists.list （ ” 准点购买” ， Loca1Time.of( l2 , 20 , 25 , 0 ) , true ),
Lists . list （ ” 晚点购票” ， Loca1Time.of( l2 , 20 , 26 , 0 ), false )
.map(data -> DynamicTest.dynamicTest((Str 工ng)data.get( O ),
() - > assertThat(ticketSeller . cloudSellAt(data . get(l ))) .
isEqualTo(data.get(2 ))));
8.3.2 命名
通常来说，单元测试类的定义与被测类一对应，放置于与被测类相同的包
路径下，并以被测类名称加上Test 命名。例如， DemoService 的测试类应该命名为
DemoServiceTest ，其目录结构示例如下
279
码出高效· Java 开发手册
src •- main
｜」一－ Java
| 」一一com
｜」一－ alibaba
｜」一－ demo
」－ DemoServ工ce . java
」一－ test
L一一一一- Java
L一一→ demo
」一一DemoServiceTest.java
单元测试代码必须写在工程目录src/tes叹j ava 下，不允许写在业务代码目录下，
因为主流Java 测试框架如JUn it, TestNG 测试代码都是默认放在src/test/java 下的，
测试资源文件则放在src/test/resources 下，这样有利于代码目录标准化。统一约定代
码存放结构带来的好处是，当修改别人的工程时，也能有种修改自己工程的感觉，
能清楚知道哪些代码在什么目录下。
如果说规范测试类的目录和命名是为了更好地管理代码结构和获得IDE 的增强辅
助，那么规范单元测试的方法名称则是为了提升测试质量。良好的方法命名能够让开
发者在测试发生错误时，快速了解出现问题的位置和影响。试比较以下两个错误信息。
示例一
> Task :test
com.al 工baba.demo . DemoServiceTest > test83 FAILED
java.lang . AssertionError at DemoServ 工ceTest . java: 177
200 tests completed, 1 failed
示例二I
> Task : test
com . alibaba . demo . DemoServiceTest > shouldSuccessWhenDecodeUserToken
FAILED
java.lang . AssertionError at DemoServiceTest . java : l77
200 tests completed , 1 failed
1280
第8 章单元测试
两者差异仅仅在于出错提示中的方法名称。显然， 示例一中的名称test83
无法让开发者在众多用例中迅速回忆起它究竟测试了什么， 而示例二中的名称
shou ldS uccess WhenDecode U se rToke n 则包含了足够多的信息， 即使这个测试不是自己
写的，也能猜测到是最近的修改把用户令牌解码的功能搞坏了。
主流的Java 单元测试方法命名规范有两种种是传统的以＂ test ”开头，然后
加待测场景和期待结果的命名方式，例如、stDecodeUserTok enSuccess ” ；另一种则
是更易于阅读的＂ should . .. Wh e n ”结构， 它类似于行为测试的飞iven ... When ... Then "
叙述， 只是将Then 部分的结果前置了， 由于Given 申的前提通常已在测试准备的＠
BeforeEach 或＠BeforeAll 方法中体现， 因此不必在各个测试方法名中重复， 例如
飞houldSuccess WhenDecodeU s erToke n ” 。
在命名时，应当在不影响表意的情况下适当精简描述语旬长度（通常控制在5 个
单词内），例如， 将＂ shou Id Return Ti cketlnfomati onlnc I ud i ngOrderN um berTo User When
AIID atais ValidAndTok en I sN o tEx pir e d ”缩短为“ sho u I dGetTi cketl nfo WhenAI I Parameters
Va lid ， ，。过长的命名容易产生信息量过载， 反而给阅读和理解带来负担。
8.3.3 断言与假设
当定义好了需要运行的测试方法后， 下一步则是关注测试方法的细节处理， 这就
离不开断言（ assert ）和假设（ a ssume ) 断言封装好了常用的判断逻辑，当不满足
条件时，该测试用例会被认定为测试失败，假设与断言类似， 只不过当条件不满足时，
测试会直接退出而不是认定为测试失败， 最终记录的状态是跳过。断言和假设是单元
测试中最重要的部分，各种单元测试框架均提供了丰富的方法。以JUnit 5 . x 为例，它
提供了一系列经典的断言和假设方法。
常用的断言被封装在org.junit.jupiter.api.Assertions 类中， 均为静态方法， 表8-2
列举了一些常用的断言相关方法。
表8-2 常用的断言相关方法
方法释义
fail 断育测试失败
assertTrue/asse 11False 吕fr 育条件为真或为假
assert Null/assertNo tNull 断言指定值为null 或非null
asse rtEqu als/asse rt NotEqu als 断育指定两个值相等或不相等， 对于基本数据类型， 使用值
比较；对于对象，使用equ a l s 方法比较
asse rtA rra y Equal s 1i!Jr 育数组元素全部相等
281
ti~出高效J ava 开发手册
续表
方法释义
assertSame/assertNotSame 断言指定两个对象是否为同一个对象
assettThrows/assertDoesNotThrow 断言是存抛出了一个特定类型的异常
assertTimeout/assertTimeoutPreempti ve ly 断再是否执行超时，区别在于测试程序是否在同一个线程内
执行
assertl terab I eEqual s 断言迭代器中的元素全部相等
assertLi nesMatch 断言字符串列表元素全部正则匹配
assertAll 断言多个条件同时满足
丰目较于断言，假设提供的静态方法更加简单，被封装在org.junit.jupiter.api.
Assumptions 类中， 同样为静态方法，如表8 -3 所示。
方法
assume True
assumeFalse
表8-3 假设判定
释义
先判断给定的条件为真或假，再决定是否继续接下来的测试
相对于假设，断言更为重要。这些断言方法中的大多数从JUnit 的早期版本就已
经存在，并且在最新的JUni t 5. x 版本中依然保持着很好的兼容性。当断言中指定的条
件不满足时， 测试用例就会被标记为失败。
对于断言的选择，优先采用更精确的断言，因为它们通常提供了更友好的
结果输出格式（包括预期值和实际值），例如asse此Equal s( l 00, result） 语句优于
assertTrue(lOO == result） 语旬。对于非相等情况的判定，比如大于、小于或者更复杂
的情况， 贝lj 可以使用assertTrue 或assertFal se 表达， 例如assertTrue(result > 0）。对于
特别复杂的条件判定， 直接使用任何一种断言方法都不容易表达时，则可以使用Java
语旬自行构造条件， 然后在不符合预期的情况下直接使用fail 断言方法将测试标记为
失败。
另外值得强调的是，对于所有两参数的断言方法，例如assertEquals 或
assertSame ， 第二个参数是预期的结果值， 第二个参数才是实际的结果值。例如
assertEquals (O, transactio 日Maker.increase(lO) .reduce(lO))
假如测试结果错误，将会在测试报告中产生如下内容I
1282
第8 章单元测试
org.opentest4j.AssertionFailedError:
Expected : 0
Actual : 20
倘若将参数的位置写反， 贝lj 生成报告的预期值与实际值位置也会颠倒， 从而给阅
读者带来困扰。
assertTimeo ut 和assertTim eoutPr巳emptivel y 断言的差异在于，前者会在操作超时
后继续执行， 并在最终的测试报告中记录操作的实际执行时间；后者在到达指定时间
后立即结束， 在最终的报告中只体现出操作超时， 但不包含实际执行的耗时。例如，
使用ass巳rtTimeout 断言的错误报告a
o rg . opentes t 4j.Assert 工o nFail e dError : execution exceeded timeout of
1000 ms by 5003 ms
使用assertTimeoutPreemptively 断言的错误报告·
org . opentest4j .AssertionFailedError: execution timed out after 1000 ms
断言负责验证逻辑， 以及数据的合法性和完整性，所以有一种说法“ 在单元测
试方法中没有断言就不是完整的测试’！。而在实际开发过程中， 仅使用JUnit 的断言
往往不能满足需求要么是被局限在JUnit 仅有的几种断言中， 对于不支持的断言就
不再写额外的判断逻辑1 要么花费很大的精力， 对要判断的条件经过一系列改造后，
再使用JUnit 现有的断言。有没有第三种选择？答案是， 有的｜
Ass巳rt] 的最大特点是流式断言（ Fluent Assertions ） ， 与Builder Chain 模式或
Java 8 的stream&filter 写法类似。它允许个目标对象通过各种Fluent Assert API 的
连接判断， 进行多次断言， 并且对IDE 更友好。但是As sert] 的assertThat 的处理方
法和之前有些不同，它利用Java 的泛型， 同时增加了目标类型对应的XxxxAssert
类， 签名为“ public static AbstractCharSequenceAssert<?, String> assertThat(String
actual ）”， 而JUnit 中的“public static void assertThat（）” 是void 返回， 其中，
AbstractCharSequenceAssert 是针对String 对象的， 这样不同的类型有不同的断言方法，
如String 和Date 就有不一样的断言方法。
如果是我们自定义的JavaBean 该如何判断， 例如我们常见的Account 对象， 如
何传给asse此That ， 然后进行断言判断？ AssertJ 通过AssertJ assertions generator 来生成
对应的XxxAssert 类，然后辅助我们对模板JavaBean 对象进行断言API 判断。AssertJ
assertions generator 有相应的Maven 和Gradle Plugin ， 生成这样的代码非常容易， 所
以很容易实现对自定义JavaBean 对象的判断需求。此外， Assert] 还添加了常用的
283 1
码出高效： Java 开发手册
扩展，如DB assertions, Guava assertions 等，以方便我们使用。例如，典型的DB
assertions ，无论你使用哪种框架（ MyBatis 、Hibernate 等），在执行完数据库操作后，
就可以使用DB assertions 对数据库中的数据进行断言，非常适合单元测试。
下面通过一个例子，来一起认识一下强大的AssertJ 。首先使用JUnit 的经典断言
实现一段测试，
／／｛电嘀JUnit 均断言
public class JUnitSampleTest {
@Test
284
public v。id testUsingJunitAssertThat() {
／／字符串判断
String s = ” abed<' ” ;
Assertio 口s.assertTrue(s . startsWith （ ” ab ” ） ) ;
Assertions . assertTrue(s.endsWith ( ” de " ));
Assertions.assertEquals( S, s .length()) ;
／／鼓字判珩
工ηteger i = 50;
Assertions . assertTrue(i > 0 );
Assertions . assertTrue(i < 100 );
／／日期判断
Date datel = new Date() ;
Date date2 = new Date (datel.getTime () + 1 0 );
Date date3 = new Date(datel.getT i me() - 100 );
Assertio 口s.assertTrue(datel.before(date2)) ;
Assertio 口s.assertTrue(datel.after(date3)) ;
II L 工st 判断
List<String> list = Arrays . asList( " a ” , ” b ” , ” c ” , ” d ” ) ;
Assertions . assertEquals( " a ” , l ist.get( O));
Assertions. assertEquals ( 4 , list. size ());
Assertions . assertEquals ( ” d ” , list . get(list.size() 1 )) ;
II Map 判断
Map<String , Object> map= new HashMap<>();
map . put( " A” , 1 );
map . put ( ” B ” , 2 ) ;
map . put ( ” C ” , 3 );
Set<String> set= map . keySet() ;
Assertions . assertEquals( 3 , map . size{));
Assertions . assertTrue(set.conta 工nsAll
第8 章单元测试
(Arrays.asList( " A” , ” B” , ” C ” ))) ;
下面，我们使用Assert｝采完成同样的断言·
／／使用AssertJ 的世Jr \'f
public class AssertJSarnpleTest {
@Test
public void testUsingAssertJ() {
／／子符串非1Jh
String s ＝ ” abc• 丁jp ” ；
Assertions . assertThat(s) .as （ ” 字符卒叮l 』： 判I 7 电皮又度’＇ ）
.startsWith (” ab ” ) . endsWi th ( ” de ” ) . has Size ( 5 );
I I ~~ 正在1J 山「
Integer i = 50 ;
Assertions . assertThat （工） . as （ ” ~x j 止1J .:h : 价字六小l 七才吃” ）
.isGreaterThan( O) .isLessThan( lOO );
／／日出事1Jrili
Date datel = new Date();
Date date2 = new Date(datel . getTirne() + 100 );
Date date3 = new Date(datel . getTirne() - :OO );
Assertions . assertThat(datel) . as （ ” 日均叫咐： 尸J!IJ 大小i七校” ）
.isBefore(date2) . isAfter(date3) ;
11 List '1'1j i如
L 工st<Str 工口g> list= Arrays . asList (” a ” , ” b ” , " c ” , ” d ” ) ;
Assertions . assertThat(list)
.as （ ” List 的叫由r ： 前、电元表及氏度’＇ ）. startsWith ( " a ” )
.endsWith ( ” d ” ) .hasSize ( 4 ) ;
I I Map ¥1] ,iF
Map<String, Object> map = new HashMap<> ();
map . put (” A” , 1 );
map . put (” B ” , 2 );
map.put (” C ” , 3 );
Assert 工ons. assert That (map) . as （ ” Map 的~111昕： 长反及I\ey i直” ）
. hasSize( 3 ) . containsKeys (” A'’ , ” B" , ” C” );
不难发现， AssertJ 的断言代码要清爽许多，流式断言充分利用了Java 8 之后的
匿名方法和S tream 类型的特点，很好地对JU nit 断言方法进行了补充。
285
第9 章代码规约
$ 同轨、书同文。手册源起，不忘初心，伯牙子期，琴瑟共鸣。
1｝~ · ~严
第9 章代码规约
9.1 代码规约的意义
别人都说程序员是“搬砖” 的码农，但我们知道自己是追求个性的艺术家。也许
我们不会过多在意自己的外表和穿着，但在不羁的外表下，骨子里追求着代码的美、
系统的美、设计的美，代码规约其实就是对程序美的一个定义。但是这种美离程序员
的生活有些遥远，尽管代码规约的价值在业内有着广泛的共识，然而在现实中执行得
并不是很好。程序员曾经最引以为豪的代码，因为代码规约的缺失严重制约了相互之
间的高效协同，频繁的系统重构和心惊胆战的维护似乎成了工作的主旋律，如何走出
这种怪圈呢？众所周知，互联网公司的效能是企业的核心竞争力，体现在开发领域上，
其实就是沟通效率和研发效率。沟通效率的重要性可以从程序员三大“编程理念之争”
（如图弘1 所示）说起
·缩进采用空格键3 还是Tab 键。
• if 单语句需要大括号，还是不需要大括号。
·左大括号不换行，还是单独另起一行。
fi fY> 生因tafY> fi®®
if .II自语句不.要大括号if 单语句需要大括号
图9-1 编程理念之争
其中， i f 单语句是否需要大括号是争论不休的话题。相对来说，写过格式缩进类
编程语言（比如Python ）的开发工程师，更加习惯于不加大括号。因为单语旬的写法，
继续添加其他语句时，窑易引起视觉上的错误判断导致程序逻辑问题，所以我们提倡
287
码出高效Java 开发手册
iC for 、while 单语句必须加大括号。此外，不加大括号还可能会导致作用域问题
public class IfSingleStatementTest {
public static void main(String[) args) {
11 l'i, T 工句均销i.｝报给： declaration not allowed here
if (true ) int x;
for (; ; ) int y ;
while (true ) int z;
有程序员想当然地认为编译会通过，最多出现警告提示： variable is never used 。
实际上，编译报错为declaration not allowed here。单语旬在没有加大括号的情况
下，声明的变量不可能再被使用，编译器认为没有任何意义，参考官方说明Every
declaration that introduces a name has a scope, in which they can be used.
这些理念之争的本质就是程序员多年代码习惯生了茧，不愿意对不样的代码风
格妥协。很多代码风恪客观上没有对与错，但是一致性很重要，可读性很重要，团队
沟通效率很重要。帕金森琐碎定律是指团队成员往往会把过多的精力花费在些琐碎
的争论上， 而真正重要的决议反而可以轻松通过。在代码风格上，团队不需要进行过
多的讨论、争论，而应该把更多的精力放在重要问题的沟通和协调上。个性化应尽量
表现在系统架构和算法效率的提升上，而不是独特的代码风格上。
原始社会的部落冲突讲究个人蛮力，现代化战争贝lj 需要海陆空多兵种联合作战，
软件工程亦是如此。从软件小作坊发展到现在，凭一人之力编写大型软件系统已经是
不可能的了。跨团队的联合开发越来越常见， 需要一定的规范来保障沟通的有效性。
如果规范不一，就像图9-2 中的小鸭和小鸡对话一样，言语不通，一脸回中目。鸡同鸭
讲也恰恰形容了人与人之间沟通的痛点，自说自话， 无法沟通。
288
第9 章代码规约
图9-2 鸡同鸭讲
代码规约除代码风格之外， 还应该包括异常日志、数据库规约、安全规约、单元
测试等相关领域，旨在提升开发工程师之间的沟通效率， 本书的书名
的就是高效沟通与协、f午。大雁是种非常讲究团队配合的鸟类，它们飞翔的队开兰可以
有效地；咸少空气阻力。所以’ 封面选择大雁作为背景，传递团队沟通与协作的理念，
顺利达到共同的目标。虽然代码规约的价值是明确的， 但是要避免对代码规约有如下
错误认识
l …ii'- i 11 ~ti 、出， r, ...主，
程序员对代码的创造力与业务理解、建模能力、架构设计等都有关系。有人认为，
代码规约是把程序员变成流水线上的工人， 消灭创造力。非要类比的话，代码规约只
是墙上的安全生产规范， 并非定义工作内容本身（这才是程序员真正发挥创造力的地
方），代码规约让代码生产更加有序、更加高效。
1 . 伊悄飞人，理角5 届j二
代码是给三个群体看的编译器、编写者、维护者。编译器需要代码符合语法；
编写者需要代码符合自己的编程风格，维护者需要代码可读性强。在软件生命周期内，
编译器的时间单位是
编写者有可能成为维护者。此夕卡’ 个人对于团队的价值， 取决于他的稀缺性。有些
程序员认为自己写的代码只有自己能够看懂，比如if-e l se 嵌套5 层，再来一个for 循环，
才能显示出个人的不可替代性。实际上， 写代码的时候， 应该多从团队利益、公司战
略的角度考虑，遵从统一的代码规约， 助人也是助己， 在维护自己代码的时候， 也会
289
码出高效： Java 开发手册
更加从容。
3. 古未＇§ 61:- ｛＼：＇ 码干＇ if' 要t.Yt {;
代码部署到服务器上稳定运行后，即使没有任何功能的增加或删除，也不是永远
不需要修改的。代码具有时间维度、机器维度、框架维度等相关属性。时间维度，比
如千年虫问题或2038 问题等；机器维度，比如机器过保或机器换代等，框架维度，
比如JDK 升级或框架安全风险等。举个例子， JDK6 升级到JDK7 必须要及时修改代码，
使Comparator 满足JDK7 的新要求，否则Arrays.sort 会抛异常。诚如哲学家所述“人
不能两次踏进同一条河流”，代码的每一次部署，也是不可能完全相同的。所以没有
一成不变的代码。
4. 1干F j『....红， ： ;!)l ：（：立伫.JfT ，白人俨l 雯
如果一双鞋适合所有人的脚，那绝对是双废鞋。代码规约并不是寻找最优解，
而是寻找认知中的最大公约数。如果一个餐馆日料、法餐、湘菜、杭帮菜都做的话，
必然不是一个好餐馆。舍得，就是舍去小部分的意志，得到大格局上的成功。在制订
代码规约的过程中，一些规则向左走或向右走都有自身的合理性。比如返回集合时，
是否允许return null 值的问题，可归结为防御式编程理念与契约式编程理念不同的处
理方式。积累多次教训后，我们提倡防御式编程理念，明确允许返回为null 值。在共
识的规约面前， 我们应该放下成见，牺牲小我，成就大我。
综上所述，代码规约的意义如下·
( I ）码出高过标准统一， 提升沟通效率和协作效率，促使研发效能的提升。
( 2 ）码出质号。防患未然， 提升质量意识，降低故障率和维护成本，快速定位问题。
( 3 ）码出情怀， 追求卓越的工匠精神，打磨精品代码。
9.2 如何推动落地
任何出发点多么美好的规章制度，如果没有被落地执行到位，也终将是纸空文。
如何落地， 上令下达， 往往是很多标准类文件的痛点。在制订团队代码规约的时候，
往往是一帆风顺的， 但是真正到实际执行层面的时候，规约落地的过程总会遇到各种
推三阻四的情况。我们可以尝试从三个方面推动落地，第一， 立法透明，第二， 执法
坚定1 第三，组织支持。推进的节奏需要循序渐进，过于生硬的一刀切很可能触发团
队的抵触情绪， 甚至有些程序员会不惜辞职来捍卫自己的编程习惯。
I 290
第9 章代码规约
I. F 注：圣日可
在规约制订的过程中，保持全程透明与公开，充分讨论，反复审稿，谨慎定稿。
需要明确回答规约为什么这样制订，违反了会有什么后果。不论团队成员是否理解，
是否赞同，要让所有人觉得规约的制订是一个共同参与、共同讨论的过程，规约是共
同遵守的约定。但某些规则或左或右时，仅仅需要的是一个拍板。由于技术是不断向
前发展的，没有套代码规约可以流行数年而不更新，我们需要保持规约内容的与时
俱进。比如， 〈阿里巴巴Java 开发手册〉（下称〈手册〉）制订之初是JDK7 时代，
转眼间已经开始拥抱JDK 门， 底层技术发生了很大的变化，因此，规约需要不断地吸
收新的特性，并且修改不再适用于主流版本的相关内容。
2 .f ..法二玉、λ
对于规约的遵守符合典型的破窗理论， 如果团队某个成员完全不遵守共同的代码
规约，久而久之，出于人性的弱点，其他成员必然一个接一个地开始违反规约，最后
规约就是形同虚设。执法的过程需要面对两件事情第一，如何判断是否违反规约，
第二，如何进行奖惩。第一件事情，首先由程序自动分析保证，能够降低规约的遵守
成本。保障规约轻量化落地的技术包括自动化扫描、数据分析等配套工具，自动化扫
描最好提供全量和增量的配置，尤其是后者可以减少因为历史代码而增加的规约遵守
成本。规约扫描的相关数据分析是指形成数据报表，按时间、团队、应用各个维度进
行聚合，立体地分析违反规约的成员和代码，有助于长效地提升规约的生命力。〈手册〉
也提供相应的静态代码扫描工具，称为P3C 扫描插件，甚至提供部分自动纠错功能，
可以有效地提升开发效率。其次，在自动化分析的基础上，增加入工CodeReview 来
保证规约的落地，进一步判断无法通过自动扫描的规则是否被遵守。比如即使是多
个字段组合，只要业务特性唯一，就必须建成唯一索引，这样的规则很难通过自动化
分析进行判断， 需要Rev i ewer 根据业务逻辑进行人工审查。第二件事情，数据分析
的结果可以作为考核机制的参考指标，督促团队成员更好地遵守代码规约。此外， 对
于优秀代码， 可以通过代码秀或者代码墙分享出来，引导其他成员学习和主动遵守代
码规范。
3. 组织支抖
公司是否需要代码规约来提升整体开发效率，维护长效的开发秩序，它是个管
理决定，决定之后的执行需要某个部门进行专项推进。通常来说，推进规约落地是一
件成就感并不是特别强的脏活累活，并且经常会面对各种抵触行为，这时就需要组织
29丁
码出高效· Java 开发手册
给予充分的支持。组织支持包括三个方面第，给予负责人相应的考核权限；第二，
需要进行各种广泛而有力的宣传和引导；第三， 建立良性、有序、分享的长效代码文化。
9.3 手册纵览
现代软件行业的高速发展和复杂架构对于开发者的综合素质要求越来越高，因为
不仅是编程知识，其他维度的知识结构也会影响到软件的最终交付质量。比如，数据
库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导
致维护困难，没有鉴权的漏洞代码被黑客攻击等。〈手册〉全文被划分为编程规约、
异常日志、单元测试、安全规约、MySQL 数据库、工程结构、设计规约七大章节，
呈现出完整的程序员能力模型。衍生的问题是这样的知识体系是不是过于庞大？仅安
全规约扩展开来可以是上百页的资料。〈手册〉主要关注的是与开发紧密相关的知识点，
如果不知道水平权限校验，如果不知道建立合理的索引，如果不知道设计模式七大原
则，那么会是名合格的开发工程师吗？这本手册不是提倡深究所有的知识点而成为
安全专家、运维专家，而是关注与编码相关的生态知识，成为知识全面的开发工程师。
回顾2013 年的手册原型，最初的内容只涉及编程习惯和异常处理两个章节。数
据库规约是第一个被扩充的章节，是因为当时认知到数据库的设计极为轻快。建库建
表、字段名称、字段类型、字段长度的决定都比较随意，导致上层应用不得不花费更
大的代价去修正底层数据结构的缺陷。
比如，存储一对多的关系主要有四种实现方式，分别为JSON 方式、XML 方式、
逗号分隔、多字段存储，底层实现方式的不同选择决定着上层实现逻辑的巨大差异。
当时在技术评审会上， 开发工程师根本就没有认真评审四种实现方式的区别，直接选
择多字段存储，导致后期不断增加列来适配－对多的关系。推荐使用JSON 方式来进
行存储，因为解析框架比较成熟， 存储开销适中， 性能不错，并且数据存储格式可以
直接阅读。
再如，表达删除的字段名非常杂乱，类似于delete 、delete_ flag 、is_deleted 、is_
delete 等。甚至在同个应用中的多个表中，表达删除的字段名都没有统一，这导致
在进行数据分析时，总要小心翼翼，像玩文字游戏。另外，在同一个字段中，居然出
现11 0 和yi n 同时表达己删除和未删除的状态， 〈手册〉推荐使用i s deleted 的字段命
名， 使用110 表示已删除和未删除的状态。
为何将约束等级分为三级？传统观念上的代码规约只列出强制项，而不是把那些
1292
第9 重代码规约
无法衡量的推荐或参考写入规约。在〈手册〉诞生之前，业界并没有使用过代码规约
分级制。什么都是强制项的“规范”，更像是一纸冰冷的法律文书。在〈手册〉的制
订过程中，发现有些规则可以量化，有些规贝lj 难以量化，根据约束力强弱及故障敏感性，
规约依次分级为强制、推荐、参考三大类。强制是一种命令型的约束，表达的是协作
痛点或故障隐患。推荐是一种语气比较强的提倡，即使不这样做也不会产生严重的问
题，但如果团队致遵守会使代码结构更清晰，团队协作更高效。参考分成两种情
况第一种是无法用规则量化的要求，比如避免出现重复的代码，即Don' t Repeat
Yourself:，第二种向左向右均可以，仅提出种期望，自由度由开发工程师自己把握，
比如在服务层的方法命名中，获取单个对象的方法用get 作为前缀等。
扩展的说明、正例、反例希望达到什么样的目的？知其然，知其不然，深度地理
解规则背后的思想。如果只是冷冰冰的规则，对于阅读者的理解和记忆都是很大的挑
战。〈手册〉希望读者能够非常舒心地完成阅读，掩卷遐思，亦有所得。其中“说明”
对内容做了引申和解释，为求知其然； “正例”展示什么样的编码、配置、实现方式
是被倡导的； “反例”标识需要提防的雷区，以及真实的错误案例，让人知其不然。
考虑到方便离线查看， 〈手册〉是以PDF 文件的方式进行发布的，共有9 个版本。
2017 年2 月9 日，第一个版本正式公布，引起社区热议。紧接着5 月20 日，吸纳社
区意见，修正错误描述，发布完美版。9 月25 日，增加单元测试规约，发布终极版。
但是，注意到软件设计领域没有比较好的指导原则， 2018 年5 月20 日，增加16 条
设计规约，发布详尽版。版本命名是有当时特定的背景考量的，每个版本都有相应的
版本号列在〈手册〉最后的附表中，目前已经转为在线维护。
9.4 聊聊成长
成长并没有直线式的捷径， “不走弯路就是捷径”这个观点未必正确。弯路是成
长的必经之路，我们在成长的路上需要注意的是保证弯路的前进大方向与直线的行进
方向基本一致。南辗北辙消耗的是时间成本、精力成本、机会成本，尤其机会成本往
往是可遇不可求的。弯路上的泥泞、徘徊、痛苦等都是成长的养分，一昧地想速成某
种能力，反而适得其反。穷实基础，方能建万丈高楼。浮沙筑高台，那只是极少数天
才的专利而已。
代码能力的提升就是不断磨炼、不断尝试、不断纠锚的成长过程。编程实战能力
是开发工程师的核心能力，现在越来越多的企业会进行在线编程能力测试，甚至在计
293 I
E马出高效： Java 开发手册
算机类博士的相关招聘中，也会有此类要求。优秀的代码能力应该体现在运行效率和
架构设计上。运行效率取决于对语言的合理运用和算法设计的合理性上。要尽量避免
〈手册〉中提到很多关于Java 语言些低效的处理方式。在算法设计上，可以参考
本书的“ 数据结构与集合川章节，尽可能写出高质量的算法代码，而架构设计，需要
融会贯通，使代码优雅、具有扩展性。
孔子曰。“学而不思则罔，思而不学则殆。”如果只是把书架上的书的数量来衡
量自己的技术功底，那真错了，真正的书架应在心中，反复地学习、实践，再穷实理论。
如果缺乏思考，就会因为不能深刻理解书本的意义而不能有效地在实际中运用好这些
知识，甚至陷入更深的迷茫中。我们只有把学习和思考结合起来，才能把知识转为己用。
笔者很喜欢在学习的同时作深度总结，至今沉淀了超过2000 页的笔记，分为四个文档
搜集、整理、专题、哲学。知识快速进入搜集区，包括书上的、听到的、看到的、疑
惑的；不断地去思考、复核并总结之后，沉淀在整理区。这是点维度的总结，把这些
点的知识串成个专题是线维度的总结；而最后的知识上升到哲学方法论级别，是面
维度的总结。
我们考完驾照的时候，总想找机会显示一下自己的驾驶技术。同理，学习和体会
计算机技术，也要敢于到班门去弄斧。提倡把自己丑陋的代码在比自己更优秀的人面
前晒出来。含蓄的结果就是以为自己是宇宙中心，别人写的代码都不如我，自己的风
格总是正道。在一度火爆的“向代码致敬，寻找你的第83 行”活动中，最后的获奖
者感言，在这个过程中收获了成长，正因为大神们的指导，打开了自己知识的广度，
找到了自己的不足之处。
最后，做个有技术情怀的人。技术情怀总结成两个关键词，热爱、卓越。热爱
是一种源动力，卓越是一种境界。兴趣是最好的老师，也是最好的动力。而热爱是
种信念，即使痛苦，也不会让你背离这份事业和内心的执着。对技术的热爱，让人勇
于追根究底，勇于坐冷板凳，勇于回馈别人。极致与卓越，似乎是个意思，即出类
拔萃，超出期望。技术情怀提倡我们追求极致式的卓越，把卓越再往前提升。不管一
个人如何卓越与优秀，都要学会自我驱动，持续进步，追求个人内心的极致。因为卓
越，所以经典，只有这样百尺竿头，才能更进一步。仰望星空的同时，是脚踏实地，
这样才能不断地学习和打磨自己。
在成长的路上，愿〈码出高效Java 开发手册〉和你一路同行，成为良师益友，
一起成长，一起携手面对技术难题，走向更精彩的明天｜
I 294
本书简介
《码出高效· Ja va 开发手册》~） 实战为
中心，从编程相关的计算机基础知识说起，
以新颖的角度，全面阐述面向对象理论，逐步
深入探索－位优秀开发工程师的成长过程。
比如．如何驾轻就熟地使用各类集合框架，
如何得心应手地处理高并发多线程问题， 如何
！｜｜页真自然地写出可读性强、可维护性好的优雅
代码。
本书旁征博引、文风轻松，秉持“国胜于
表， 表胜于言”的理念z 紧？日学以致用、学以
精进的目标，结合阿里巴巴实践经验和故障
案例，与底层；原码解中斤融会贯通，深入浅出
地把知识客观、立体地呈现出来，是适合初级
入门、中级进阶、高级修炼的“ 全天候’3 图书。
本书以打造民族标杆图书为己任3 追求极
致，打磨精昂，在技术广度和深度上兼具比
较强的参考性，相信可以便读者在计算机综
合素质上有大幅的提升。
欢迎您加入读者群，您可以在群里提任何
关于本书的建议和意见。我们也会在该群
中发布本书的所高动态和新闰。
微信发送34909
加入本书共读群
.,_ ..... .:,. .... .. 博文视点·IT 出版膜舰晶牌
;;;;;.,J;,-;;;;;;,;,,;.com~cn 技术凝聚实力· 专业创新出版
E辑... ~－－·哩’‘’、，，旨在搞
我们一起合作写经济发展的代码，写未来社会发展的每一行代码，
码出高效，码出未来。
一一马云
稳定是一切基础设施的重中之童，以规范、合理的设计写出更高质
量的代码， ~）＿技术解决技术问题。
一行癫
写下一行只要1 分钟，但未来会被寸t代工程师i卖很多次、改很多次。
代码的可读性与可1由户性， 是费心目中虫到t码的第一标准。
一鲁肃