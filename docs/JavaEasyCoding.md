# **JavaEasyCoding**



## 第1章 计算机基础

大道至简，盘古生其中。计算机的基础世界一切都是由 0 与 1 组成的。

**追根究底**是深度分析和解决问题、提升程序员素质的关键所在，有助于编写高质量的代码。基础知识的深度认知决定着知识上层建筑的延展性。试问， 对于如下的基础知识，你的认知是否足够清晰呢？
·	 位移运算可以快速地实现乘除运算，那位移时要注意什么？
· 	浮点数的存储与计算为什么总会产生微小的误差？
· 	乱码产生的根源是什么？
· 	代码执行时， CPU 是如何与内存配合完成程序使命的？
· 	网络连接资源耗尽的问题本质是什么？
· 	黑客攻击的通常套路是什么？如何有效地防止？
本章从编程的角度深度探讨计算机组成原理、计算机网络、信息安全等相关内容，与具体编程语言无关。

### 1.1 走进0与1的世界

### 1.2 浮点数

### 1.3 字符集与乱码

### 1.4 CPU 与内存

### 1.5 TCP/IP

### 1.6 信息安全

### 1.7 编程语言的发展



## 第2章 面向对象

”一树菩提，一‘门’一世界。” 一切皆对象，万物有三问·我是谁？我从哪里来？我到哪里去？

### 2.1 OOP 理念

### 2.2 初识Java

### 2.3 类

### 2.4 方法

### 2.5 重载

### 2 .6 泛型

### 2.7 数据类型

#### 2.7.1 基本数据类型

#### 2.7.2 包装类型

#### 2.7.3 字符串

​		字符串类型是常用的数据类型，它在 JVM 中的地位并不比基本数据类型低，JVM 对字符串也做了特殊处理。String 就像是流落到基本数据类型部落的一个副首领，虽然很神气， 但是终归难以得到族人对它的认同，毕竟它是堆上分配来的。

​		字符串相关类型主要有三种String 、StringBuilder、StringBuffer 。

​		String 是只读字符串，典型的 immutable 对象，对它的任何改动，其实都是创建一个新对象，再把引用指向该对象。String 对象赋值操作后，会在常量池中进行缓存，如果下次申请创建对象时，缓存中已经存在， 则直接返回相应引用给创建者。

​		**StringBuffer 则可以在原对象上进行修改， 是线程安全的。**JDK5 引入的StringBuilder 与 StringBuffer 均继承自 AbstractStringBuiIder ， 两个子类的很多方法都是通过 "super.方法()"  的方式调用抽象父类中的方法， 此抽象类在内部与String 一样， 也是以字符数组的形式存储字符串的。**StringBuilder 是非线程安全的**， 把是否需要进行多线程加锁交给工程师决定，操作效率比StringBuffer 高。线程安全的对象先产生是因为计算机的发展总是从单线程到多线程，从单机到分布式。

​		在非基本数据类型的对象中， String 是仅支持直接相加操作的对象；这样操作比较方便， 但在循环体内，字符串的连接方式应该使用 StringBuilder 的 append 方法进行扩展。如下的方式是不推荐的

```java
String str = "start";
for (int i = O; i < 100; i++) {
	str = str + "hello" ;
}
```

​		此段代码的内部实现逻辑是每次循环都会 new 个StringBuilder 对象， 然后进行append 操作，最后通过toString 方法返回 String 对象， 不但造成了内存资源浪费，而且性能更差。







## 第3章 代码风格

流水淡，碧天长，鸿雁成行。编码风格，简捷清爽，反引无限风光。









## 第4章 走进JVM

云开方见日，潮尽炉峰出。揭开JVM的神秘面纱，探寻底层的实现原理。







## 第5章 异常与日志

“欲渡黄河冰塞川，将登太行雪满山。” 系统运行，风云不测，睹始知终，秋去冬来，一叶落而知秋。











## 第6章 数据结构与集合

​		廊腰缦回，檐牙高啄。纵使相同一砖一瓦，不同雕琢设计，亦生错落有致的廊榭美景。	数据结构的魅力也缘于此中道理。			

​		在代码世界中，集合是对 Collection 一词的翻译，事实上这么翻译仍不够准确。
​		在数学世界中，集合是指具有某种特定性质的事物汇成的集体，对应英文是Set ， 它具有确定性、无序性、互异性等特点。而  **Java 中的集合表达的是数据结构的载体 **，并未对应于数学概念上的集合，  **Java 中的集合元素可以是有序的，也可以是重复的，与数学中的要求不一样 。**本书中其他地方出现的集合概念，都指的是Collection ， 用来保存各种各样的对象。我们经常说，"程序=数据结构+算法"。 **集合作为数据结构的载体， 可对元素进行加工和输出，以一定的算法实现最基本的增删改查功能，因此集合是所有编程语言的基础。**
​		在进入高并发编程时代后，由集合引发的相关故障占比越来越高。比如，多线程共享集合时出现的脏数据问题，某些集合在数据扩容时出现节点之间的死链问题；写多读少的场景误用某些集合导致性能下降问题等。本章将从数组讲起，引申到集合框架，再到重点集合源码分析， 最后介绍高并发集合框架，目的是对集合的了解成竹在
胸、运用得心应手。	

### 6.1 数据结构	

#### 6.1.1 数据结构定义

​		**数据结构是什么？** 网络上的一些定义十分抽象且各不相同，学习完之后，反而对数据结构的概念更加模糊、更有敬畏之心。**数据结构是指  (1)逻辑意义上 的 (2)数据组织方式 及其相应的(3)处理方式。**

​		( 1）什么是***逻辑意义***？ **数据结构的抽象表达非常丰富，而实际物理存储的方式相对单一。**比如，二叉树在磁盘中的存储真的是树形排列吗？并非如此。树的存储可能是**基于物理上的<u>顺序存储</u>方式**，可以理解为一个格子一个格子连续地放， 设想有7个节点的二叉树，第一个格子放根节点，第二个恪子放左子树根节点，并且根据引用知道左叶子在后续的哪个格子里，第三个格子放右子树根节点，依此类推。此外，树的存储也可能是**基于物理上的<u>链式存储</u>方式**，这里不再详细展开。

​		( 2） 什么是***数据组织方式***？ <u>逻辑意义上的组织方式有很多，比如树、图、队列、哈希等。树可以是二叉树、三叉树、B＋ 树等，图可以是有向图或无向图，队列是先进先出的线性结构；哈希是根据某种算法直接定位的数据组织方式。</u>

​		( 3 ) 什么是***数据处理方式***？ <u>在既定的数据组织方式上，以某种特定的算法实现数据的增加、删除、修改、查找和遍历。</u>不同的数据处理方式往往存在着非常大的性能差异。



#### 6.1.2 数据结构分类  //TODO

数据结构是算法实现的基石， 它是－种体现基础逻辑思维的内功心法，也是计算
机从业人员能力图谱中的重要一项。如果完全不懂数据结构，很难写出优秀的代码。
有缺陷的底层数据结构容易导致系统风险高、可扩展性差，所以需要认真地对数据结
构进行设计和评审。从直接前继和直接后继个数的维度来看，大体可以将数据结构分
为以下四类。
( I ）线↑生结构0 至l 个直接前继和直接后继。当线性结构非空时，有唯－的
首元素和尾元素，除两者外， 所有的元素都有唯一的直接前继和直接后继。线性结
构包括顺序表、链表、枝、队列等，其中枝和队列是访问受限的结构。枝是后进先
出，即Last-In, First-Out ，简称LIFO ；队列是先进先出，即First-In, First-Out ，简称
FIFO 。
( 2 ）树＃均0 至1 个直接前继和0 至n 个直接后继（ n 大于或等于2 ）。树是
一种非常重要的有层次的非线性数据结构，像自然界的树一样。由于树结构比较稳定
和均衡，在计算机领域中得到广泛应用。
( 3 ）可言给啕0 至n 个直接前继和直接后继（ n 大于或等于2 ）。图结构包括简
单图、多重图、有向图和无向图等。
( 4 ）晗养均构没有直接前继和直接后继。晗希结构通过某种特定的晗希函数
将索51 与存储的值关联起来， 它是一种查找效率非常高的数据结构。
不同的数据组织方式和处理方式带来了一个新的问题·如何衡量数据处理的性
能。数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储设备越来越便宜的
情况下，时间复杂度成为重点考量的因素。算法时间复杂度是种衡量计算性能的指
标， 反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能够反映出算
法性能的优劣与否。而这个量级通常用大写的0 和一个函数描述， 如O(n 3） 表示程序
执行时间随输入规模呈现三次方倍的增长， 这是比较差的算法实现。从最好到最坏的
常用算法复杂度排序如下：常数级0(1 ）、对数级O(logn ）、线性级0伊）、线性对数级
。（nlogn ） 、平方级。但2）、立方级O(n 3）、指数级0(2＂） 等。有人觉得在实际编程中没
有必要去纠结算法复杂度，因为现实中的数据量有限，执行时间相差无几。但是，数
据规模并非静止不变，优秀的程序实现不会因为数据规模的急剧上升导致程序性能的
急剧下降。



最后以“ 猜数字” 为例进一步理解时间复杂度， 主持人从1 ～ 100 的范围内任选
一个数字， 玩家随机猜一个数， 如果没有猜中， 主持人会提示猜大了还是猜小了， 继
续这样的循环，直到猜对为止。显而易见， 如果要猜测， 最多要猜100 次，最少只用
猜l 次。经验表明， 玩家总会往中间砍一段，平均猜测次数总在七八次左右。通过模
拟程序运行l 亿次， 完全随机的情况下，平均猜测的次数是7.47 次， 近似二分法猜
测的是5 . 8 次， 时间复杂度为O(logn ） 。

### 6.2 集合框架图



### 6.3 集合初始化	



### 6.4 数组与集合



### 6.5 集合与泛型



### 6.6 元素的比较



### 6. 7 fail-fast 机制



### 6.8 Map 类集合

#### 6.8.1 红黑树

#### 6.8.2 TreeMap

#### 6.8.3 HashMap

#### 6.8.4 ConcurrentHashMap		









## 第7章 并发与多线程

​		是以驷牡异力，而六辔如琴，并驾齐驱，而一毂统辐：驭文之法，有似于此。行文如此，并发亦如此。











## 第8章 单元测试

​		祸乱生于疏忽，单元测试先于交付。穿越暂时黑暗的时光隧道，才能迎来系统的曙光。









## 第9章 代码规约

车同轨、书同文。手册源起，不忘初心，伯牙子期，琴瑟共鸣。





























